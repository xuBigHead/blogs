---
layout: post
title: Go 常量和变量.md
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# Go 常量和变量

## 概述

基本类型的字面量表示（除了`false`和`true`）都属于无名常量（unnamed constant），或者叫字面常量（literal constant），`false`和`true`是预声明的两个具名常量。本文将介绍如何声明自定义的具名常量。所有变量都是可以寻址的，所有常量都是不可被寻址。



### 组合字面量

下面四种类型的值（除了切片和映射类型的零值）可以用组合字面量表示：

| 类型（`T`） |  `T{}`是类型`T`的零值  |
| :---------: | :--------------------: |
| 结构体类型  |           是           |
|  数组类型   |           是           |
|  切片类型   | 否 （零值用`nil`表示） |
|  映射类型   | 否 （零值用`nil`表示） |



切片和数组组合字面量中的索引必须是非负常量。

```go
func TestArrayAndSliceCompositeLiteralsIndexMustBeNonNegativeIntegerConstant(t *testing.T) {
	var k = 1
	_ = [2]int{k: 1} // error: 索引必须为一个常量
	_ = []int{k: 1}  // error: 索引必须为一个常量
}
```



切片、数组、映射组合字面量的常量索引和键值不能重复。

```go
func TestArrayAndSliceCompositeLiteralsIndexMustNotDuplicate(t *testing.T) {
    _ = []bool{0: false, 1: true, 1: true}        // Duplicate index: 1
    _ = [...]string{0: "foo", 1: "bar", 0: "foo"} // Duplicate index: 0
    _ = map[string]int{"foo": 1, "foo": 2}        // Duplicate key foo in the map literal
}
```

## 常量

### 类型不确定常量

在Go中，有些值的类型是不确定的，换句话说，有些值的类型有很多可能性，这些值称为类型不确定值（untyped value）。大多数类型不确定值各自都有一个默认类型，除了预声明的`nil`，`nil`是没有默认类型的。与类型不确定值相对应的概念称为类型确定值（typed value）。字面常量（无名常量）都属于类型不确定值，Go中大多数的类型不确定值都属于字面常量和具名常量，少数类型不确定值包括刚提到的`nil`和某些操作的布尔返回值。一个字面常量的默认类型取决于它为何种字面量形式：

- 一个字符串字面量的默认类型是预声明的`string`类型；
- 一个布尔字面量的默认类型是预声明的`bool`类型；
- 一个整数型字面量的默认类型是预声明的`int`类型；
- 一个rune字面量的默认类型是预声明的`rune`（亦即`int32`）类型；
- 一个浮点数字面量的默认类型是预声明的`float64`类型；
- 如果一个字面量含有虚部字面量，则此字面量的默认类型是预声明的`complex128`类型；



#### 显式类型转换

显式类型转换的形式为`T(v)`，其表示将一个值`v`转换为类型`T`。编译器将`T(v)`的转换结果视为一个类型为`T`的类型确定值。对于特定的类型`T`，`T(v)`并非对任意的值`v`都合法。对于类型不确定常量值`v`，有两种情形显式转换`T(v)`是合法的：

1. `v`可以表示为`T`类型的一个值，转换结果为类型为`T`的类型确定常量值；
2. `v`的默认类型是整数类型（`int`或者`rune`）并且`T`是字符串类型，转换`T(v)`将`v`看作是一个Unicode码点，转换结果为一个类型为`T`的字符串常量。此字符串常量只包含一个Unicode码点，并且可以看作是此Unicode码点的UTF-8表示形式。对于不在合法的Unicode码点取值范围内的整数`v`，转换结果等同于字符串字面量`"\uFFFD"`（亦即`"\xef\xbf\xbd"`），`0xFFFD`是Unicode标准中的（非法码点的）替换字符值。

事实上，第二种情形并不要求`v`必须是一个常量，如果`v`是一个常量，则转换结果也是一个常量；如果`v`不是一个常量，则转换结果也不是一个常量。



> 今后的Go版本可能只允许rune或byte整数被转换为字符串，从Go官方工具链1.15版本开始，`go vet`命令会对从非rune和非byte整数到字符串的转换做出警告。



一些合法的转换例子：

```go
complex128(1 + -1e-1000i) // 结果为complex128类型的1.0+0.0i，虚部被舍入了
float32(0.49999999) // 结果为float32类型的0.5，这里也舍入了
float32(17000000000000000) // 只要目标类型不是整数类型，舍入都是允许的
float32(123)
uint(1.0)
int8(-123)
int16(6+0i)
complex128(789)

string(65)          // "A"
string('A')         // "A"
string('\u68ee')    // "森"
string(-1)          // "\uFFFD"
string(0xFFFD)      // "\uFFFD"
string(0x2FFFFFFFF) // "\uFFFD"
```



下面是一些非法的转换：

```go
int(1.23)     // 1.23不能被表示为int类型值
uint8(-1)     // -1不能被表示为uint8类型值
float64(1+2i) // 1+2i不能被表示为float64类型值
float64(-1e1000) // -1e+1000不能被表示为float64类型值，不允许溢出
int(0x10000000000000000) // 0x10000000000000000做为int值将溢出
string(65.0) // 字面量65.0的默认类型是float64（不是一个整数类型）
string(66+0i) // 66+0i的默认类型是complex128（不是一个整数类型）
```



从上面的例子可以看出，一个类型不确定数字值所表示的值可能溢出它的默认类型的表示范围，比如上例中的`-1e1000`和`0x10000000000000000`。一个溢出了它的默认类型的表示范围的类型不确定数字值是不能被转换到它的默认类型的（将编译报错）。有时一个显式转换形式必须被写成`(T)(v)`以免发生歧义，这种情况多发生在`T`不为一个标识符的时候。



#### 类型推断

Go支持类型推断（type deduction or type inference），类型推断是指在某些场合下在代码中使用一些类型不确定值，编译器会自动推断出这些类型不确定值在特定情景下应被视为某些特定类型的值。

如果某处需要一个特定类型的值并且一个类型不确定值可以表示为此特定类型的值，则此类型不确定值可以使用在此处。Go编译器将此类型不确定值视为此特定类型的类型确定值。这种情形常常出现在运算符运算、函数调用和赋值语句中。有些场景对某些类型不确定值并没有特定的类型要求，在这种情况下，Go编译器将这些类型不确定值视为它们各自的默认类型的类型确定值。

上述两条类型推断规则可以被视为隐式转换规则。



### 具名常量声明

和无名字面常量一样，具名常量（constant）也必须都是布尔、数字或者字符串值，在Go中，关键字`const`用来声明具名常量，下面是一些常量声明的例子：

```go
// 声明了两个单独的具名常量，非ASCII字符可以用做标识符
const π = 3.1416
const Pi = π // 等价于：const Pi = 3.1416

// 声明了一组具名常量。
const (
	No         = !Yes
	Yes        = true
	MaxDegrees = 360
	Unit       = "弧度"
)

func main() {
	// 声明了三个局部具名常量。
	const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "度"
}
```



Go白皮书把上面每行含有一个等号`=`的语句称为一个常量描述（constant specification）。 每个`const`关键字对应一个常量声明。一个常量声明中可以有若干个常量描述。 上面的例子中含有4个常量声明。除了第3个，其它的常量声明中都各自只有一个常量描述。 第3个常量声明中有4个常量描述。

在上面的例子中，符号`*`是一个乘法运算符， 符号`!`是一个布尔取否运算符。 运算符将在[下一篇文章](https://gfw.go101.org/article/operators.html)中详述。

常量声明中的等号`=`表示“绑定”而非“赋值”。 每个常量描述将一个或多个字面量绑定到各自对应的具名常量上。 或者说，每个具名常量其实代表着一个字面常量。

在上面的例子中，具名常量`π`和`Pi`都绑定到（或者说代表着）字面常量`3.1416`。 这两个具名常量可以在程序代码中被多次使用，从而有效避免了字面常量`3.1416`在代码中出现在多处。 如果字面常量`3.1416`在代码中出现在多处， 当我们以后欲将`3.1416`改为`3.14`的时候，所有出现在代码中的`3.1416`都得逐个修改。 有了具名常量的帮助，我们只需修改对应常量描述中的`3.1416`即可。 这是常量声明的主要作用。当然常量声明也可常常增加代码的可读性（代码即注释）。

以后，我们使用非常量这一术语表示不是常量的值。 下一节将要介绍的变量就属于非常量。

注意，常量可以直接声明在包中，也可以声明在函数体中。 声明在函数体中的常量称为局部常量（local constant），直接声明在包中的常量称为包级常量（package-level constant）。 包级常量也常常被称为全局常量。

包级常量声明中的常量描述的顺序并不重要。比如在上面的例子中， 常量描述`No`和`Yes`的顺序可以掉换一下。

上面例子中声明的所有常量都是类型不确定的。 它们各自的默认类型和它们各自代表的字面量的默认类型是一样的。



#### 类型确定具名常量

在声明常量时指定常量的确切类型，这样声明的常量称为**类型确定具名常量**。

```go
const X float32 = 3.14

const (
	A, B int64   = -3, 5
	Y    float32 = 2.718
)
```



如果常量描述中包含多个类型确定常量，则这些常量的类型必然是一样的，比如上例中的`A`和`B`。也可以使用显式类型转换来声明类型确定常量，下面的例子和上面的例子是完全等价的。

```go
const X = float32(3.14)

const (
	A, B = int64(-3), int64(5)
	Y    = float32(2.718)
)
```



欲将一个字面常量绑定到一个类型确定具名常量上，此字面常量必须能够表示为此常量的确定类型的值，否则，编译将报错。

```go
const a uint8 = 256             // error: 256溢出uint8
const b = uint8(255) + uint8(1) // error: 256溢出uint8
const c = int8(-128) / int8(-1) // error: 128溢出int8
const MaxUint_a = uint(^0)      // error: -1溢出uint
const MaxUint_b uint = ^0       // error: -1溢出uint
```



下面这个类型确定常量声明在64位的操作系统上是合法的，但在32位的操作系统上是非法的，因为一个`uint`值在32位操作系统上的尺寸是32位， `(1 << 64) - 1`将溢出`uint`。

```go
const MaxUint uint = (1 << 64) - 1
// 可以用下述方式来声明一个代表着最大`uint`值的常量，该方式在64位和32位的操作系统上都是合法的。
const ValidMaxUint = ^uint(0)
// 使用下面这个常量声明来声明一个具名常量来表示最大的`int`值
const MaxInt = int(^uint(0) >> 1)
```



使用类似的方法，可以声明一个常量来表示当前操作系统的位数，或者检查当前操作系统是32位的还是64位的。

```go
const NativeWordBits = 32 << (^uint(0) >> 63) // 64 or 32
const Is64bitOS = ^uint(0) >> 63 != 0 // true
const Is32bitOS = ^uint(0) >> 32 == 0 // false
```



#### 常量声明中的自动补全

在一个包含多个常量描述的常量声明中，除了第一个常量描述，其它后续的常量描述都可以只包含标识符列表部分，Go编译器将通过照抄前面最紧挨的一个完整的常量描述来自动补全不完整的常量描述。

```go
const (
	X float32 = 3.14
	Y                // 这里必须只有一个标识符
	Z                // 这里必须只有一个标识符

	A, B = "Go", "language"
	C, _ // 空标识符是必需的，如果上一行是一个不完整的常量描述的话
)
```



在编译阶段，编译器会将上述代码自动补全为下述所示：

```go
const (
	X float32 = 3.14
	Y float32 = 3.14
	Z float32 = 3.14

	A, B = "Go", "language"
	C, _ = "Go", "language"
)
```



#### `iota`

`iota`是Go中预声明的特殊的具名常量，`iota`被预声明为`0`，但是它的值在编译阶段并非恒定。当此预声明的`iota`出现在一个常量声明中的时候，它的值在第n个常量描述中的值为`n`（从0开始），所以`iota`只对含有多个常量描述的常量声明有意义，`iota`和常量描述自动补全相结合时能够给Go编程带来很大便利。

```go
func main() {
	const (
		k = 3 // 在此处，iota == 0

		m float32 = iota + .5 // m float32 = 1 + .5
		n                     // n float32 = 2 + .5

		p = 9             // 在此处，iota == 3
		q = iota * 2      // q = 4 * 2
		_                 // _ = 5 * 2
		r                 // r = 6 * 2
		s, t = iota, iota // s, t = 7, 7
		u, v              // u, v = 8, 8
		_, w              // _, w = 9, 9
	)

	const x = iota // x = 0 （iota == 0）
	const (
		y = iota // y = 0 （iota == 0）
		z        // z = 1
	)
}
```



上面的例子只是展示了一下如何使用`iota`，在实际编程中，应该用有意义的方式使用方式，比如：

```go
const (
	Failed = iota - 1 // == -1
	Unknown           // == 0
	Succeeded         // == 1
)

const (
	Readable = 1 << iota // == 1
	Writable             // == 2
	Executable           // == 4
)
```



一般常量值的值固定不变，常量值可以被赋给变量值。但是预声明的`iota`是一个绑定了`0`的常量，它的值并不固定。在一个包含多个常量描述的常量声明中，如果一个`iota`的值出现在一个常量描述中，则它的值将被自动调整为此常量描述在此常量声明中的次序值，尽管此调整发生在编译时刻。`iota`只能被用于常量声明中，它不能被赋给变量。



### 更多关于常量声明

#### 类型不确定常量值可以溢出其默认类型

下例中的三个类型不确定常量均溢出了它们各自的默认类型，但是此程序编译和运行都没问题。

```go
package main

// 三个类型不确定常量。
const n = 1 << 64          // 默认类型为int
const r = 'a' + 0x7FFFFFFF // 默认类型为rune
const x = 2e+308           // 默认类型为float64

func main() {
	_ = n >> 2
	_ = r - 0x7FFFFFFF
	_ = x / 2
}
```



但是下面这个程序编译不通过，因为三个声明的常量为类型确定常量。

```go
package main

// 三个类型确定常量。
const n int = 1 << 64           // error: 溢出int
const r rune = 'a' + 0x7FFFFFFF // error: 溢出rune
const x float64 = 2e+308        // error: 溢出float64

func main() {}
```



#### 常量标识符在编译时被其字面量所替代

在编译阶段，所有的标识符将被它们各自绑定的字面量所替代。如果运算中的所有运算数都为常量，则此运算的结果也为常量，或者说，此运算将在编译阶段就被估值。

```go
package main

const X = 3
const Y = X + X
var a = X

func main() {
	b := Y
	println(a, b, X, Y)
}
```



上面这段程序代码将在编译阶段被重写为下面这样：

```go
package main

var a = 3

func main() {
	b := 6
	println(a, b, 3, 6)
}
```



### 编译期常量校验

#### 常量大小比较限制

下面是一些方法用来在编译时刻保证常量`N`不小于另一个常量`M`：

```go
// 下面任一行均可保证N >= M
func _(x []int) {_ = x[N-M]}
func _(){_ = []int{N-M: 0}}
func _([N-M]int){}
var _ [N-M]int
const _ uint = N-M
type _ [N-M]int

// 如果M和N都是正整数常量，也可以使用下一行所示的方法
var _ uint = N/M - 1

// 利用容器组合字面量中不能出现重复的常量键值进行常量大小的比较
var _ = map[bool]struct{}{false: struct{}{}, N>=M: struct{}{}}

// 上述方法看上去有些冗长，但是更加通用，可以用来断言任何条件。也可以如下面所示不必很冗长，但需要多消耗一点内存
var _ = map[bool]int{false: 0, N>=M: 1}
```



#### 常量大小相等限制

下面是断言两个整数常量相等的方法：

```go
var _ [N-M]int; var _ [M-N]int
type _ [N-M]int; type _ [M-N]int
const _, _ uint = N-M, M-N
func _([N-M]int, [M-N]int) {}

var _ = map[bool]int{false: 0, M==N: 1}

var _ = [1]int{M-N: 0} // 唯一被允许的元素索引下标为0
var _ = [1]int{}[M-N]  // 唯一被允许的元素索引下标为0

var _ [N-M]int = [M-N]int{}
```

​	

#### 非空字符串限制

下面是一些用来断言一个常量字符串是不是一个空串的方法。

```go
type _ [len(aStringConstant)-1]int
var _ = map[bool]int{false: 0, aStringConstant != "": 1}
var _ = aStringConstant[:1]
var _ = aStringConstant[0]
const _ = 1/len(aStringConstant)
```



有时候，为了避免包级变量消耗太多的内存，我们可以把断言代码放在一个名为空标识符的函数体中。 例如：

```go
func _() {
	var _ = map[bool]int{false: 0, N>=M: 1}
	var _ [N-M]int
}
```



## 变量

变量是可以被更改的具名的值，所有的变量值都是类型确定值，声明变量时必须显示或隐式指定变量类型。



### 变量声明和赋值操作

Go语言有标准和短声明两种变量声明形式，短声明形式只能用来声明局部变量。



#### 标准变量声明形式

标准变量声明形式语句起始于一个`var`关键字，每个`var`关键字跟随着一个变量名，每个变量名必须为一个标识符。和常量声明一样，多个同类型的变量可以在一条语句中被声明。

```go
var lang, website string = "Go", "https://golang.org"
var compiled, dynamic bool = true, false
var announceYear int = 2009
```



完整形式的标准变量声明形式有些罗嗦，很少使用，另外两种变种形式用得更广泛一些：

- 省略变量类型，但仍指定了初始值，编译器将初始值的字面量形式的默认类型作为变量的类型；
- 省略初始值，但仍指定了变量类型，编译器将变量类型的零值做为变量的初始值；



如果初始值是类型确定值，则对应声明的变量的类型将被推断为此初始值的类型；如果初始值是类型不确定值，则对应声明的变量的类型将被推断为此初始值的默认类型。此过程中的类型推断可以被视为隐式类型转换。在这种变种中，同时声明的多个变量的类型可以不一样。

```go
// 省略类型的标准变量声明示例如下，每个声明的变量的类型为它们各自的初始值的字面量形式的默认类型
var lang, dynamic = "Go", false // 变量lang和dynamic的类型将被推断为内置类型string和bool
var compiled, announceYear = true, 2009 // 变量compiled和announceYear的类型将被推断为内置类型bool和int
var website = "https://golang.org" // 变量website的类型将被推断为内置类型string

// 省略初始值的标准变量声明示例如下，每个声明的变量的初始值为它们各自的类型的零值
var lang, website string      // 两者都被初始化为空字符串
var interpreted, dynamic bool // 两者都被初始化为false
var n int                     // 被初始化为0
```



和常量声明一样，多个变量可以用一对小括号组团在一起被声明，一般来说，将多个相关的变量声明在一起将增强代码的可读性。

```go
var (
	lang, bornYear, compiled     = "Go", 2007, true
	announceAt, releaseAt    int = 2009, 2012
	createdBy, website       string
)
```



#### 纯赋值语句

赋值语句语法规范如下：

- 等号`=`表示赋值，变量被声明之后，值可以被通过纯赋值语句来修改，多个变量可以同时在一条赋值语句中被修改；

- 赋值语句等号左边的表达式必须是一个可寻址的值、一个映射元素或者一个空标识符，空标识符表示不关心对应的目标值；

- 空标识符不可被用做源值；

- 常量是不可改变的（不可寻址的），所以常量不能做为目标值出现在纯赋值语句的左边，变量既可以出现在纯赋值语句的左边用做目标值，也可以出现在右边用做源值;

- 对于标准编译器来说，赋值不是原子操作。

  

一些纯赋值语句的例子：

```go
const N = 123
var x int
var y, z float32

N = 789 // error: N是一个不可变量
y = N   // ok: N被隐式转换为类型float32
x = y   // error: 类型不匹配
x = N   // ok: N被隐式转换为类型int
y = x   // error: 类型不匹配
z = y   // ok
_ = y   // ok

z, y = y, z               // ok
_, y = y, z               // ok
z, _ = y, z               // ok
_, _ = y, z               // ok
x, y = 69, 1.23           // ok
x, y = y, x               // error: 类型不匹配
x, y = int(y), float32(x) // ok，使用了显式类型转换
```





#### 短变量声明形式

也可以用短变量声明形式来声明一些局部变量，比如下例：

```go
lang, year := "Go language", 2007 // 变量lang和year都为新声明的变量
year, createdBy := 2009, "Google Research" // 只有变量createdBy是新声明的变量，变量year已经在上面声明过了，所以这里仅仅改变了它的值，或者说它被重新声明了
lang, year = "Go", 2012 // 这是一个纯赋值语句
```



短变量声明形式规范如下：

- 每个短声明语句中必须至少有一个新声明的变量；
- 短声明形式不包含`var`关键字，并且不能指定变量的类型；
- 短变量声明中的赋值符号必须为`:=`；
- 在一个短声明语句的左侧，已经声明过的变量和新声明的变量可以共存，但在一个标准声明语句中，所有出现在左侧的变量必须都为新声明的变量；
- 短声明左侧必须都为纯标识符，容器元素索引表达式（`x[i]`）、结构体的字段选择器（`x.f`）、指针解引用（`*p`）和限定标识符（`aPackage.Value`）都不能出现在`:=`符号的左侧。



### 局部变量和全局变量

在函数体内声明的变量称为局部变量，在函数体外声明的变量称为包级或者全局变量。



#### 局部变量至少要被有效使用一次

一个局部变量被声明之后至少要被有效使用一次，否则编译器将报错，包级变量无此限制。如果变量总是被当作赋值语句中的目标值，那么认为这个变量没有被有效使用过。下面这个例子编译不通过。

```go
package main

var x, y, z = 123, true, "foo" // 包级变量

func main() {
	var q, r = 789, false // ./*.go:6:6: r declared and not used
	r, s := true, "bar" // ./*.go:7:16: s declared and not used
	r = y // r没有被有效使用。
	x = q // q被有效使用了。
}
```



可以通过删除未使用变量声明或将未使用变量赋值给空标识符来避免编译错误。

```go
package main

var x, y, z = 123, true, "foo"

func main() {
	var q, r = 789, false
	r, s := true, "bar"
	r = y
	x = q

	_, _ = r, s // 将r和s做为源值使用一次。
}
```



#### 全局变量初始化顺序

包级变量在声明时的依赖关系将影响它们的初始化顺序，下面这个例子中的声明的变量的初始化顺序为`y = 5`、`c = y`、`b = c+1`、`a = b+1`、`x = a+1`。

```go
var x, y = a+1, 5         // 8 5
var a, b, c = b+1, c+1, y // 7 6 5
```



包级变量在初始化的时候不能相互依赖，下面这个变量声明语句编译不通过。

```go
var x, y = y, x
```



### 非常量数字值相关的显式类型转换规则

在Go中，两个类型不一样的基本类型值不能相互赋值，必须使用显式类型转换将一个值转换为另一个值的类型之后才能进行赋值。整数常量或整数非常量都可以被显式转换为字符串类型。

- 一个非常量浮点数和整数可以显式转换到其它任何一个浮点数和整数类型；
- 一个非常量复数可以显式转换到其它任何一个复数类型；



常量数字值的类型转换不能溢出，非常量数字值的类型转换中，溢出是允许的。当浮点数非常量值转换为整数类型时，精度丢失也是允许的。具体规则如下：

- 比特位数多的整数类型的非常量整数值向比特位数少的整数类型转换时，高位的比特将被舍弃，低位的比特将被保留，这种处理方式称之为截断（truncated）；
- 非常量的浮点数向整数类型转换时，浮点数的小数部分将被舍弃（向零靠拢）；
- 非常量整数或浮点数向浮点数类型转换的时候，精度丢失是允许的；
- 非常量复数向另一个复数类型转换时，精度丢失也是允许的；
- 显式转换涉及到非常量浮点数或者复数数字值时，如果源值溢出了目标类型的表示范围，则转换结果取决于具体编译器实现（即行为未定义）；



```go
const a = -1.23
var b = a // a被转换为它的默认类型float64，因此b的类型被推断为float64
var x = int32(a) // error: 常量1.23不能被截断舍入到一个整数
var y int32 = b // error: float64类型值不能被隐式转换到int32
var z = int32(b) // ok: z == -1，变量z的类型被推断为int32，z的小数部分将被舍弃

const k int16 = 255
var n = k            // 变量n的类型将被推断为int1。
var f = uint8(k + 1) // error: 常量256溢出了uint8
var g uint8 = n + 1  // error: int16值不能隐式转换为uint8
var h = uint8(n + 1) // ok: h == 0，变量h的类型为uint8，(n+1)溢出uint8，所以只有低8位bits（都为0）被保留
```



### 变量和常量的作用域

在Go中使用一对大括号来显式形成一个（局部）代码块，一个代码块可以内嵌另一个代码块，最外层的代码块称为包级代码块。声明在内层代码块中的常量或者变量将遮挡另一个外层代码块中声明的同名变量或者常量。下面的代码中声明了3个名为`x`的变量，内层的`x`将遮挡外层的`x`，外层的`x`在内层的`x`声明之后在内层中将不可见。

```go
package main

const y = 70
var x int = 123 // 包级变量

func main() {
	var x = true // 此x变量遮挡了包级变量x。
	{
		x, y := x, y-10 // 这里，左边的x和y均为新声明的变量，右边的x为外层声明的bool变量，右边的y为包级变量
		// 在此内层代码块中，从此开始，刚声明的x和y将遮挡外层声明x和y
		x, z := !x, y/10 // z是一个新声明的变量，x和y是上一句中声明的变量
		println(x, y, z) // false 60 6
	}
	println(x) // true
	println(y) // 70 （包级变量y从未修改）
	/*
	println(z) // error: z未定义，z的作用域仅限于上面的最内层代码块。
	*/
}
```



作用域是指一个标识符的可见范围，一个包级变量或者常量的作用域为其所处于的整个代码包。局部变量或者常量的作用域开始于此变量或者常量的声明的下一行，结束于最内层包含此变量或者常量的声明语句的代码块的结尾。



## 不可变量

如下是三种不可变值的定义：

1. 没有地址的值（所以它们不可以寻址）；
2. 有地址但是因为种种原因在语法上不可以寻址的值；
3. 可寻址但不允许在语法上被修改的值。



在Go语言中，直到现在（Go 1.23），没有值满足第三种定义。但是零尺寸类型的变量值可以被视为事实上的（可被取地址的）不变量。具名常量值满足第一种定义。方法和包级函数可以被视为声明的不可变值，它们满足第二种定义 字符串的字节元素和映射条目中的元素值同样满足第二种定义。在Go中没有办法声明其它不可变值。