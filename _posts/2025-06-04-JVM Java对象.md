---
layout: post
title: 2025-06-04-JVM Java对象.md
categories: [Java 虚拟机]
description: 
keywords: JVM Java对象.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# Java Instance

## 对象实例化

### 创建对象方式
- new：最常见的方式，单例类中调用getInstance的静态类方法，XXXFactory的静态方法；
- Class类的newInstance方法：反射的方式，在 JDK9 里面被标记为过时，因为只能调用空参构造器，权限必须是public；
- Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求；
- 使用clone()：不调用任何的构造器，要求当前类需要实现Cloneable接口中的clone()方法；
- 使用反序列化：反序列化一般用于Socket的网络传输，从文件中、从网络中获取一个对象的二进制流；
- 第三方库Objenesis。




### 创建对象步骤
1. 加载类元信息
2. 为对象分配内存
3. 处理并发问题
4. 属性的默认初始化（零值初始化）
5. 设置对象头信息
6. 属性的显示初始化、代码块中初始化、构造器中初始化

![img](https://oss.xubighead.top/oss/image/202506/1929847560614285314.png)



```java
Person zhang = new Person();
```



1. 将硬盘上指定位置的Person.class文件加载进内存
2. 执行main方法时，在栈内存中开辟了main方法的空间（压栈-进栈），然后在main方法的栈区分配了一个变量zhang。
3. 执行new，在堆内存中开辟一个 实体类的 空间，分配了一个内存首地址值
4. 调用该实体类对应的构造函数，进行初始化（如果没有构造函数，Java会补上一个默认构造函数）。
5. 将实体类的 首地址赋值给zhang，变量zhang就引用了该实体。（指向了该对象）



#### 类加载检查
虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。即判断类元信息是否存在。

如果没有，那么在双亲委派模式下，使用当前类加载器以“ClassLoader+包名+类名”为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到则进行类加载，并生成对应的Class类对象。



#### 分配内存
先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的



##### 指针碰撞
如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。即所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就是把指针指向空闲那边挪动一段与对象大小相等的距离。

用于Serial、ParNew垃圾回收器。



##### 空闲列表
如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表（Free List）来为对象分配内存。即虚拟机维护了一个空闲列表，记录可用内存块，分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。

用于CMS垃圾回收器。



#### 处理并发问题

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **本地线程分配缓冲区（TLAB）：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。通过UseTLAB参数来设定虚拟机是否使用TLAB(jdk8后默认开启)。



#### 初始化零值
属性的默认初始化，即给对象的成员变量赋予默认值，保证该成员变量不用显示赋值仍可直接使用。

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。



#### 设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息和锁信息等数据存储在对象的对象头中，具体设置方式取决于JVM实现。

> 数据对象 = 数据内容 + 元数据（描述数据的数据）



#### 执行init方法进行初始化

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

先进行属性的显式初始化、代码块中的初始化，两者依据代码中的顺序先后初始化；在进行构造器初始化。




#### 示例
```java
public class InstanceClass {
    // 加载完成后会0值初始化code的值为0，codeLabel的值为null
    private int code;
    private String codeLabel;
    // 显示初始化属性name的值为“instanceClass”
    private String name = "instanceClass";
    
    {
        this.code = 0;
    }
    
    public InstanceClass() {
        this.code = 1;
    }
}
```

1. new对象时，比如`InstanceClass instance = new InstanceClass()`会声明一个InstanceClass类型的引用，JVM首先去检查InstanceClass这个符号引用所代表的类是否已经被加载过，如果没有就要执行对应类的加载过程；
2. 类加载完成以后，对象所需的内存大小其实就已经确定下来了，接下来JVM就会在堆上为对象分配内存；
3. 属性“0”值初始化即为实例化对象的各个属性赋上默认初始化“0”值，比如int的初始化0值就是0，对象的初始化0值就是null；
4. 接下来JVM会进行对象头的设置，主要包括对象的运行时元数据（比如Hash码、GC分代年龄、锁状态标志、锁指针、偏向线程ID、偏向时间戳等）以及类型指针（JVM通过该类型指针来确定该对象是哪个类的实例）；
5. 属性的显示初始化即针对某个属性字段手动的赋值；
6. 最后是调用类的构造方法来进行进行构造方法内的初始化动作。



## 对象内存布局
### 对象头
1. 对象头（Header）

> 如果是数组，还需要记录数组的长度



#### 运行时元数据
- Hash码（HashCode）：对象的首地址值，换成哈希以免查找耗时；
- GC分代年龄：年龄计数器age，达到16就进入老年代；
- 锁状态标志
- 线程持有的锁
- 偏向线程ID
- 偏向时间戳



#### 类型指针
指向类元数据，确定该对象所属的类型，指向的其实是方法区中存放的类元信息。并不是所有的对象都会保留类型指针。



### 实例数据
实例数据（Instance Data）是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）。


#### 规则
- 父类中定义的变量会出现在子类之前；
- 相同宽度的字段总是被分配在一起；
- 如果 CompactFields 参数为 true（默认为 true）：字类的窄变量可能插入到父类变量的空隙。



### 对齐填充

对齐填充（Padding），不是必须的，也没有特别的含义，仅仅起到占位符的作用。



## 对象访问定位

建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

JVM有两种方式通过栈帧中的对象引用访问到其内部的对象实例，分别是句柄访问和直接指针访问。



```java
Object o = new Object();
```

`Object obj` 出现在方法体中，则上述代码会反映到 Java 栈的本地变量表中，作为 reference 类型数据出现。

`new Object()` 反映到 Java 堆中，形成一块存储了 Object 类型所有对象实例数据值的内存。Java堆中还包含对象类型数据的地址信息，这些类型数据存储在方法区中。



### 句柄访问

![1542615-20200713213704816-440722806](https://oss.xubighead.top/oss/image/202506/1929847398970003458.png)



如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池。

优点在于reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针，reference本身不需要被修改。



### 直接指针

![1542615-20200713213709560-755989951](https://oss.xubighead.top/oss/image/202506/1929847464195624961.png)

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。

直接指针是局部变量表中的引用直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。此时如果堆中对象的位置改变，那么reference也要跟着改变，如 “垃圾回收相关算法”中的复制算法。

hotspot JVM采用的就是直接指针的方式访问对象实例。



**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**



## TLAB

从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内

多线程同时分配内存时，使用 TLAB （Thread Local Allocation Buffer）可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为**快速分配策略**

OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计

- 堆区是线程共享的，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。

在程序中，可以通过 `-XX:UseTLAB` 设置是否开启 TLAB 空间。

默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 `-XX:TLABWasteTargetPercent` 设置 TLAB 空间所占用 Eden 空间的百分比大小。

一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。



## 相关命令
### TLAB区配置
- -XX:+UseTLAB

表示使用TLAB

- -XX:-UseTLAB

表示不使用TLAB

- -XX:+TLABSize

表示设置TLAB大小

- -XX:TLABRefillWasteFraction

表示设置进入TLAB空间，单个对象大小。是一个比例值，默认为64。如果对象小于整个空间的1/64，则放在TLAB区，如果对象大于整个空间的1/64，则放在堆区。

- -XX:+PrintTLAB

表示查看TLAB信息

- -XX:ResizeTLAB

表示自动调整TLABRefillWasteFraction阈值




## 参考资料
- [【JVM之内存与垃圾回收篇】对象实例化内存布局与访问定位](https://www.cnblogs.com/blknemo/p/13296019.html)

# Java Feature

## 方法

### 方法解析

#### 基础概念

**动态连接**

Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个特性给 Java 带来了更强大的动态扩展能力，使得可以在类运行期间才能确定某些目标方法的直接引用。



**静态解析**

方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。静态解析成立的前提是：**方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的**。换句话说，**调用目标在编译器进行编译时就必须确定**，这类方法的调用称为解析。

在 Java 语言中，符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，因此它们都适合在类加载阶段进行解析。



**非虚方法**

只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类。这些在类加载时就会把符号引用解析为该方法的直接引用的方法可以称为`非虚方法`。

特别说明下 final 方法，虽然调用 final 方法使用的是 invokevirtual 指令，但是由于它无法覆盖，没有其他版本，所以也无需对方发接收者进行多态选择，Java 语言规范中明确说明了 final 方法是一种非虚方法。



**虚方法**

与**非虚方法**相反，其他方法就称为虚方法。



#### 调用指令

方法调用唯一的任务是确定被调用方法的版本（调用哪个方法），暂时还不涉及方法内部的具体运行过程。

Java 虚拟机里共提供了四种方法调用字节指令，分别是：

- invokestatic：调用静态方法。
- invokespecial：调用实例构造器`<init>`方法、私有方法和父类方法。
- invokevirtual：调用所有的虚方法，final方法。
- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。



#### 总结

解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用， 不会延迟到运行期再去完成。



### 分派调用

分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。



#### 基础概念

**宗量**

方法的调用者和方法的参数统称为方法的宗量。



#### 静态分派

所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用就是多态性中的方法重载。静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。

```java
class Human{
}  
class Man extends Human{
}
class Woman extends Human{
}

public class StaticPai{

 public void say(Human hum){
  System.out.println("I am human");
 }
 public void say(Man hum){
  System.out.println("I am man");
 }
 public void say(Woman hum){
  System.out.println("I am woman");
 }

 public static void main(String[] args){
  Human man = new Man();
  Human woman = new Woman();
  StaticPai sp = new StaticPai();
  sp.say(man);
  sp.say(woman);
 }
}
```



```java
Human man = new Man();
```

上面代码中的“Human”称为变量的静态类型，后面的“Man”称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定。

上面代码在调用`say()`方法时，方法的调用者都为 sp 的前提下，使用哪个重载版本，完全取决于传入参数的数量和数据类型。代码中定义了两个静态类型相同、实际类型不同的变量，可见**「编译器（不是虚拟机，因为如果是根据静态类型做出的判断，那么在编译期就确定了）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。」**并且静态类型是编译期可知的，所以在编译阶段，Javac 编译器就根据参数的静态类型决定使用哪个重载版本。这就是静态分派最典型的应用。



#### 动态分派

动态分派与多态性的另一个重要体现——方法覆写有着很紧密的关系。向上转型后调用子类覆写的方法便是一个很好地说明动态分派的例子。

在判断执行父类中的方法还是子类中覆盖的方法时，如果用静态类型来判断，那么无论怎么进行向上转型，都只会调用父类中的方法，但实际情况是，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法，很明显，这里是要根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。



#### 单分派和多分派

方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。



```java
class Eat{
}
class Drink{
}

class Father{
 public void doSomething(Eat arg){
  System.out.println("爸爸在吃饭");
 }
 public void doSomething(Drink arg){
  System.out.println("爸爸在喝水");
 }
}

class Child extends Father{
 public void doSomething(Eat arg){
  System.out.println("儿子在吃饭");
 }
 public void doSomething(Drink arg){
  System.out.println("儿子在喝水");
 }
}

public class SingleDoublePai{
 public static void main(String[] args){
  Father father = new Father();
  Father child = new Child();
  father.doSomething(new Eat());
  child.doSomething(new Drink());
 }
}
```



编译阶段编译器的选择过程，即静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型是 Father 还是 Child，二是方法参数类型是 Eat 还是 Drink。因为是根据两个宗量进行选择，所以 Java 语言的**静态分派属于多分派类型**。

再来看运行阶段虚拟机的选择，即动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的接受者的实际类型是 Father 还是 Child。因为只有一个宗量作为选择依据，所以 Java 语言的**动态分派属于单分派类型**。

**Java语言的静态多分派和动态单分派分别对应了Java语言中的方法重载和方法重写的特性。**