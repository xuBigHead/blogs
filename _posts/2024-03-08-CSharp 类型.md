---
layout: post
title: 第001章-CSharp 类型
categories: [C#]
description: 
keywords: CSharp 类型.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# C# 类型

## 值类型

### 概述

值类型和[引用类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/reference-types)是 C# 类型的两个主要类别。 值类型的变量包含类型的实例。 它不同于引用类型的变量，后者包含对类型实例的引用。 默认情况下，在[分配](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/assignment-operator)中，通过将实参传递给方法并返回方法结果来复制变量值。 对于值类型变量，会复制相应的类型实例。 以下示例演示了该行为：

```cs
using System;

public struct MutablePoint
{
    public int X;
    public int Y;

    public MutablePoint(int x, int y) => (X, Y) = (x, y);

    public override string ToString() => $"({X}, {Y})";
}

public class Program
{
    public static void Main()
    {
        var p1 = new MutablePoint(1, 2);
        var p2 = p1;
        p2.Y = 200;
        Console.WriteLine($"{nameof(p1)} after {nameof(p2)} is modified: {p1}");
        Console.WriteLine($"{nameof(p2)}: {p2}");

        MutateAndDisplay(p2);
        Console.WriteLine($"{nameof(p2)} after passing to a method: {p2}");
    }

    private static void MutateAndDisplay(MutablePoint p)
    {
        p.X = 100;
        Console.WriteLine($"Point mutated in a method: {p}");
    }
}
// Expected output:
// p1 after p2 is modified: (1, 2)
// p2: (1, 200)
// Point mutated in a method: (100, 200)
// p2 after passing to a method: (100, 200)
```



如前面的示例所示，对值类型变量的操作只影响存储在变量中的值类型实例。

如果值类型包含引用类型的数据成员，则在复制值类型实例时，只会复制对引用类型实例的引用。 副本和原始值类型实例都具有对同一引用类型实例的访问权限。 以下示例演示了该行为：

```cs
using System;
using System.Collections.Generic;

public struct TaggedInteger
{
    public int Number;
    private List<string> tags;

    public TaggedInteger(int n)
    {
        Number = n;
        tags = new List<string>();
    }

    public void AddTag(string tag) => tags.Add(tag);

    public override string ToString() => $"{Number} [{string.Join(", ", tags)}]";
}

public class Program
{
    public static void Main()
    {
        var n1 = new TaggedInteger(0);
        n1.AddTag("A");
        Console.WriteLine(n1);  // output: 0 [A]

        var n2 = n1;
        n2.Number = 7;
        n2.AddTag("B");

        Console.WriteLine(n1);  // output: 0 [A, B]
        Console.WriteLine(n2);  // output: 7 [A, B]
    }
}
```



若要使代码更不易出错、更可靠，请定义并使用不可变的值类型。 本文仅为演示目的使用可变值类型。



#### 值类型的种类以及类型约束

值类型可以是以下种类之一：

- [结构类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/struct)，用于封装数据和相关功能
- [枚举类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum)，由一组命名常数定义，表示一个选择或选择组合

[可为 null 值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types)`T?` 表示其基础值类型 `T` 的所有值及额外的 [null](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/null) 值。 不能将 `null` 分配给值类型的变量，除非它是可为 null 的值类型。

你可使用 [`struct` 约束](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters)指定类型参数为不可为 null 的值类型。 结构类型和枚举类型都满足 `struct` 约束。 可在基类约束中使用 `System.Enum`（称为[枚举约束](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters#enum-constraints)），以指定类型参数为枚举类型。



#### 内置值类型

C# 提供以下内置值类型，也称为“简单类型”：

- [整型数值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)
- [浮点型数值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
- [bool](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool)，表示布尔值
- [char](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/char)，表示 Unicode UTF-16 字符



所有简单值都是结构类型，它们与其他结构类型的不同之处在于，它们允许特定的额外操作：

- 可以使用文字为简单类型提供值。 例如，`'A'` 是类型 `char` 的文本，`2001` 是类型 `int` 的文本。
- 可以使用 [const](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/const) 关键字声明简单类型的常数。 不能具有其他结构类型的常数。
- 常数表达式的操作数都是简单类型的常数，在编译时进行评估。



[值元组是值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-tuples)，而不是简单类型。



### 整型数值类型

整型数值类型 表示整数。 所有的整型数值类型均为[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types)。 它们还是[简单类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types)，可以使用[文本](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types#integer-literals)进行初始化。 所有整型数值类型都支持[算术](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators)、[位逻辑](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators)、[比较](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators)和[相等](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators)运算符。



#### 整型类型的特征

C# 支持以下预定义整型类型：

| C# 类型/关键字 | 范围                                                    | 大小                       | .NET 类型                                                    |
| :------------- | :------------------------------------------------------ | :------------------------- | :----------------------------------------------------------- |
| `sbyte`        | -128 到 127                                             | 8 位带符号整数             | [System.SByte](https://learn.microsoft.com/zh-cn/dotnet/api/system.sbyte) |
| `byte`         | 0 到 255                                                | 无符号的 8 位整数          | [System.Byte](https://learn.microsoft.com/zh-cn/dotnet/api/system.byte) |
| `short`        | -32,768 到 32,767                                       | 有符号 16 位整数           | [System.Int16](https://learn.microsoft.com/zh-cn/dotnet/api/system.int16) |
| `ushort`       | 0 到 65,535                                             | 无符号 16 位整数           | [System.UInt16](https://learn.microsoft.com/zh-cn/dotnet/api/system.uint16) |
| `int`          | -2,147,483,648 到 2,147,483,647                         | 带符号的 32 位整数         | [System.Int32](https://learn.microsoft.com/zh-cn/dotnet/api/system.int32) |
| `uint`         | 0 到 4,294,967,295                                      | 无符号的 32 位整数         | [System.UInt32](https://learn.microsoft.com/zh-cn/dotnet/api/system.uint32) |
| `long`         | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 64 位带符号整数            | [System.Int64](https://learn.microsoft.com/zh-cn/dotnet/api/system.int64) |
| `ulong`        | 0 到 18,446,744,073,709,551,615                         | 无符号 64 位整数           | [System.UInt64](https://learn.microsoft.com/zh-cn/dotnet/api/system.uint64) |
| `nint`         | 取决于（在运行时计算的）平台                            | 带符号的 32 位或 64 位整数 | [System.IntPtr](https://learn.microsoft.com/zh-cn/dotnet/api/system.intptr) |
| `nuint`        | 取决于（在运行时计算的）平台                            | 无符号的 32 位或 64 位整数 | [System.UIntPtr](https://learn.microsoft.com/zh-cn/dotnet/api/system.uintptr) |



在除最后两行之外的所有表行中，最左侧列中的每个 C# 类型关键字都是相应 .NET 类型的别名。 关键字和 .NET 类型名称是可互换的。 例如，以下声明声明了相同类型的变量：

```cs
int a = 123;
System.Int32 b = 123;
```



表的最后两行中的 `nint` 和 `nuint` 类型是本机大小的整数。 可以使用 `nint` 和 `nuint` 上下文关键字定义原本大小的整数。 在 32 位进程中运行时有 32 位的整数，在 64 位进程中运行时有 64 位的整数。 这些类型可用于互操作方案、低级别的库，可用于在广泛使用整数运算的方案中提高性能。

本机大小的整数类型在内部表示为 .NET 类型 [System.IntPtr](https://learn.microsoft.com/zh-cn/dotnet/api/system.intptr) 和 [System.UIntPtr](https://learn.microsoft.com/zh-cn/dotnet/api/system.uintptr)。 从 C# 11 开始，`nint` 和 `nuint` 类型是基础类型的别名。

每个整型类型的默认值都为零 `0`。

每个整型类型都有 `MinValue` 和 `MaxValue` 属性，提供该类型的最小值和最大值。 这些属性是编译时常量，但本机大小类型（`nint` 和 `nuint`）的情况除外。 对于本地大小的类型，`MinValue` 和 `MaxValue` 属性是在运行时计算的。 这些类型的大小取决于进程设置。

[System.Numerics.BigInteger](https://learn.microsoft.com/zh-cn/dotnet/api/system.numerics.biginteger) 结构用于表示没有上限或下限的带符号整数。



#### 整数文本

整数文本可以是

- 十进制：不使用任何前缀
- 十六进制：使用 `0x` 或 `0X` 前缀
- 二进制：使用 `0b` 或 `0B` 前缀

下面的代码演示每种类型的示例：

```csharp
var decimalLiteral = 42;
var hexLiteral = 0x2A;
var binaryLiteral = 0b_0010_1010;
```



前面的示例还演示了如何将 `_` 用作数字分隔符。 可以将数字分隔符用于所有类型的数字文本。

整数文本的类型由其后缀确定，如下所示：

- 如果文本没有后缀，则其类型为以下类型中可表示其值的第一个类型：`int`、`uint`、`long`、`ulong`。

  > 文本解释为正值。 例如，文本 `0xFF_FF_FF_FF` 表示 `uint` 类型的数字 `4294967295`，但其位表现形式与 `int` 类型的数字 `-1` 相同。 如果需要特定类型的值，请将文本强制转换为该类型。 如果文本值无法以目标类型表示，请使用运算符 `unchecked`。 示例：`unchecked((int)0xFF_FF_FF_FF)` 生成 `-1`。

- 如果文本以 `U` 或 `u` 为后缀，则其类型为以下类型中可表示其值的第一个类型：`uint`、`ulong`。

- 如果文本以 `L` 或 `l` 为后缀，则其类型为以下类型中可表示其值的第一个类型：`long`、`ulong`。

  > 可以使用小写字母 `l` 作为后缀。 但是，这会生成一个编译器警告，因为字母 `l` 可能与数字 `1` 混淆。 为清楚起见，请使用 `L`。

- 如果文本的后缀为 `UL`、`Ul`、`uL`、`ul`、`LU`、`Lu`、`lU` 或 `lu`，则其类型为 `ulong`。



如果由整数字面量所表示的值超出了 [UInt64.MaxValue](https://learn.microsoft.com/zh-cn/dotnet/api/system.uint64.maxvalue#system-uint64-maxvalue)，则将出现编译器错误 [CS1021](https://learn.microsoft.com/zh-cn/dotnet/csharp/misc/cs1021)。

如果确定的整数文本的类型为 `int`，且文本所表示的值位于目标类型的范围内，则该值可以隐式转换为 `sbyte`、`byte`、`short`、`ushort`、`uint`、`ulong`、`nint` 或 `nuint`：

```cs
byte a = 17;
byte b = 300;   // CS0031: Constant value '300' cannot be converted to a 'byte'
```



如前面的示例所示，如果文本的值不在目标类型的范围内，则发生编译器错误 [CS0031](https://learn.microsoft.com/zh-cn/dotnet/csharp/misc/cs0031)。

还可以使用强制转换将整数文本所表示的值转换为除确定的文本类型之外的类型：

```cs
var signedByte = (sbyte)42;
var longVariable = (long)42;
```



#### 转换

可以将任何整型数值类型转换为其他整数数值类型。 如果目标类型可以存储源类型的所有值，则转换是隐式的。 否则，需要使用[强制转换表达式](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression)来执行显式转换。 



#### 本机大小的整数

本机大小的整数类型具有特殊行为，因为存储是由目标计算机上的自然整数大小决定的。

- 若要在运行时获取本机大小的整数大小，可以使用 `sizeof()`。 但是，必须在不安全的上下文中编译代码。 例如：

  ```cs
  Console.WriteLine($"size of nint = {sizeof(nint)}");
  Console.WriteLine($"size of nuint = {sizeof(nuint)}");
  
  // output when run in a 64-bit process
  //size of nint = 8
  //size of nuint = 8
  
  // output when run in a 32-bit process
  //size of nint = 4
  //size of nuint = 4
  ```

  也可以通过静态 [IntPtr.Size](https://learn.microsoft.com/zh-cn/dotnet/api/system.intptr.size#system-intptr-size) 和 [UIntPtr.Size](https://learn.microsoft.com/zh-cn/dotnet/api/system.uintptr.size#system-uintptr-size) 属性获得等效的值。

  

- 若要在运行时获取本机大小的整数的最小值和最大值，请将 `MinValue` 和 `MaxValue` 用作 `nint` 和 `nuint` 关键字的静态属性，如以下示例中所示：

  ```cs
  Console.WriteLine($"nint.MinValue = {nint.MinValue}");
  Console.WriteLine($"nint.MaxValue = {nint.MaxValue}");
  Console.WriteLine($"nuint.MinValue = {nuint.MinValue}");
  Console.WriteLine($"nuint.MaxValue = {nuint.MaxValue}");
  
  // output when run in a 64-bit process
  //nint.MinValue = -9223372036854775808
  //nint.MaxValue = 9223372036854775807
  //nuint.MinValue = 0
  //nuint.MaxValue = 18446744073709551615
  
  // output when run in a 32-bit process
  //nint.MinValue = -2147483648
  //nint.MaxValue = 2147483647
  //nuint.MinValue = 0
  //nuint.MaxValue = 4294967295
  ```

  

- 可以使用以下范围内的常量值：

  - 对于 `nint`：[Int32.MinValue](https://learn.microsoft.com/zh-cn/dotnet/api/system.int32.minvalue#system-int32-minvalue) 到 [Int32.MaxValue](https://learn.microsoft.com/zh-cn/dotnet/api/system.int32.maxvalue#system-int32-maxvalue)。
  - 对于 `nuint`：[UInt32.MinValue](https://learn.microsoft.com/zh-cn/dotnet/api/system.uint32.minvalue#system-uint32-minvalue) 到 [UInt32.MaxValue](https://learn.microsoft.com/zh-cn/dotnet/api/system.uint32.maxvalue#system-uint32-maxvalue)。

- 编译器可将这些类型隐式和显式转换为其他数值类型。 有关详细信息，请参阅[内置数值转换](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/numeric-conversions)。

- 没有适用于本机大小整数文本的直接语法。 没有后缀可表示文本是本机大小整数，例如 `L` 表示 `long`。 可以改为使用其他整数值的隐式或显式强制转换。 例如：

  ```cs
  nint a = 42
  nint a = (nint)42;
  ```



### 浮点型数值类型

浮点数值类型表示实数。 所有浮点型数值类型均为[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types)。 它们还是[简单类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types)，可以使用[文本](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types#real-literals)进行初始化。 所有浮点数值类型都支持[算术](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators)、[比较](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators)和[相等](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators)运算符。



#### 浮点类型的特征

C# 支持以下预定义浮点类型：

| C# 类型/关键字 | 大致范围                       | 精度              | 大小      | .NET 类型                                                    |
| :------------- | :----------------------------- | :---------------- | :-------- | :----------------------------------------------------------- |
| `float`        | ±1.5 x 10−45 至 ±3.4 x 1038    | 大约 6-9 位数字   | 4 个字节  | [System.Single](https://learn.microsoft.com/zh-cn/dotnet/api/system.single) |
| `double`       | ±5.0 × 10−324 到 ±1.7 × 10308  | 大约 15-17 位数字 | 8 个字节  | [System.Double](https://learn.microsoft.com/zh-cn/dotnet/api/system.double) |
| `decimal`      | ±1.0 x 10-28 至 ±7.9228 x 1028 | 28-29 位          | 16 个字节 | [System.Decimal](https://learn.microsoft.com/zh-cn/dotnet/api/system.decimal) |



在上表中，最左侧列中的每个 C# 类型关键字都是相应 .NET 类型的别名。 它们是可互换的。 例如，以下声明声明了相同类型的变量：

```csharp
double a = 12.3;
System.Double b = 12.3;
```



每个浮点类型的默认值都为零，`0`。 每个浮点类型都有 `MinValue` 和 `MaxValue` 常量，提供该类型的最小值和最大有限值。 `float` and `double` 类型还提供可表示非数字和无穷大值的常量。 例如，`double` 类型提供以下常量：[Double.NaN](https://learn.microsoft.com/zh-cn/dotnet/api/system.double.nan#system-double-nan)、[Double.NegativeInfinity](https://learn.microsoft.com/zh-cn/dotnet/api/system.double.negativeinfinity#system-double-negativeinfinity) 和 [Double.PositiveInfinity](https://learn.microsoft.com/zh-cn/dotnet/api/system.double.positiveinfinity#system-double-positiveinfinity)。

当所需的精度由小数点右侧的位数决定时，`decimal` 类型是合适的。 此类数字通常用于财务应用程序、货币金额（例如 $1.00）、利率（例如 2.625%）等。 精确到只有一个小数的偶数用 `decimal` 类型处理会更准确：例如，0.1 可以由 `decimal` 实例精确表示，而没有精确表示 0.1 的 `double` 或 `float` 实例。 由于数值类型存在这种差异，因此当你对十进制数据使用 `double` 或 `float` 时，算术计算可能会出现意外的舍入错误。 当优化性能比确保准确度更重要时，可以使用 `double` 代替 `decimal`。 然而，除了大多数计算密集型应用程序之外，所有应用程序都不会注意到性能上的任何差异。 避免使用 `decimal` 的另一个可能原因是为了最大限度地降低存储需求。 例如，[ML.NET](https://learn.microsoft.com/zh-cn/dotnet/machine-learning/how-does-mldotnet-work) 使用 `float`，因为对于非常大的数据集，4 个字节与 16 个字节之间的差异合乎情理。 有关详细信息，请参阅 [System.Decimal](https://learn.microsoft.com/zh-cn/dotnet/api/system.decimal)。

可在表达式中将[整型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)类型与 `float` 和 `double` 类型混合使用功能。 在这种情况下，整型类型隐式转换为其中一种浮点类型，且必要时，`float` 类型隐式转换为 `double`。 此表达式的计算方式如下：

- 如果表达式中有 `double` 类型，则表达式在关系比较和相等比较中求值得到 `double` 或 [`bool`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool)。
- 如果表达式中没有 `double` 类型，则表达式在关系比较和相等比较中求值得到 `float` 或 `bool`。

你还可在表达式中混合使用整型类型和 `decimal` 类型。 在这种情况下，整型类型隐式转换为 `decimal` 类型，并且表达式在关系比较和相等比较中求值得到 `decimal` 或 `bool`。

不能在表达式中将 `decimal` 类型与 `float` 和 `double` 类型混合使用。 在这种情况下，如果你想要执行算术运算、比较运算或相等运算，则必须将操作数显式转换为 `decimal` 或反向转换，如下例所示：

```cs
double a = 1.0;
decimal b = 2.1m;
Console.WriteLine(a + (double)b);
Console.WriteLine((decimal)a + b);
```



可以使用[标准数字格式字符串](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/standard-numeric-format-strings)或[自定义数字格式字符串](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/custom-numeric-format-strings)设置浮点值的格式。



#### 真实文本

真实文本的类型由其后缀确定，如下所示：

- 不带后缀的文本或带有 `d` 或 `D` 后缀的文本的类型为 `double`
- 带有 `f` 或 `F` 后缀的文本的类型为 `float`
- 带有 `m` 或 `M` 后缀的文本的类型为 `decimal`

下面的代码演示每种类型的示例：

```cs
double d = 3D;
d = 4d;
d = 3.934_001;

float f = 3_000.5F;
f = 5.4f;

decimal myMoney = 3_000.5m;
myMoney = 400.75M;
```



前面的示例还演示了如何将 `_` 用作数字分隔符。 可以将数字分隔符用于所有类型的数字文本。

还可以使用科学记数法，即指定真实文本的指数部分，如以下示例所示：

```cs
double d = 0.42e2;
Console.WriteLine(d);  // output 42

float f = 134.45E-2f;
Console.WriteLine(f);  // output: 1.3445

decimal m = 1.5E6m;
Console.WriteLine(m);  // output: 1500000
```



#### 转换

浮点数值类型之间只有一种隐式转换：从 `float` 到 `double`。 但是，可以使用[显式强制转换](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression)将任何浮点类型转换为任何其他浮点类型。



### 内置数值转换

C# 提供了一组[整型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)和[浮点](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)数值类型。 任何两种数值类型之间都可以进行隐式或显式转换。 必须使用[强制转换表达式](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression)来执行显式转换。



#### 隐式数值转换

下表显示内置数值类型之间的预定义隐式转换：

| From                                                         | 到                                                           |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [sbyte](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `short`、`int`、`long`、`float`、`double`、`decimal` 或 `nint`。 |
| [byte](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`、`double`、`decimal`、`nint` 或 `nuint` |
| [short](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `int`、`long`、`float`、`double`、`decimal` 或 `nint`        |
| [ushort](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `int`、`uint`、`long`、`ulong`、`float`、`double`、`decimal`、`nint` 或 `nuint` |
| [int](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `long`、`float`、`double`、`decimal` 或 `nint`               |
| [uint](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `long`、`ulong`、`float`、`double`、`decimal` 或 `nuint`     |
| [long](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `float`、`double` 或 `decimal`                               |
| [ulong](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `float`、`double` 或 `decimal`                               |
| [float](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types) | `double`                                                     |
| [nint](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `long`、`float`、`double` 或 `decimal`                       |
| [nuint](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `ulong`、`float`、`double` 或 `decimal`                      |



> 从 `int`、`uint`、`long`、`ulong`、`nint` 或 `nuint` 到 `float` 的隐式转换以及从 `long`、`ulong`、`nint` 或 `nuint` 到 `double` 的隐式转换可能会丢失精准率，但绝不会丢失一个数量级。 其他隐式数值转换不会丢失任何信息。



另请注意：

- 任何[整型数值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)都可以隐式转换为任何[浮点数值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)。
- 不存在针对 `byte` 和 `sbyte` 类型的隐式转换。 不存在从 `double` 和 `decimal` 类型的隐式转换。
- `decimal` 类型和 `float` 或 `double` 类型之间不存在隐式转换。
- 类型 `int` 的常量表达式的值（例如，由整数文本所表示的值）如果在目标类型的范围内，则可隐式转换为 `sbyte`、`byte`、`short`、`ushort`、`uint`、`ulong`、`nint` 或 `nuint`：



#### 显式数值转换

下表显示不存在[隐式转换](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/numeric-conversions#implicit-numeric-conversions)的内置数值类型之间的预定义显式转换：

| From                                                         | 到                                                           |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [sbyte](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `byte`、`ushort`、`uint`、`ulong` 或 `nuint`                 |
| [byte](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`                                                      |
| [short](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`、`byte`、`ushort`、`uint`、`ulong` 或 `nuint`        |
| [ushort](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`、`byte` 或 `short`                                   |
| [int](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`uint`、`ulong` 或 `nuint`。 |
| [uint](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`int` 或 `nint`          |
| [long](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`ulong`、`nint` 或 `nuint` |
| [ulong](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`nint` 或 `nuint` |
| [float](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`decimal`、`nint` 或 `nuint` |
| [double](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`、`decimal`、`nint` 或 `nuint` |
| [decimal](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`、`double`、`nint` 或 `nuint` |
| [nint](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`ulong` 或 `nuint` |
| [nuint](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) | `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long` 或 `nint` |



> 显式数值转换可能会导致数据丢失或引发异常，通常为 [OverflowException](https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception)。



另请注意：

- 将整数类型的值转换为另一个整数类型时，结果取决于[溢出检查上下文](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked)。 在已检查的上下文中，如果源值在目标类型的范围内，则转换成功。 否则会引发 [OverflowException](https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception)。 在未检查的上下文中，转换始终成功，并按如下方式进行：
  - 如果源类型大于目标类型，则通过放弃其“额外”最高有效位来截断源值。 结果会被视为目标类型的值。
  - 如果源类型小于目标类型，则源值是符号扩展或零扩展，以使其与目标类型的大小相同。 如果源类型带符号，则是符号扩展；如果源类型是无符号的，则是零扩展。 结果会被视为目标类型的值。
  - 如果源类型与目标类型的大小相同，则源值将被视为目标类型的值。
- 将 `decimal` 值转换为整型类型时，此值会向零舍入到最接近的整数值。 如果生成的整数值处于目标类型的范围之外，则会引发 [OverflowException](https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception)。
- 将 `double` 或 `float` 值转换为整型类型时，此值会向零舍入到最接近的整数值。 如果生成的整数值处于目标类型范围之外，则结果会取决于[溢出上下文](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked)。 在已检查的上下文中，引发 [OverflowException](https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception)；而在未检查的上下文中，结果是目标类型的未指定值。
- 将 `double` 转换为 `float` 时，`double` 值舍入为最接近的 `float` 值。 如果 `double` 值太小或太大，无法匹配 `float` 类型，结果将为零或无穷大。
- 将 `float` 或 `double` 转换为 `decimal` 时，源值转换为 `decimal` 表示形式，并并五入到第 28 位小数后最接近的数（如有必要）。 根据源值的值，可能出现以下结果之一：
  - 如果源值太小，无法表示为 `decimal`，结果则为零。
  - 如果源值为 NaN（非数值）、无穷大或太大而无法表示为 `decimal`，则引发 [OverflowException](https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception)。
- 将 `decimal` 转换为 `float` 或 `double` 时，源值分别舍入为最接近的 `float` 或 `double` 值。



### bool

`bool` 类型关键字是 .NET [System.Boolean](https://learn.microsoft.com/zh-cn/dotnet/api/system.boolean) 结构类型的别名，它表示一个布尔值，可为 `true` 或 `false`。`bool` 类型的默认值为 `false`。

若要使用 `bool` 类型的值执行逻辑运算，请使用[布尔逻辑](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators)运算符。 `bool` 类型是 [比较](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators)和[相等](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators)运算符的结果类型。 `bool` 表达式可以是 [if](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-if-statement)、[do](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-do-statement)、[while](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-while-statement) 和 [for](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement) 语句中以及[条件运算符 `?:`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/conditional-operator) 中的控制条件表达式。



#### 文本

可使用 `true` 和 `false` 文本来初始化 `bool` 变量或传递 `bool` 值：

```cs
bool check = true;
Console.WriteLine(check ? "Checked" : "Not checked");  // output: Checked

Console.WriteLine(false ? "Checked" : "Not checked");  // output: Not checked
```



#### 三值布尔逻辑

如需支持三值逻辑（例如，在使用支持三值布尔类型的数据库时），请使用可为空 `bool?` 类型。 对于 `bool?` 操作数，预定义的 `&` 和 `|` 运算符支持三值逻辑。 



#### 转换

C# 仅提供了两个涉及 `bool` 类型的转换。 它们是对相应的可以为空的 `bool?` 类型的隐式转换以及对 `bool?` 类型的显式转换。 但是，.NET 提供了其他方法可用来转换到 `bool` 类型从或此类型进行转换。



### char

`char` 类型关键字是 .NET [System.Char](https://learn.microsoft.com/zh-cn/dotnet/api/system.char) 结构类型的别名，它表示 Unicode UTF-16 字符。

| 类型   | 范围             | 大小  | .NET 类型                                                    |
| :----- | :--------------- | :---- | :----------------------------------------------------------- |
| `char` | U+0000 到 U+FFFF | 16 位 | [System.Char](https://learn.microsoft.com/zh-cn/dotnet/api/system.char) |



`char` 类型的默认值为 `\0`，即 U+0000。`char` 类型支持[比较](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators)、[相等](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators)、[增量](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#increment-operator-)和[减量](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#decrement-operator---)运算符。 此外，对于 `char` 操作数，[算数](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators)和[逻辑位](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators)运算符对相应的字符代码执行操作，并得出 `int` 类型的结果。[字符串](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types#the-string-type)类型将文本表示为 `char` 值的序列。



#### 文本

可以使用以下命令指定 `char` 值：

- 字符文本。
- Unicode 转义序列，它是 `\u` 后跟字符代码的十六进制表示形式（四个符号）。
- 十六进制转义序列，它是 `\x` 后跟字符代码的十六进制表示形式。



```cs
var chars = new[]
{
    'j',
    '\u006A',
    '\x006A',
    (char)106,
};
Console.WriteLine(string.Join(" ", chars));  // output: j j j j
```

如前面的示例所示，你还可以将字符代码的值转换为相应的 `char` 值。



> 对于 Unicode 转义序列，必须指定全部四位十六进制值。 也就是说，`\u006A` 是一个有效的转义序列，而 `\u06A` 和 `\u6A` 是无效的。
>
> 对于十六进制转义序列，可以省略前导零。 也就是说，`\x006A`、`\x06A` 和 `\x6A` 转义序列是有效的，并且对应于同一个字符。



#### 转换

`char` 类型可隐式转换为以下[整型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)类型：`ushort`、`int`、`uint`、`long` 和 `ulong`。 它也可以隐式转换为内置[浮点](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)数值类型：`float`、`double` 和 `decimal`。 它可以显式转换为 `sbyte`、`byte` 和 `short` 整型类型。

无法将其他类型隐式转换为 `char` 类型。 但是，任何[整型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)或[浮点](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)数值类型都可显式转换为 `char`。



### 枚举类型

枚举类型 是由基础[整型数值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types)的一组命名常量定义的[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)。 若要定义枚举类型，请使用 `enum` 关键字并指定枚举成员 的名称：

```cs
enum Season
{
    Spring,
    Summer,
    Autumn,
    Winter
}
```



默认情况下，枚举成员的关联常数值为类型 `int`；它们从零开始，并按定义文本顺序递增 1。 可以显式指定任何其他[整数数值](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)类型作为枚举类型的基础类型。 还可以显式指定关联的常数值，如下面的示例所示：

```cs
enum ErrorCode : ushort
{
    None = 0,
    Unknown = 1,
    ConnectionLost = 100,
    OutlierReading = 200
}
```



不能在枚举类型的定义内定义方法。 若要向枚举类型添加功能，请创建[扩展方法](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)。枚举类型 `E` 的默认值是由表达式 `(E)0` 生成的值，即使零没有相应的枚举成员也是如此。可以使用枚举类型，通过一组互斥值或选项组合来表示选项。 若要表示选项组合，请将枚举类型定义为位标志。



#### 作为位标志的枚举类型

如果希望枚举类型表示选项组合，请为这些选项定义枚举成员，以便单个选项成为位字段。 也就是说，这些枚举成员的关联值应该是 2 的幂。 然后，可以使用[按位逻辑运算符`|`或 `&`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#enumeration-logical-operators) 分别合并选项或交叉组合选项。 若要指示枚举类型声明位字段，请对其应用 [Flags](https://learn.microsoft.com/zh-cn/dotnet/api/system.flagsattribute) 属性。 如下面的示例所示，还可以在枚举类型的定义中包含一些典型组合。

```cs
[Flags]
public enum Days
{
    None      = 0b_0000_0000,  // 0
    Monday    = 0b_0000_0001,  // 1
    Tuesday   = 0b_0000_0010,  // 2
    Wednesday = 0b_0000_0100,  // 4
    Thursday  = 0b_0000_1000,  // 8
    Friday    = 0b_0001_0000,  // 16
    Saturday  = 0b_0010_0000,  // 32
    Sunday    = 0b_0100_0000,  // 64
    Weekend   = Saturday | Sunday
}

public class FlagsEnumExample
{
    public static void Main()
    {
        Days meetingDays = Days.Monday | Days.Wednesday | Days.Friday;
        Console.WriteLine(meetingDays);
        // Output:
        // Monday, Wednesday, Friday

        Days workingFromHomeDays = Days.Thursday | Days.Friday;
        Console.WriteLine($"Join a meeting by phone on {meetingDays & workingFromHomeDays}");
        // Output:
        // Join a meeting by phone on Friday

        bool isMeetingOnTuesday = (meetingDays & Days.Tuesday) == Days.Tuesday;
        Console.WriteLine($"Is there a meeting on Tuesday: {isMeetingOnTuesday}");
        // Output:
        // Is there a meeting on Tuesday: False

        var a = (Days)37;
        Console.WriteLine(a);
        // Output:
        // Monday, Wednesday, Saturday
    }
}
```



#### System.Enum 类型和枚举约束

[System.Enum](https://learn.microsoft.com/zh-cn/dotnet/api/system.enum) 类型是所有枚举类型的抽象基类。 它提供多种方法来获取有关枚举类型及其值的信息。 有关更多信息和示例，请参阅 [System.Enum](https://learn.microsoft.com/zh-cn/dotnet/api/system.enum) API 参考页。

可在基类约束中使用 `System.Enum`（称为[枚举约束](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters#enum-constraints)），以指定类型参数为枚举类型。 所有枚举类型也都满足 `struct` 约束，此约束用于指定类型参数为不可为 null 的值类型。



#### 转换

对于任何枚举类型，枚举类型与其基础整型类型之间存在显式转换。 如果将枚举值[转换](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression)为其基础类型，则结果为枚举成员的关联整数值。

```cs
public enum Season
{
    Spring,
    Summer,
    Autumn,
    Winter
}

public class EnumConversionExample
{
    public static void Main()
    {
        Season a = Season.Autumn;
        Console.WriteLine($"Integral value of {a} is {(int)a}");  // output: Integral value of Autumn is 2

        var b = (Season)1;
        Console.WriteLine(b);  // output: Summer

        var c = (Season)4;
        Console.WriteLine(c);  // output: 4
    }
}
```



使用 [Enum.IsDefined](https://learn.microsoft.com/zh-cn/dotnet/api/system.enum.isdefined) 方法来确定枚举类型是否包含具有特定关联值的枚举成员。对于任何枚举类型，都存在分别与 [System.Enum](https://learn.microsoft.com/zh-cn/dotnet/api/system.enum) 类型的[装箱和取消装箱](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/boxing-and-unboxing)相互转换。



### 结构类型

结构类型（“structure type”或“struct type”）是一种可封装数据和相关功能的[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types) 。 使用 `struct` 关键字定义结构类型：

```cs
public struct Coords
{
    public Coords(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double X { get; }
    public double Y { get; }

    public override string ToString() => $"({X}, {Y})";
}
```



结构类型具有值语义 。 也就是说，结构类型的变量包含类型的实例。 默认情况下，在分配中，通过将参数传递给方法并返回方法结果来复制变量值。 对于结构类型变量，将复制该类型的实例。 有关更多信息，请参阅[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types)。

通常，可以使用结构类型来设计以数据为中心的较小类型，这些类型只有很少的行为或没有行为。 例如，.NET 使用结构类型来表示数字（[整数](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)和[实数](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)）、[布尔值](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool)、[Unicode 字符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/char)以及[时间实例](https://learn.microsoft.com/zh-cn/dotnet/api/system.datetime)。 如果侧重于类型的行为，请考虑定义一个[类](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/class)。 类类型具有引用语义 。 也就是说，类类型的变量包含的是对类型的实例的引用，而不是实例本身。

由于结构类型具有值语义，因此建议定义不可变的结构类型。



#### `readonly` 结构

可以使用 `readonly` 修饰符来声明结构类型为不可变。 `readonly` 结构的所有数据成员都必须是只读的，如下所示：

- 任何字段声明都必须具有 [`readonly` 修饰符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/readonly)
- 任何属性（包括自动实现的属性）都必须是只读的或[仅 `init`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/init)。

这样可以保证 `readonly` 结构的成员不会修改该结构的状态。 这意味着除构造函数外的其他实例成员是隐式 [`readonly`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/struct#readonly-instance-members)。



> 在 `readonly` 结构中，可变引用类型的数据成员仍可改变其自身的状态。 例如，不能替换 [List](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 实例，但可以向其中添加新元素。



下面的代码使用 init-only 属性资源库定义 `readonly` 结构：

```cs
public readonly struct Coords
{
    public Coords(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double X { get; init; }
    public double Y { get; init; }

    public override string ToString() => $"({X}, {Y})";
}
```



#### `readonly` 实例成员

还可以使用 `readonly` 修饰符来声明实例成员不会修改结构的状态。 如果不能将整个结构类型声明为 `readonly`，可使用 `readonly` 修饰符标记不会修改结构状态的实例成员。

在 `readonly` 实例成员内，不能分配到结构的实例字段。 但是，`readonly` 成员可以调用非 `readonly` 成员。 在这种情况下，编译器将创建结构实例的副本，并调用该副本上的非 `readonly` 成员。 因此，不会修改原始结构实例。

通常，将 `readonly` 修饰符应用于以下类型的实例成员：

- 方法：

  ```cs
  public readonly double Sum()
  {
      return X + Y;
  }
  ```

  

  还可以将 `readonly` 修饰符应用于可替代在 [System.Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 中声明的方法的方法：

  ```cs
  public readonly override string ToString() => $"({X}, {Y})";
  ```

  

- 属性和索引器：

  ```cs
  private int counter;
  public int Counter
  {
      readonly get => counter;
      set => counter = value;
  }
  ```

  如果需要将 `readonly` 修饰符应用于属性或索引器的两个访问器，请在属性或索引器的声明中应用它。

  

  > 编译器会将[自动实现的属性](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties)的 `get` 访问器声明为 `readonly`，而不管属性声明中是否存在 `readonly` 修饰符。

  

  可以将 `readonly` 修饰符应用于具有 `init` 访问器的属性或索引器：

  ```cs
  public readonly double X { get; init; }
  ```



可以将 `readonly` 修饰符应用于结构类型的静态字段，但不能应用于任何其他静态成员，例如属性或方法。编译器可以使用 `readonly` 修饰符进行性能优化。 有关详细信息，请参阅[避免分配](https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/performance/)。



#### 非破坏性变化

从 C# 10 开始，可以使用 [`with` 表达式](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/with-expression)来生成修改了指定属性和字段的结构类型实例的副本。 使用[对象初始值设定项](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers)语法来指定要修改的成员及其新值，如以下示例所示：

```csharp
public readonly struct Coords
{
    public Coords(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double X { get; init; }
    public double Y { get; init; }

    public override string ToString() => $"({X}, {Y})";
}

public static void Main()
{
    var p1 = new Coords(0, 0);
    Console.WriteLine(p1);  // output: (0, 0)

    var p2 = p1 with { X = 3 };
    Console.WriteLine(p2);  // output: (3, 0)

    var p3 = p1 with { X = 1, Y = 4 };
    Console.WriteLine(p3);  // output: (1, 4)
}
```



#### `record` 结构

从 C# 10 开始，可定义记录结构类型。 记录类型提供用于封装数据的内置功能。 可同时定义 `record struct` 和 `readonly record struct` 类型。 记录结构不能是 [`ref struct`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/ref-struct)。 有关详细信息和示例，请参阅[记录](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/record)。



#### 内联数组

从 C# 12 开始，可以将*内联数组*声明为 `struct` 类型：

```csharp
[System.Runtime.CompilerServices.InlineArray(10)]
public struct CharBuffer
{
    private char _firstElement;
}
```



内联数组是包含相同类型的 N 个元素的连续块的结构。 它是一个安全代码，等效于仅在不安全代码中可用的[固定缓冲区](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/unsafe-code#fixed-size-buffers)声明。 内联数组是具有以下特征的 `struct`：

- 它包含单个字段。
- 结构未指定显式布局。



此外，编译器还会验证 [System.Runtime.CompilerServices.InlineArrayAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.inlinearrayattribute) 属性：

- 必须大于零 (`> 0`)。
- 目标类型必须是结构。



在大多数情况下，可以像访问数组一样访问内联数组，以读取和写入值。 此外，还可以使用[范围](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#range-operator-)和[索引](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#indexer-access)运算符。

对单个字段的类型有最低限制。 它不能是指针类型，但可以是任何引用类型或任何值类型。 几乎可以将内联数组与任何 C# 数据结构一起使用。

内联数组是一种高级语言功能。 它们适用于高性能方案，在这些方案中，内联的连续元素块比其他替代数据结构速度更快。 可以从[功能规范](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-12.0/inline-arrays)中了解有关内联数组的详细信息



#### 结构初始化和默认值

`struct` 类型的变量直接包含该 `struct` 类型的数据。 这会让未初始化的 `struct`（具有其默认值）和已初始化的 `struct`（通过构造值来存储一组值）之间存在区别。 例如，考虑下面的代码：

```cs
public readonly struct Measurement
{
    public Measurement()
    {
        Value = double.NaN;
        Description = "Undefined";
    }

    public Measurement(double value, string description)
    {
        Value = value;
        Description = description;
    }

    public double Value { get; init; }
    public string Description { get; init; }

    public override string ToString() => $"{Value} ({Description})";
}

public static void Main()
{
    var m1 = new Measurement();
    Console.WriteLine(m1);  // output: NaN (Undefined)

    var m2 = default(Measurement);
    Console.WriteLine(m2);  // output: 0 ()

    var ms = new Measurement[2];
    Console.WriteLine(string.Join(", ", ms));  // output: 0 (), 0 ()
}
```



如前面的示例所示，[默认值表达式](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/default)忽略了无参数构造函数，并生成了结构类型的[默认值](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/default-values)。 结构类型数组实例化还忽略无参数构造函数并生成使用结构类型的默认值填充的数组。

你看到默认值的最常见情况是在数组中或内部存储包含变量块的其他集合中。 以下示例创建了一个由 30 个 `TemperatureRange` 结构组成的数组，每个结构都具有默认值：

```csharp
// All elements have default values of 0:
TemperatureRange[] lastMonth = new TemperatureRange[30];
```



结构的所有成员字段在创建时必须进行明确指定，因为 `struct` 类型直接存储其数据。 结构的 `default` 值已将所有字段明确指定为 0。 调用构造函数时，必须明确指定所有字段。 可以使用以下机制初始化字段：

- 可以将字段初始化表达式添加到任何字段或自动实现的属性。
- 可以在构造函数主体中初始化任何字段或自动属性。

从 C# 11 开始，如果你没有初始化结构中的所有字段，编译器会将代码添加到将这些字段初始化为默认值的构造函数中。 编译器执行其常用的明确指定分析。 在指定之前访问的任何字段，或者当构造函数完成执行时未明确指定的字段，会在构造函数主体执行之前被指定其默认值。 如果在指定所有字段之前访问 `this`，则结构会在构造函数主体执行之前初始化为默认值。

```csharp
public readonly struct Measurement
{
    public Measurement(double value)
    {
        Value = value;
    }

    public Measurement(double value, string description)
    {
        Value = value;
        Description = description;
    }

    public Measurement(string description)
    {
        Description = description;
    }

    public double Value { get; init; }
    public string Description { get; init; } = "Ordinary measurement";

    public override string ToString() => $"{Value} ({Description})";
}

public static void Main()
{
    var m1 = new Measurement(5);
    Console.WriteLine(m1);  // output: 5 (Ordinary measurement)

    var m2 = new Measurement();
    Console.WriteLine(m2);  // output: 0 ()

    var m3 = default(Measurement);
    Console.WriteLine(m3);  // output: 0 ()
}
```



每个 `struct` 都具有一个 `public` 无参数构造函数。 如果要编写无参数构造函数，它必须是公共构造函数。 如果结构声明了任何字段初始值设定项，就必须显式声明一个构造函数。 该构造函数不必是无参数的。 如果结构声明了字段初始值设定项，但没有构造函数，编译器将报告错误。 任何显式声明的构造函数（有参数或无参数）都会执行该结构的所有字段初始值设定项。 没有字段初始值设定项或构造函数的赋值的所有字段均设置为[默认值](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/default-values)。 有关详细信息，请参阅[无参数结构构造函数](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-10.0/parameterless-struct-constructors)功能建议说明。

从 C# 12 开始，`struct` 类型可以将[主构造函数](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors#primary-constructors)定义为其声明的一部分。 主要构造函数为构造函数参数提供了简洁的语法，可在该结构的任何成员声明中的整个 `struct` 正文中使用。

如果结构类型的所有实例字段都是可访问的，则还可以在不使用 `new` 运算符的情况下对其进行实例化。 在这种情况下，在首次使用实例之前必须初始化所有实例字段。 下面的示例演示如何执行此操作：

```csharp
public static class StructWithoutNew
{
    public struct Coords
    {
        public double x;
        public double y;
    }

    public static void Main()
    {
        Coords p;
        p.x = 3;
        p.y = 4;
        Console.WriteLine($"({p.x}, {p.y})");  // output: (3, 4)
    }
}
```

在处理[内置值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types)的情况下，请使用相应的文本来指定类型的值。



#### 结构类型的设计限制

结构具有[类](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/class)类型的大部分功能。 存在一些异常情况，在较新版本中也删除了一些异常：

- 结构类型不能从其他类或结构类型继承，也不能作为类的基础类型。 但是，结构类型可以实现[接口](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface)。
- 不能在结构类型中声明[终结器](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/finalizers)。
- 在 C# 11 之前，结构类型的构造函数必须初始化该类型的所有实例字段。



#### 按引用传递结构类型变量

将结构类型变量作为参数传递给方法或从方法返回结构类型值时，将复制结构类型的整个实例。 通过值传递可能会影响高性能方案中涉及大型结构类型的代码的性能。 通过按引用传递结构类型变量，可以避免值复制操作。 使用 `ref`、`out`、`in` 或 `ref readonly` 方法参数修饰符，指示必须[按引用传递](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/method-parameters#reference-parameters)某个参数。 使用 [ref 返回值](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-return-statement)按引用返回方法结果。 有关详细信息，请参阅[避免分配](https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/performance/)。



#### struct 约束

你还可在 [`struct` 约束](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters)中使用 `struct` 关键字，来指定类型参数为不可为 null 的值类型。 结构类型和[枚举](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum)类型都满足 `struct` 约束。



#### 转换

对于任何结构类型（[`ref struct`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/ref-struct) 类型除外），都存在与 [System.ValueType](https://learn.microsoft.com/zh-cn/dotnet/api/system.valuetype) 和 [System.Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 类型之间的[装箱和取消装箱](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/boxing-and-unboxing)相互转换。 还存在结构类型和它所实现的任何接口之间的装箱和取消装箱转换。



### Ref 结构类型



### 元组类型



### 可以为null的值类型



## 引用类型



## void

## 内置类型

## 非托管类型

## 默认值

下表显示 C# 类型的默认值：



| 类型                     | 默认值                                                       |
| :----------------------- | :----------------------------------------------------------- |
| 任何引用类型             | `null`                                                       |
| 任何内置整数数值类型     | 0（零）                                                      |
| 任何内置浮点型数值类型   | 0（零）                                                      |
| bool                     | `false`                                                      |
| char                     | `'\0'` (U + 0000)                                            |
| enum                     | 表达式 `(E)0` 生成的值，其中 `E` 是枚举标识符。              |
| struct                   | 通过如下设置生成的值：将所有值类型的字段设置为其默认值，将所有引用类型的字段设置为 `null`。 |
| 任何可以为 null 的值类型 | [HasValue](https://learn.microsoft.com/zh-cn/dotnet/api/system.nullable-1.hasvalue) 属性为 `false` 且 [Value](https://learn.microsoft.com/zh-cn/dotnet/api/system.nullable-1.value) 属性未定义的实例。 该默认值也称为可以为 null 的值类型的“null” 值。 |



### 默认值表达式

使用 [`default` 运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/default#default-operator)生成默认类型值，如下面的示例所示：

```cs
int a = default(int);
```



可使用[`default` 文本](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/default#default-literal)来初始化变量，使其具有其类型的默认值：

```cs
int a = default;
```



### 值类型的无参数构造函数

对于值类型，隐式无参数构造函数还可生成类型的默认值，如以下示例所示：

```cs
var n = new System.Numerics.Complex();
Console.WriteLine(n);  // output: (0, 0)
```



在运行时，如果 [System.Type](https://learn.microsoft.com/zh-cn/dotnet/api/system.type) 实例表示一个值类型，则可以使用 [Activator.CreateInstance(Type)](https://learn.microsoft.com/zh-cn/dotnet/api/system.activator.createinstance#system-activator-createinstance(system-type)) 方法来调用无参数构造函数，以获取该类型的默认值。
