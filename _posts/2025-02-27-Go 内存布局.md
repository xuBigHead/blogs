# Go 内存

Go支持自动内存管理，比如自动内存开辟和自动垃圾回收。尽管无须知道底层的自动内存管理是如何实现的，但是知道自动内存管理实现中的一些概念和事实对写出高质量的Go代码是非常有帮助的。



## 内存块

内存块（memory block）是一段在运行时刻承载着若干值部的连续内存片段，不同的内存块的大小可能不同，因它们所承载的值部的尺寸而定。一个内存块同时可能承载着不同Go值的若干值部，但是一个值部在内存中绝不会跨内存块存储，无论此值部的尺寸有多大。

一个内存块可能承载若干值部的原因有很多，这里仅列出一部分：

- 一个结构体值很可能有若干字段，所以当为此结构体值开辟了一个内存块时，此内存块同时也将承载此结构体值的各个字段值的直接部分；
- 一个数组值常常包含很多元素，所以当为此数组值开辟了一个内存块时，此内存块同时也将承载此数组值的各个元素值的直接部分；
- 两个切片的底层间接部分的元素序列可能承载在同一个内存块上，这两个间接值部甚至可能有部分重叠。



### 值引用着内存块

值部可能引用着另一个值部，也可以说一个内存块被它承载着的各个值部所引用着。所以当一个值部`v`被另一个值部引用着时，此另一个值部也（间接地）引用着承载着值部`v`的内存块。



### 开辟内存块

在Go中，在下列场合（不限于）将发生开辟内存块的操作：

- 显式地调用`new`和`make`内置函数，`new`函数调用总是只开辟一个内存块，`make`函数调用有可能会开辟多个内存块来承载创建的切片/映射/通道值的直接和底层间接值部；
- 使用字面量创建映射、切片或函数值，在此创建过程中，一个或多个内存块将被开辟出来；
- 声明变量；
- 将一个非接口值赋给一个接口值，对于标准编译器来说，不包括将一个指针值赋给一个接口值的情况；
- 衔接非常量字符串；
- 将字符串转换为字节切片或者码点切片，或者反之，除了一些编译器优化情形；
- 将一个整数转换为字符串；
- 调用内置`append`函数并且基础切片的容量不足够大；
- 向一个映射添加一个键值条目并且此映射底层内部的哈希表需要改变容量；



### 内存块开辟位置

对每一个使用标准编译器编译的Go程序，在运行时刻，每一个协程将维护一个栈（stack）。一个栈是一个预申请的内存段，它做为一个内存池供某些内存块从中开辟。在Go官方工具链1.19版本之前，一个栈的初始尺寸总是2KiB；从1.19版本开始，栈的初始尺寸是自适应的，每个栈的尺寸在协程运行的时候将按照需要增长和收缩。栈的最小尺寸为2KiB。

注意：Go运行时维护着一个协程栈的最大尺寸限制，此限制为全局的。如果一个协程在增长它的栈的时候超过了此限制，整个程序将崩溃。对于目前的官方标准Go官方工具链1.23版本，此最大限制的默认值在64位系统上为1GB，在32位系统上为250MB。可以在运行时刻调用`runtime/debug`标准库包中的`SetMaxStack`来修改此值。当前的官方标准编译器实现中，实际上允许的协程栈的最大尺寸为不超过最大尺寸限制的2的幂。所以对于默认设置，实际上允许的协程栈的最大尺寸在64位系统上为512MiB，在32位系统上为128MiB。

内存块可以被开辟在栈上，开辟在一个协程维护的栈上的内存块只能在此协程内部被使用（引用），其它协程是无法访问到这些内存块的。一个协程可以无需使用任何数据同步技术而使用开辟在它的栈上的内存块上的值部。

堆（heap）是一个虚拟的概念，每个程序只有一个堆。如果一个内存块没有开辟在任何一个栈上，则说它开辟在了堆上。开辟在堆上的内存块可以被多个协程并发地访问。在需要的时候，对承载在它们之上的值部的访问需要做同步。

如果编译器觉察到一个内存块在运行时将会被多个协程访问，或者不能轻松地断定此内存块是否只会被一个协程访问，则此内存块将会被开辟在堆上。也就是说，编译器将采取保守但安全的策略，使得某些可以安全地被开辟在栈上的内存块也有可能会被开辟在堆上。事实上，栈对于Go程序来说并非必要，Go程序中所有的内存块都可以开辟在堆上，支持栈只是为了让Go程序的运行效率更高。

- 从栈上开辟内存块比在堆上快得多；
- 开辟在栈上的内存块不需要被垃圾回收；
- 开辟在栈上的内存块对CPU缓存更加友好。



如果一个内存块被开辟在某处（堆或栈），则可以说承载在此内存块上的各个值部也开辟在此处。

如果一个局部声明的变量的某些值部被开辟在堆上，则说这些值部以及此局部变量逃逸到了堆上。可以运行Go官方工具链中提供的`go build -gcflags -m`命令来查看代码中哪些局部值的值部在运行时刻会逃逸到堆上。如上所述，目前官方Go标准编译器中的逃逸分析器并不十分完美，因此某些可以安全地开辟在栈上的值也可能会逃逸到了堆上。

在运行时刻，每一个仍在被使用中的逃逸到堆上的值部肯定被至少一个开辟在栈上的值部所引用着，如果一个逃逸到堆上的值是一个被声明为`T`类型的局部变量，则在运行时，一个`*T`类型的隐式指针将被创建在栈上。此指针存储着此`T`类型的局部变量的在堆上的地址，从而形成了一个从栈到堆的引用关系。另外，编译器还将所有对此局部变量的使用替换为对此指针的解引用。此`*T`值可能从今后的某一时刻不再被使用从而使得此引用关系不再存在。



类似地可以认为每个包级变量（常称全局变量）都被开辟在了堆上，并且它被一个开辟在一个全局内存区上的隐式指针所引用着。事实上，此指针引用着此包级变量的直接部分，此直接部分又引用着其它的值（部）。一个开辟在堆上的内存块可能同时被开辟在若干不同栈上的值部所引用着。一些事实：

- 如果一个结构体值的一个字段逃逸到了堆上，则此整个结构体值也逃逸到了堆上；
- 如果一个数组的某个元素逃逸到了堆上，则此整个数组也逃逸到了堆上；
- 如果一个切片的某个元素逃逸到了堆上，则此切片中的所有元素都将逃逸到堆上，但此切片值的直接部分可能开辟在栈上；
- 如果一个值部`v`被一个逃逸到了堆上的值部所引用，则此值部`v`也将逃逸到堆上；



使用内置`new`函数开辟的内存可能开辟在堆上，也可能开辟在栈上。



当一个协程的栈的大小（因为栈增长或者收缩而）改变时，一个新的内存段将申请给此栈使用。原先已经开辟在老的内存段上的内存块将很有可能被转移到新的内存段上，或者说这些内存块的地址将改变。相应地，引用着这些开辟在此栈上的内存块的指针（它们同样开辟在此栈上）中存储的地址也将得到刷新。下面是一个展示开辟在栈上的值的地址改变的例子。

```go
package main

// 下面这行是为了防止f函数的调用被内联。
// go:noinline
func f(i int) byte {
	var a [1<<20]byte // 使栈增长
	return a[i]
}

func main(){
	var x int
	println(&x)
	f(100)
	println(&x) // 前后两次输出的地址不同
}
```



#### 函数返回局部变量的指针

在Go中函数返回局部变量的指针是绝对安全的，支持栈的Go编译器将会对每个局部变量进行逃逸分析。对于官方标准编译器来说，如果一个值可以在编译时刻被断定它在运行时刻仅会在一个协程中被使用，则此值将被开辟在（此协程的）栈上；否则此值将被开辟在堆上。 



### 内存块回收

为包级变量的直接部分开辟的内存块永远不会被回收。

每个协程的栈将在此协程退出之时被整体回收，此栈上开辟的各个内存块没必要被一个一个单独回收，栈内存池并不由垃圾回收器回收。

对一个开在堆上的内存块，当它不再被任何开辟在协程栈的仍被使用中的，以及全局内存区上的值部所（直接或者间接）地引用着，则此内存块可以被安全地垃圾回收了。称这样的内存块为不再被使用的内存块，开辟在堆上的不再被使用的内存块将在以后某个时刻被垃圾回收器回收掉。



下面是一个展示了一些内存块在何时可以被垃圾回收的例子。

```go
var p *int

func main() {
	done := make(chan bool)
	// done通道将被使用在主协程和下面将要创建的新协程中，所以它将被开辟在堆上。

	go func() {
		x, y, z := 123, 456, 789
		_ = z  // z可以被安全地开辟在栈上。
		p = &x // 因为x和y都会将曾经被包级指针p所引用过，
		p = &y // 因此，它们都将开辟在堆上。

		// 到这里，x已经不再被任何其它值所引用，或者说承载它的内存块已经不再被使用，此内存块可以被回收了。

		p = nil
		// 到这里，y已经不再被任何其它值所引用，承载它的内存块可以被回收了。

		done <- true
	}()

	<-done
	// 到这里，done已经不再被任何其它值所引用，一个聪明的编译器将认为承载它的内存块可以被回收了。
}
```



在下面这个例子中，切片`bs`的底层间接值部在`bs`仍在使用之前就已经被标准编译器发觉已经不再被使用了。

```go
func main() {
	// 假设此切片的长度很大，以至于它的元素将被开辟在堆上。
	bs := make([]byte, 1 << 31)

	// 一个聪明的编译器将觉察到bs的底层元素部分已经不会再被使用，而正确地认为bs的底层元素部分在此刻可以被安全地回收了。
	fmt.Println(len(bs))
}
```



有时希望上例中的`bs`切片的底层间接值部不要在`fmt.Println`调用之前被垃圾回收，这时可以使用一个`runtime.KeepAlive`函数调用以便让垃圾回收器知晓在此调用之前切片`bs`和它所引用着的值部仍在被使用中。一个例子：

```go
package main

import "fmt"
import "runtime"

func main() {
	bs := make([]int, 1000000)

	fmt.Println(len(bs))
	runtime.KeepAlive(&bs)
	// 对于这个特定的例子，也可以调用runtime.KeepAlive(bs)。
}
```



垃圾回收过程将消耗相当的CPU资源和一些内存资源，所以垃圾回收过程并非总在运行。一个新的垃圾回收过程将在程序运行中的某些实时指标达到某些条件时才会被触发，这些条件怎么定义的是一个垃圾回收调度问题。官方标准运行时（runtime）的垃圾回收调度实现仍在随着版本递增而在不断地改善中，所以很难精确地描述此实现并同时保证描述的长期有效性。



### 内存块使用状态判断

目前的官方Go标准运行时（1.23版本）使用一个并发三色（tri-color）标记清扫（mark-sweep）算法来实现垃圾回收，此垃圾回收算法不会移动内存块来整理内存碎片。一个垃圾回收过程分为两个阶段：标记阶段和清扫阶段。



在标记阶段，垃圾回收器（一组协程）使用三色算法来分析哪些（开辟在堆上的）内存块已经不再使用了。算法中使用三色而不是两色的原因是此标记过程是并发的，在标记的过程中，很多其它普通用户协程也正在运行中。简而言之，当在某个用户协程中，一个已经标记为黑色的内存块在标记过程中被修改而使其新引用着的一个仍标记为白色的内存块时，此白色内存块需要被标记为灰色，否则此白色内存块有可能将被认为是垃圾而回收掉；除此之外的情况不做特殊处理。

- 在每一轮垃圾回收过程的开始，所有的堆内存块将被标记为白色；

- 然后垃圾回收器将所有开辟在栈和全局内存区上的内存块标记为灰色，并把它们加入一个灰色内存块列表；

- 循环下面两步直到灰色内存块列表为空：

  1. 从个灰色内存块列表中取出一个内存块，并把它标记为黑色。
  2. 然后扫描承载在此内存块上的指针值，并通过这些指针找到它们引用着的内存块，如果一个引用着的内存块为白色的，则将其标记为灰色并加入灰色内存块列表；否则，忽略之。

  

在清扫阶段，仍被标记为白色的内存块将被认为不再使用而被回收掉。一个不再被使用的内存块被回收后可能并不会立即释放给操作系统，这样Go运行时可以将其重新分配给其它值部使用。



## 内存布局

### Go中的类型对齐保证

为了充分利用CPU指令来达到最佳程序性能，为一个特定类型的值开辟的内存块的起始地址必须为某个整数N的倍数。N被称为此类型的值地址对齐保证（alignment guarantee），或者简单地称为此类型的对齐保证，也可以说此类型的值的地址保证为N字节对齐的。事实上，每个类型有两个对齐保证，当它被用做结构体类型的字段类型时的对齐保证称为此类型的字段对齐保证，其它情形的对齐保证称为此类型的一般对齐保证。

对于一个类型`T`，可以调用`unsafe.Alignof(t)`来获得它的一般对齐保证，其中`t`为一个`T`类型的非字段值，也可以调用`unsafe.Alignof(x.t)`来获得`T`的字段对齐保证，其中`x`为一个结构体值并且`t`为一个类型为`T`的结构体字段值。`unsafe`标准库包中的函数的调用都是在编译时刻估值的。

在运行时刻，对于类型为`T`的一个值`t`，可以调用`reflect.TypeOf(t).Align()`来获得类型`T`的一般对齐保证，也可以调用`reflect.TypeOf(t).FieldAlign()`来获得`T`的字段对齐保证。



对于当前的官方Go标准编译器（1.23版本），一个类型的一般对齐保证和字段对齐保证总是相等的；对于gccgo编译器，这两者可能不相等。Go白皮书仅列出了些许类型对齐保证要求。一个合格的Go编译器必须保证：

1. 对于任何类型的变量`x`，`unsafe.Alignof(x)`的结果最小为`1`。
2. 对于一个结构体类型的变量`x`，`unsafe.Alignof(x)`的结果为`x`的所有字段的对齐保证`unsafe.Alignof(x.f)`中的最大值（但是最小为`1`）。
3. 对于一个数组类型的变量`x`，`unsafe.Alignof(x)`的结果和此数组的元素类型的一个变量的对齐保证相等。



从这些要求可以看出，Go白皮书并未为任何类型指定了确定的对齐保证要求，它只是指定了一些最基本的要求。即使对于同一个编译器，具体类型的对齐保证在不同的架构上也是不相同的，同一个编译器的不同版本做出的具体类型的对齐保证也有可能是不相同的，当前版本（1.23）的标准编译器做出的对齐保证如下：

```go
类型种类                   对齐保证（字节数）
------                    ------
bool, uint8, int8         1
uint16, int16             2
uint32, int32             4
float32, complex64        4
数组                       取决于元素类型
结构体类型                  取决于各个字段类型
其它类型                    一个自然字的尺寸
```



一个自然字（native word）的尺寸在32位的架构上为4字节，在64位的架构上为8字节。这意味着，对于当前版本的标准编译器，其它类型的对齐保证为`4`或者`8`，具体取决于程序编译时选择的目标架构，此结论对另一个流行Go编译器gccgo也成立。一般情况下，在Go编程中不必关心值地址的对齐保证，除非需要优化一下内存消耗，或者编写跨平台移植性良好的Go代码。

Go编译器将不会重新排列结构体的字段来最小化结构体值的尺寸，因为这样做会导致意想不到的结果。但是可以根据需要手工重新排序字段来实现填充最小化。



#### 64位整数值对齐保证

传递给`sync/atomic`标准库包中的64位函数的地址必须是64位对齐的，否则调用这些函数将在运行时导致恐慌产生。

对于标准编译器和gccgo编译器，在64位架构下，64位整数的地址将保证总是64位对齐的，所以它们总是可以被安全地原子访问。但在32位架构下，64位整数的地址仅保证是32位对齐的，所以原子访问某些64位整数可能会导致恐慌。但是，有一些方法可以保证一些64位整数总是可以被安全地原子访问。



### 类型的尺寸和结构体字节填充

Go白皮书只对以下种类的类型的尺寸进行了明确规定，没有对其它种类的类型的尺寸做出明确规定，标准编译器（和gccgo编译器）将确保一个类型的尺寸为此类型的对齐保证的倍数。

```go
类型种类                  尺寸（字节数）
------                   ------
uint8, int8              1
uint16, int16            2
uint32, int32, float32   4
uint64, int64            8
float64, complex64       8
complex128               16
uint, int                取决于编译器实现。通常在
                         32位架构上为4，在64位
                         架构上为8。
uintptr                  取决于编译器实现。但必须
                         能够存下任一个内存地址。
```



为了满足前面提到的各条地址对齐保证要求规则，Go编译器可能会在结构体的相邻字段之间填充（structure padding）一些字节，这使得一个结构体类型的尺寸并非等于它的各个字段类型尺寸的简单相加之和。下面展示了一些字节是如何填充到一个结构体中的例子：

- 内置类型`int8`的对齐保证和尺寸均为1个字节；内置类型`int16`的对齐保证和尺寸均为2个字节；内置类型`int64`的尺寸为8个字节，但它的对齐保证在32位架构上为4个字节，在64位架构上为8个字节。
- 下例中的类型`T1`和`T2`的对齐保证均为它们的各个字段的最大对齐保证，所以它们的对齐保证和内置类型`int64`相同，即在32位架构上为4个字节，在64位架构上为8个字节；
- 类型`T1`和`T2`尺寸需为它们的对齐保证的倍数，即在32位架构上为4n个字节，在64位架构上为8n个字节。

```go
type T1 struct {
	a int8
	// 在64位架构上，为了让字段b的地址为8字节对齐，需在这里填充7个字节。在32位架构上，为了让字段b的地址为4字节对齐，需在这里填充3个字节。
	b int64
	c int16

	// 为了让类型T1的尺寸为T1的对齐保证的倍数，在64位架构上需在这里填充6个字节，在32架构上需在这里填充2个字节。
}
// 类型T1的尺寸在64位架构上为24个字节（1+7+8+2+6），在32位架构上为16个字节（1+3+8+2+2）。

type T2 struct {
	a int8

	// 为了让字段c的地址为2字节对齐，需在这里填充1个字节。
	c int16

	// 在64位架构上，为了让字段b的地址为8字节对齐，需在这里填充4个字节。在32位架构上，不需填充字节即可保证字段b的地址为4字节对齐的。
	b int64
}
// 类型T2的尺寸在64位架构上位16个字节（1+1+2+4+8），在32位架构上为12个字节（1+1+2+8）。
```



从这个例子可以看出，尽管类型`T1`和`T2`拥有相同的字段集，但是它们的尺寸并不相等。有时结构体类型中零尺寸类型的字段可能会影响到此结构体类型的尺寸。



### 结构体最后一个零尺寸字段类型的影响

可寻址的结构值的所有字段都可以被取地址，如果非零尺寸的结构体值的最后一个字段的尺寸是零，那么取此最后一个字段的地址将会返回一个越出了为此结构体值分配的内存块的地址，这个返回的地址可能指向另一个被分配的内存块。在目前的官方Go标准运行时的实现中，如果一个内存块被至少一个依然活跃的指针引用，那么这个内存块将不会被视作垃圾因而肯定不会被回收。所以只要有一个活跃的指针存储着此非零尺寸的结构体值的最后一个字段的越界地址，它将阻止垃圾收集器回收另一个内存块，从而可能导致内存泄漏。

为避免上述问题，标准的Go编译器会确保取一个非零尺寸的结构体值的最后一个字段的地址时，绝对不会返回越出分配给此结构体值的内存块的地址。Go标准编译器通过在需要时在结构体最后的零尺寸字段之后填充一些字节来实现这一点。

如果一个结构体的全部字段的类型都是零尺寸的(因此整个结构体也是零尺寸的)，那么就不需要再填充字节，因为标准编译器会专门处理零尺寸的内存块。



```go
func TestStructLastFieldAffectSizeInMemory(t *testing.T) {
	type T1 struct {
		a struct{}
		x int64
	}
	fmt.Println(unsafe.Sizeof(T1{})) // 8

	type T2 struct {
		x int64
		a struct{}
	}
	fmt.Println(unsafe.Sizeof(T2{})) // 16
}
```



### 64位字原子操作的地址对齐保证要求

64位字是指类型为内置类型`int64`或`uint64`的值，一个64位字的原子操作要求此64位字的地址必须是8字节对齐的。这对于标准编译器目前支持的64位架构来说并不是一个问题，因为标准编译器保证任何一个64位字的地址在64位架构上都是8字节对齐的。然而，在32位架构上，标准编译器为64位字做出的地址对齐保证仅为4个字节。对一个不是8字节对齐的64位字进行64位原子操作将在运行时刻产生一个恐慌。更糟的是，一些非常老旧的架构并不支持64位原子操作需要的基本指令。



`sync/atomic`标准库包文档的末尾提到：

>  On x86-32, the 64-bit functions use instructions unavailable before the Pentium MMX.
>
> On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.
>
> On both ARM and x86-32, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.



1. 这些非常老旧的架构在今日已经相当的不主流了，如果一个程序需要在这些架构上对64位字进行原子操作，还有很多其它同步技术可用。
2. 对其它不是很老旧的32位架构，有一些途径可以保证在这些架构上对一些64位字的原子操作是安全的。



这些途径被描述为**开辟的结构体、数组和切片值中的第一个（64位）字可以被认为是8字节对齐的**。一个开辟的值为一个声明的变量、内置函数`make`的调用返回值，或者内置函数`new`的调用返回值所引用的值。如果一个切片是从一个开辟的数组派生出来的并且此切片和此数组共享第一个元素，则也可以将此切片看作是一个开辟的值。

下面是一个展示了哪些64位字在32位架构上可以和哪些不可以被安全地原子访问的例子：

```go
type (
	T1 struct {
		v uint64
	}

	T2 struct {
		_ int16
		x T1
		y *T1
	}

	T3 struct {
		_ int16
		x [6]int64
		y *[6]int64
	}
)

var a int64    // a可以安全地被原子访问
var b T1       // b.v可以安全地被原子访问
var c [6]int64 // c[0]可以安全地被原子访问

var d T2 // d.x.v不能被安全地被原子访问
var e T3 // e.x[0]不能被安全地被原子访问

func f() {
	var f int64           // f可以安全地被原子访问
	var g = []int64{5: 0} // g[0]可以安全地被原子访问

	var h = e.x[:] // h[0]可以安全地被原子访问

	// 这里，d.y.v和e.y[0]都可以安全地被原子访问，因为*d.y和*e.y都是开辟出来的。
	d.y = new(T1)
	e.y = &[6]int64{}

	_, _, _ = f, g, h
}

// 事实上，c、g和e.y.v的所有以元素都可以被安全地原子访问。只不过官方文档没有明确地做出保证。
```



如果一个结构体类型的某个64位字的字段（通常为第一个字段）在代码中需要被原子访问，为了保证此字段值在各种架构上都可以被原子访问，应该总是使用此结构体的开辟值。 当此结构体类型被用做另一个结构体类型的一个字段的类型时，此字段应该（尽量）被安排为另一个结构体类型的第一个字段，并且总是使用另一个结构体类型的开辟值。

如果一个结构体含有需要一个被原子访问的字段，并且希望此结构体可以自由地用做其它结构体的任何字段（可能非第一个字段）的类型，则可以用一个`[15]byte`值来模拟此64位值，并在运行时刻动态地决定此64位值的地址。比如：

```go
type Counter struct {
	x [15]byte // 模拟：x uint64
}

func (c *Counter) xAddr() *uint64 {
	// 此返回结果总是8字节对齐的。
	return (*uint64)(unsafe.Pointer((uintptr(unsafe.Pointer(&c.x)) + 7)/8*8))
}

func (c *Counter) Add(delta uint64) {
	p := c.xAddr()
	atomic.AddUint64(p, delta)
}

func (c *Counter) Value() uint64 {
	return atomic.LoadUint64(c.xAddr())
}
```



通过采用此方法，`Counter`类型可以自由地用做其它结构体的任何字段的类型，而无需担心此类型中维护的64位字段值可能不是8字节对齐的。此方法的缺点是，对于每个`Counter`类型的值，都有7个字节浪费了，而且此方法使用了非类型安全指针。

Go 1.19引入了一种更为优雅的方法来保证一些值的地址对齐保证为8字节，Go 1.19在`sync/atomic`标准库包中加入了几个原子类型。这些类型包括`atomic.Int64`和`atomic.Uint64`，这两个类型的值在内存中总是8字节对齐的，即使在32位架构上也是如此。可以利用这个事实来确保一些64位字在32位架构上总是8字节对齐的，比如，无论在32位架构还是64位架构上，下面的代码所示的`T`类型的`x`字段在任何情形下总是8字节对齐的。

```go
type T struct {
	_ [0]atomic.Int64
	x int64
}
```



## 内存泄漏

Go 支持自动垃圾回收，不需要关心内存泄露问题，因为程序的运行时会负责回收不再使用的内存，但是也存在一些特殊的可能会造成暂时性或永久性内存泄露的情形。



### 暂时性内存泄漏

#### 子字符串场景

Go白皮书并没有说明一个子字符串表达式的结果（子）字符串和基础字符串是否应该共享一个承载底层字节序列的内存块，但标准编译器确实让它们共享一个内存块，而且很多标准库包的函数原型设计也默认了这一点。这是一个好的设计，它不仅节省内存，而且还减少了CPU消耗，但是有时候它会造成暂时性的内存泄露。

比如，当下面这段代码中的`demo`函数被调用之后，将会造成大约1M字节的暂时性内存泄露，直到包级变量`s0`的值在其它某处被重新修改为止。

```go
var s0 string // 一个包级变量

// 一个演示目的函数。
func f(s1 string) {
	s0 = s1[:50]
	// 目前，s0和s1共享着承载它们的字节序列的同一个内存块。虽然s1到这里已经不再被使用了，但是s0仍然在使用中，
	// 所以它们共享的内存块将不会被回收。虽然此内存块中只有50字节被真正使用，而其它字节却无法再被使用。
}

func demo() {
	s := createStringWithLengthOnHeap(1 << 20) // 1M bytes
	f(s)
}
```



为防止上面的`f`函数产生临时性内存泄露，可以将子字符串表达式的结果转换为一个字节切片，然后再转换回来。

```go
func f(s1 string) {
	s0 = string([]byte(s1[:50]))
}
```



此种防止临时性内存泄露的方法不是很高效，因为在此过程中底层的字节序列被复制了两次，其中一次是不必要的。可以利用官方Go标准编译器对字符串衔接所做的优化来防止一次不必要的复制，代价是有一个字节的浪费。第二种防止临时性内存泄露的方法有可能在将来会失效，并且它对于其它编译器来说很可能是无效的。

```go
func f(s1 string) {
	s0 = (" " + s1[:50])[1:]
}
```



第三种防止临时性内存泄露的方法是使用在Go 1.10种引入的`strings.Builder`类型来防止一次不必要的复制。第三种方法的缺点是它的实现有些啰嗦，但是从Go 1.12开始，可以调用`strings`标准库包中的`Repeat`函数来克隆一个字符串。从Go 1.12开始，此函数将利用`strings.Builder`来防止一次不必要的复制。

```go
import "strings"

func f(s1 string) {
	var b strings.Builder
	b.Grow(50)
	b.WriteString(s1[:50])
	s0 = b.String()
}
```



从Go 1.18开始，`strings`标准库包中引入了一个`Clone`函数。 调用此函数为克隆一个字符串的最佳实现方式。



#### 子切片场景

和子字符串情形类似，子切片也可能会造成暂时性的内存泄露。在下面这段代码中，当函数`g`被调用之后，承载着切片`s1`的元素的内存块的开头大段内存将不再可用（假设没有其它值引用着此内存块）。同时因为`s0`仍在引用着此内存块，所以此内存块得不到释放。

```go
var s0 []int

func g(s1 []int) {
	// 假设s1的长度远大于30。
	s0 = s1[len(s1)-30:]
}
```



可以在函数`g`中将30个元素均复制一份，使得切片`s0`和`s1`不共享承载底层元素的内存块来避免临时性内存泄漏。

```go
func g(s1 []int) {
	s0 = make([]int, 30)
	copy(s0, s1[len(s1)-30:])
	// 现在，如果再没有其它值引用着承载着s1元素的内存块，则此内存块可以被回收了。
}
```



#### 丢失的切片指针元素场景

在下面这段代码中，`h`函数调用之后，`s`的首尾两个元素将不再可用。

```go
func h() []*int {
	s := []*int{new(int), new(int), new(int), new(int)}
	// 使用此s切片 ...

	return s[1:3:3]
}
```



只要`h`函数调用返回的切片仍在被使用中，它的各个元素就不会回收，包括首尾两个已经丢失的元素。因此这两个已经丢失的元素引用着的两个`int`值也不会被回收，即使再也无法使用这两个`int`值。为了防止这样的暂时性内存泄露，必须重置丢失的元素中的指针。

```go
func h() []*int {
	s := []*int{new(int), new(int), new(int), new(int)}
	// 使用此s切片 ...

	s[0], s[len(s)-1] = nil, nil // 重置首尾元素指针
	return s[1:3:3]
}
```



#### 延迟调用场景

较大的延迟调用队列可能会消耗很多内存。另外，某些资源可能因为某些调用被延迟的太久而未能被及时释放。比如，如果下面的例子中的函数需要处理大量的文件，则在此函数退出之前，将有大量的文件句柄得不到释放。

```go
func writeManyFiles(files []File) error {
	for _, file := range files {
		f, err := os.Open(file.path)
		if err != nil {
			return err
		}
		defer f.Close()

		_, err = f.WriteString(file.content)
		if err != nil {
			return err
		}

		err = f.Sync()
		if err != nil {
			return err
		}
	}

	return nil
}
```



对于这种情形，应该使用匿名函数将需要及时执行延迟的调用包裹起来。比如上面的函数可以改进为如下：

```go
func writeManyFiles(files []File) error {
	for _, file := range files {
		if err := func() error {
			f, err := os.Open(file.path)
			if err != nil {
				return err
			}
			defer f.Close() // 将在此循环步内执行

			_, err = f.WriteString(file.content)
			if err != nil {
				return err
			}

			return f.Sync()
		}(); err != nil {
			return err
		}
	}

	return nil
}
```



### 永久性内存泄漏

#### 协程被永久阻塞场景

有时，一个程序中的某些协程会永久处于阻塞状态。Go运行时并不会将处于永久阻塞状态的协程杀掉，因此永久处于阻塞状态的协程所占用的资源将永得不到释放。

Go运行时出于两个原因并不杀掉处于永久阻塞状态的协程，一是有时候Go运行时很难分辨出一个处于阻塞状态的协程是永久阻塞还是暂时性阻塞；二是有时是可能故意永久阻塞某些协程。所以应该避免因为代码设计中的一些错误而导致一些协程处于永久阻塞状态。



#### 没有停止不再使用的`time.Ticker`值场景

当一个`time.Timer`值不再被使用，一段时间后它将被自动垃圾回收掉。但对于一个不再使用的`time.Ticker`值必须调用它的`Stop`方法结束它，否则它将永远不会得到回收。



#### 不正确使用终结器场景

将一个终结器（finalizer）设置到一个循环引用值组中的一个值上可能导致被此值组中的值所引用的内存块永远得不到回收。当下面这个函数被调用后，承载着`x`和`y`的两个内存块将不保证会被逐渐回收。所以，不要为一个循环引用值组中的值设置终结器，也不应该把终结器用做析构函数。

```go
func memoryLeaking() {
	type T struct {
		v [1<<20]int
		t *T
	}

	var finalizer = func(t *T) {
		 fmt.Println("finalizer called")
	}

	var x, y T

	// 此SetFinalizer函数调用将使x逃逸到堆上。
	runtime.SetFinalizer(&x, finalizer)

	// 下面这行将形成一个包含x和y的循环引用值组，这有可能造成x和y不可回收。
	x.t, y.t = &y, &x // y也逃逸到了堆上。
}
```



## 内存顺序

很多编译器优化（在编译时刻）和CPU处理器优化（在运行时刻）会常常调整指令执行顺序，从而使得指令执行顺序和代码中指定的顺序不太一致，指令顺序也称为内存顺序。

指令执行顺序的调整规则不是任意的，最基本的要求是发生在一个不与其它协程共享数据的协程内部的指令执行顺序调整在此协程内部必须不能被觉察到。换句话说，从这样的一个协程的角度看，其中的指令执行顺序和代码中指定的顺序总是一致的，即使确实有一些指令的执行顺序发生了调整。

然而，如果一些协程之间共享数据，那么在其中一个协程中发生的指令执行顺序调整将有可能被剩余的其它协程觉察到，从而影响到所有这些协程的行为。在并发编程中，多个协程之间经常共享数据，如果忽视了指令执行顺序调整带来的影响，编写的并发程序的行为将依赖于特定编译器和CPU，这样的程序常常表现出异常行为。

下面是一个编写得非常不职业的Go程序。此程序的编写没有考虑指令执行顺序调整带来的影响。

```go
var a string
var done bool

func setup() {
	a = "hello, world"
	done = true
	if done {
		log.Println(len(a)) // 如果被打印出来，它总是12
	}
}

func main() {
	go setup()

	for !done {
		runtime.Gosched()
	}
	log.Println(a) // 期待的打印结果：hello, world
}
```



此程序运行后`hello, world`将被打印输出，然而，此程序的行为并非跨编译器和跨平台架构兼容的。如果使用一个不同的（但符合Go规范的）编译器或者不同的编译器版本编译，它的运行结果可能是不同的。即使此程序使用同一个编译器编译，在不同的平台架构上的运行结果也可能是不同的。编译器和CPU可能调整`setup`函数中的前两条语句的执行顺序，使得`setup`协程中的指令的执行顺序和下面的代码指定的顺序一致。

```go
func setup() {
	done = true
	a = "hello, world"
	if done {
		log.Println(len(a))
	}
}
```



`setup`协程并不会觉察到此执行顺序调整，所以此协程中的`log.Println(len(a))`语句将总是打印出`12`，但是，此执行顺序调整将被主协程觉察到，所以最终的打印结果有可能是空，而不是`hello, world`。

除了没有考虑指令执行顺序调整带来的影响，此程序还存在数据竞争的问题，变量`a`和`done`的使用没有进行同步，所以此程序是一个充满了各种并发编程错误的不良例子。可以使用Go官方工具链中的`go build -race`命令来编译并运行一个程序，以检查此程序中是否存在着数据竞争。



### 内存顺序保证

不同的CPU架构提供了不同的栅栏（fence）指令来防止各种指令执行顺序调整，一些编程语言提供对应的函数来在代码中的合适位置插入各种栅栏指令。但是，理解和正确地使用这些栅栏指令极大地提高了并发编程的门槛。

Go语言的设计哲学是用尽量少的易于理解的特性来支持尽量多的使用场景，同时还要尽量保证代码的高执行效率。所以Go内置和标准库并没有提供直接插入各种栅栏指令的途径。 事实上，这些栅栏指令被使用在Go中提供的各种高级数据同步技术的实现中，所以应该使用Go中提供的高级数据同步技术来保证代码执行顺序。

在下面的叙述中，如果说事件`A`保证发生在事件`B`之前，这意味着这两个事件涉及到的任何协程都将观察到在事件`A`之前的语句肯定将在事件`B`之后的语句先执行，对于不相关的协程，它们所观察到的顺序可能并非如此所述。



#### 协程的创建发生在此协程中的代码执行之前

在下面这个函数中，对`x`和`y`的赋值保证发生在对它们的打印之前，并且对`x`的打印肯定发生在对`y`的打印之前。

```go
var x, y int
func f1() {
	x, y = 123, 789
	go func() {
		fmt.Println(x)
		go func() {
			fmt.Println(y)
		}()
	}()
}
```



然而这些顺序在下面这个函数中是得不到任何保证的。此函数存在着数据竞争。

```go
var x, y int
func f2() {
	go func() {
		fmt.Println(x) // 可能打印出0、123，或其它值
	}()
	go func() {
		fmt.Println(y) // 可能打印出0、789，或其它值
	}()
	x, y = 123, 789
}
```



#### 通道操作相关的顺序保证

下面列出的是通道操作做出的基本顺序保证：

1. 一个通道上的第n次成功发送操作的开始发生在此通道上的第n次成功接收操作完成之前，无论此通道是缓冲的还是非缓冲的；
2. 一个容量为m通道上的第n次成功接收操作的开始发生在此通道上的第n+m次发送操作完成之前，特别地，如果此通道是非缓冲的（`m == 0`），则此通道上的第n次成功接收操作的开始发生在此通道上的第n次发送操作完成之前；
3. 一个通道的关闭操作发生在任何因为此通道被关闭而从此通道接收到了零值的操作完成之前；



对一个非缓冲通道来说，第n次成功发送的完成的发送和第n次成功接收的完成应被视为同一事件。下面这段代码展示了一个非缓冲通道上的发送和接收操作是如何保证特定的代码执行顺序的。

```go
func f3() {
	var a, b int
	var c = make(chan bool)

	go func() {
		a = 1
		c <- true
		if b != 1 {
			panic("b != 1") // 绝不可能发生
		}
	}()

	go func() {
		b = 1
		<-c
		if a != 1  {
			panic("a != 1") // 绝不可能发生
		}
	}()
}
```



对于函数`f3`中创建的两个协程，下列顺序将得到保证：

- 赋值语句`b = 1`肯定在条件`b != 1`被估值之前执行完毕。
- 赋值语句`a = 1`肯定在条件`a != 1`被估值之前执行完毕。

所以，上例代码中两个协程中的`panic`调用将永不可能得到执行。做为对比，下面这段代码中的`panic`调用有可能会得到执行，因为上述通道操作相关的顺序保证对于不相关的协程是无效的。

```go
func f4() {
	var a, b, x, y int
	c := make(chan bool)

	go func() {
		a = 1
		c <- true
		x = 1
	}()

	go func() {
		b = 1
		<-c
		y = 1
	}()

	// 和上面的通道操作不相关的协程，这是一个不良代码的例子，它造成了很多数据竞争。
	go func() {
		if x == 1 {
			if a != 1 {
				panic("a != 1") // 有可能发生
			}
			if b != 1 {
				panic("b != 1") // 有可能发生
			}
		}

		if y == 1 {
			if a != 1 {
				panic("a != 1") // 有可能发生
			}
			if b != 1 {
				panic("b != 1") // 有可能发生
			}
		}
	}()
}
```



这里的新创建的第三个协程是一个和通道`c`上的发送和接收操作不相关的一个协程，它所观察到的执行顺序和其它两个新创建的协程可能是不同的。条件`a != 1`和`b != 1`的估值有可能为`true`，所以四个`panic`调用有可能会得到执行。

事实上，大多数编译器的实现确实很可能能够保证上面这个不良的例子中的四个`panic`调用永远不可能被执行，但是没有任何Go官方文档做出了这样的保证。下面是一个缓冲通道的例子。

```go
func f5() {
	var k, l, m, n, x, y int
	c := make(chan bool, 2)

	go func() {
		k = 1
		c <- true
		l = 1
		c <- true
		m = 1
		c <- true
		n = 1
	}()

	go func() {
		x = 1
		<-c
		y = 1
	}()
}
```



在此例子中，下面的顺序得以保证：

- 赋值语句`k = 1`的执行保证在赋值语句`y = 1`的执行之前结束；
- 赋值语句`x = 1`的执行保证在赋值语句`n = 1`的执行之前结束；
- 赋值语句`x = 1`的执行并不能保证在赋值语句`l = 1`和`m = 1`的执行之前结束；
- 赋值语句`l = 1`和`m = 1`的执行也不能保证在赋值语句`y = 1`的执行之前结束；



下面是一个通道关闭的例子，在这个例子中，赋值语句`k = 1`的执行保证在赋值语句`y = 1`执行之前结束，但不能保证在赋值语句`x = 1`执行之前结束。

```go
func f6() {
	var k, x, y int
	c := make(chan bool, 1)

	go func() {
		c <- true
		k = 1
		close(c)
	}()

	go func() {
		<-c
		x = 1
		<-c
		y = 1
	}()
}
```



#### 互斥锁相关的顺序保证

Go中互斥锁相关的顺序保证：

1. 对于一个可寻址的`sync.Mutex`类型或者`sync.RWMutex`类型的值`m`，第n次成功的`m.Unlock()`方法调用保证发生在第n+1次`m.Lock()`方法调用返回之前；
2. 对一个可寻址的`RWMutex`类型值`rw`，如果它的第n次`rw.Lock()`方法调用已成功返回，并且有一个`rw.RLock()`方法调用保证发生在此第n次`rw.Lock()`方法调用返回之后，则第n次成功的`rw.Unlock()`方法调用保证发生在此`rw.RLock()`方法调用返回之前；
3. 对一个可寻址的`RWMutex`类型值`rw`，如果它的第n次`rw.RLock()`方法调用已成功返回，并且有一个`rw.Lock()`方法调用保证发生在此第n次`rw.RLock()`方法调用返回之后，则第m次成功的`rw.RUnlock()`方法调用（其中`m <= n`）保证发生在此`rw.Lock()`方法调用返回之前。



在下面这个例子中，下列顺序肯定得到保证。

- 赋值语句`a = 1`的执行保证在赋值语句`b = 1`的执行之前结束。
- 赋值语句`m = 1`的执行保证在赋值语句`n = 1`的执行之前结束。
- 赋值语句`x = 1`的执行保证在赋值语句`y = 1`的执行之前结束。

```go
func fab() {
	var a, b int
	var l sync.Mutex // or sync.RWMutex

	l.Lock()
	go func() {
		l.Lock()
		b = 1
		l.Unlock()
	}()
	go func() {
		a = 1 // 赋值语句`a = 1`的执行保证在赋值语句`b = 1`的执行之前结束
		l.Unlock()
	}()
}

func fmn() {
	var m, n int
	var l sync.RWMutex

	l.RLock()
	go func() {
		l.Lock()
		n = 1
		l.Unlock()
	}()
	go func() {
		m = 1 // 赋值语句`m = 1`的执行保证在赋值语句`n = 1`的执行之前结束
		l.RUnlock()
	}()
}

func fxy() {
	var x, y int
	var l sync.RWMutex

	l.Lock()
	go func() {
		l.RLock()
		y = 1
		l.RUnlock()
	}()
	go func() {
		x = 1 // 赋值语句`x = 1`的执行保证在赋值语句`y = 1`的执行之前结束
		l.Unlock()
	}()
}
```



注意，在下面这段代码中，根据Go官方文档，赋值语句`p = 1`的执行并不能保证在赋值语句`q = 1`的执行之前结束，尽管多数编译器确实能够做出这样的保证。

```go
var p, q int
func fpq() {
	var l sync.Mutex
	p = 1
	l.Lock()
	l.Unlock()
	q = 1
}
```



#### 同步操作做出顺序保证

- `sync.WaitGroup`值做出的顺序保证：假设在某个给定时刻，一个可寻址的`sync.WaitGroup`值`wg`维护的计数不为0，并且有一个`wg.Wait()`方法调用在此给定时刻之后调用。如果有一组`wg.Add(n)`方法调用在此给定时刻之后调用，并且可以保证这组调用中只有最后一个返回的调用会将`wg`维护的计数修改为0，则这组调用中的每个调用保证都发生在此`wg.Wait()`方法调用返回之前。

- `sync.Once`值做出的顺序保证

- `sync.Cond`值做出的顺序保证



#### 原子操作相关的顺序保证

从Go 1.19开始，Go 1 内存模型正式地说明Go程序中执行的原子操作按照顺序一致次序（sequentially consistent order）执行。如果一个原子（写）操作A的效果被一个原子（读）操作B观察到，则A肯定被同步到B之前执行。

按照这个说法，在下面这个程序中，对变量`b`的原子写操作肯定发生在对其读取结果为`1`的原子原子读操作之前，从而使得对变量`a`的普通写操作也发生于对其的普通读操作之前。 所以此程序保证会打印出`2`。

```go
func main() {
	var a, b int32 = 0, 0

	go func() {
		a = 2
		atomic.StoreInt32(&b, 1)
	}()

	for {
		if n := atomic.LoadInt32(&b); n == 1 {
			fmt.Println(a) // 2
			break
		}
		runtime.Gosched()
	}
}
```



#### 和终结器相关的顺序保证

调用`runtime.SetFinalizer(x, f)`发生在终结调用`f(x)`被执行之前。	



## 栈内存

### 栈内存溢出

在目前的主流Go编译器实现中，栈溢出是致命错误。一旦栈溢出发生，程序将不可恢复地崩溃。

```go
func f() {
	f()
}

func TestStackOverflow(t *testing.T) {
	defer func() {
		recover() // 无法防止程序崩溃
		fmt.Println("recover success")
	}()
	f()
}
```



运行结果：

```shell
=== RUN   TestStackOverflow
runtime: goroutine stack exceeds 1000000000-byte limit
runtime: sp=0xc020161390 stack=[0xc020160000, 0xc040160000]
fatal error: stack overflow

runtime stack:
......
```



## 总结



