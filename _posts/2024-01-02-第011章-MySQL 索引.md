---
layout: post
title: MySQL 索引.md
categories: [MySQL]
description: 
keywords: MySQL 索引.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# MySQL索引

索引有很多种类型，可以为不同的场景提供更好的性能。在 MySQL 中，**索引是存储引擎层实现的**，并没有统一的索引标准，即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

索引的根本原理就是降低硬盘的io次数。



> 其实简单来说，索引就是一个排好序的数据结构



**索引优势**

1. 加快查询和分组、排序的速度，降低数据库的IO成本以及CPU的消耗。
2. 通过创建唯一索引，可以保证每一行数据的唯一性。
3. 加速表与表的连接。
4. 显著的减少查询中分组和排序的时间



**索引劣势**

1. 增删改操作时需要更新索引，会降低数据操作的性能：
2. 新增：自然需要在索引树中新增节点；
3. 删除：索引树中指向的记录可能会失效，意味着这棵索引树很多节点，都是失效的；
4. 改动：索引树中节点的**指向**可能需要改变。
5. 创建索引时需要对表加锁，在锁表的同时，可能会影响到其他的数据操作。
6. 索引需要磁盘的空间进行存储，如果针对单表创建了大量的索引，可能比数据文件更快达到大小上限。
7. 当对表中的数据进行CRUD的时，也会触发索引的维护，而维护索引需要时间，可能会降低数据操作的性能。
8. 创建索引需要时间，后期创建的索引，创建开销时间与表数据量呈正相关
9. 占用磁盘空间；
10. 增加查询优化器的负担；



## 索引类型

### 数据结构角度

#### B+Tree 索引

#### Hash索引

基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。



##### 优点

- 通过对Key进行散列值计算，可以直接得到对应数据的存放位置，它的查询效率能够达到O(1)。



##### 缺陷

- Hash索引仅仅能满足“=”，“in”查询条件，不能使用范围查询。
- 不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。
- 哈希索引也没办法利用索引完成排序
- 不支持最左匹配原则
- 存在大量哈希冲突（Hash碰撞）的情况下，哈希索引的效率也是极低的



#### 自适应哈希索引

自适应哈希索引（AHI）



#### R-Tree索引

空间索引，是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。



### 应用层次角度

#### 普通索引

即一个索引只包含单个列，一个表可以有多个单列索引。

普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。



#### 联合索引

一个索引包含多个列。组合索引和字符串列上的索引都有一个最左匹配原则，查询条件中必须要有索引最左一列才会生效，而如果中间跳过一列则跳过的列及之后的列都不会生效。

有时有可能因为多个列名过长，导致组合索引树的键大小过大，降低了存储和查询的效率。所以为了避免出现这样的情况，可以适当的保证每一列的名字不要太长，或只取组合索引每一列前几个字符组成索引。

**组合索引实际还是一个索引，并非真的创建了多个索引，只是产生的效果等价于产生多个索引。**联合索引当遇到范围查询 (>、<、between、like) 就会停止匹配，也就是 **a 字段能用到联合索引，但是 reward 字段则无法利用到索引**。



**示例**

| 索引名称           | 字段               | 索引类型 | 索引方法 |
| ------------------ | ------------------ | -------- | -------- |
| idx_classify_title | classify_id, title | NORMAL   | BTREE    |



##### 优点

- 减少开销

组合索引(col1,col2,col3)实际产生的作用等价于建了(col1),(col1,col2),(col1,col2,col3)三个索引。索引也需要磁盘空间，每多一个索引，不仅增加磁盘空间的开销，还多了一棵索引的查询和维护。对于大量数据的表，使用联合索引会大大的减少磁盘空间和执行开销！



- 覆盖索引

如果查询的列都包括在组合索引中，那么MySQL可以只遍历一次该组合索引，便可以取到`col1,col2,col3`三列的数据，而无需回表，这就减少了很多IO操作。



- 效率高

索引列越多，通过索引筛选出的数据越少。



##### 建立原则

- 从维护索引数量角度考虑，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的；
- 从索引占用空间角度考虑，如果必须要维护多个索引时，字段长的建立一次，短的建立两次；

```sql
alter table student add index key_city_age(city, age);
alter table student add index key_age(age);
```



因为age是int类型，占用空间较小，因此建立两次。而不是建立如下索引：

```sql
alter table student add index key_age_city(age, city);
alter table student add index key_city(city);
```



#### 唯一索引

唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。

在数据库的角度中，`NULL` != `NULL` , 所以唯一索引列，可以有多个空值。

每张表可以有多个唯一索引，但是只能有一个Primary索引。



#### 前缀索引

前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。



#### 空间索引

> 不常用

空间索引，空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。



#### 全文索引

> 不常用

全文索引（MySQL 5.6 之后InnoDB才支持），它是模糊匹配的一种更好的解决方案，它的效率要比使用`like %`更高，并且它还支持多种匹配方式，灵活性也更加强大。只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。

全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引

全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。

说是全文索引，其实它只代表可以实现全文检索的功能，而全文检索的底层实现，实际就是倒排索引，所以你也可以把全文索引的本质，当做是倒排索引。再了解全文检索之前，务必要先了解倒排索引

为什么叫倒排索引？

因为英文单词Inverted有颠倒的意思，然后可能就被翻译为倒排索引，也有很多地方叫反向索引。相对而言的索引就是正排索引（forward index）
倒排索引和正排索引，我的个人理解是，它与我们之前说的B+索引，哈希索引的应用不同。拿这些索引的知识去理解正排索引和倒排索引，感觉有些难以联系起来，容易混乱。因为正排，倒排是属于搜索引擎范畴的概念，所以理解正排，倒排最好还是先对搜索引擎有一些了解。比如使用过ElasticSearch
什么是倒排索引（Inverted index）？

说实话，倒排索引也不是一个简单的概念，很多搜索引擎的底层原理都是倒排索引，比如ElasticSearch等。
学习倒排索引的时候，最好还是需要一些搜索引擎的知识会更容易理解。

倒排索引就是相对正排索引相反而言的模型。正排索引是通过文档ID来遍历文档内容，找到关键字（文档 -> 关键字）。而倒排索引则是通过关键字，找到所在的文档（关键字 -> 文档）

以上正排索引，假如我们的搜索引擎是基于正排索引实现的，那么我们要在索引库中查询"python"关键字, 就很可能需要一个一个文档的进行遍历，直到在某个文档的内容中找到"python"单词。这样的一个时间复杂度是很大的，尤其是数据量很大的情况下。所以基于正排索引实现的搜索引擎是不现实的

如果在每一文档录入搜索引擎索引库的时候，我们就对文档的内容进行分词，统计，分析。建立倒排索引，记录分词得到的每个单词对应文档的出现位置和出现次数。 那么我们在搜索引擎查询"python"关键字，就会非常的快速，只需要通过关键字就可以马上查询到已经预处理的统计分析结果。也就知道了'python'关键字在文档A和文档B出现过。展示给用户即可。

这也是为什么是正排和倒排的原因，正排是通过文档查找关键字，倒排是通过关键字查到对应的文档。详细的倒排索引知识以后有时间再在ES的知识点中重点说明。




### 数据存储角度

#### 聚簇索引

MySQL在创建表时如果设置了主键（Primary Key），则会默认在主键列上设置索引，即主键索引（Primary Index）。在InnoDB里，主键索引也被称为**聚簇索引**（Clustered Index）。

**在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调递增的字段作为主键，这样会造成主索引频繁分裂。**



##### 特点

1. 数据唯一，不能为NULL



##### 非递增业务属性作为主键

有些业务的场景需求是这样的：

- 只有一个索引；
- 该索引必须是唯一索引。

此时由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。



#### 非聚簇索引

与主键索引相对的即是**辅助索引**（Secondary Index），辅助索引也被称为**二级索引**、**次级索引**。在InnoDB中也被称为非聚簇索引（No-Clustered Index）。**非聚簇索引会默认和主键做联合索引，但是和一般联合索引区别在于叶子节点上不包含主键。**



##### 特点

1. 一个表中可以包含多个非聚簇索引；
2. InnoDB的辅助键索引，以及MyISAM的主、辅索引都是非聚簇索引；
3. 非聚簇索引只存储主键（InnoDB）与指针（myisam），不存储数据。



##### 优点

- **因为一张表只能有一个聚簇索引，而非聚簇索引则可以有多个**；
- **非聚簇索引占用空间小**，因为叶子结点不存储真实数据，所以非聚簇索引相比聚簇索引更小；
- 在部分查询中，**可以利用覆盖索引的特性，加快查询速度**，直接从辅助键索引中获得想要的数据，而不需要做二次查询；
- **非聚簇索引只需要一次遍历，便可得到数据地址。**支持聚簇索引的存储引擎会导致其辅助键索引查询的结果只是一个中间结果，还需要通过该中间结果在聚簇索引再遍历一次。而不支持聚簇索引的存储引擎，只有非聚簇索引，非聚簇索引只需要一次遍历，即可得到真实数据的地址。



##### 缺陷

1. 非聚集索引只能按逻辑顺序存储数据，并不允许以物理空间连续的方式对数据行进行顺序存储。既非聚簇索引一个叶子结点内部的所有关键字仅仅是逻辑顺序的维护。一个结点对应真实数据在数据文件中可能并非按连续物理空间存储的。 相对聚簇索引的查询，IO次数可能更多，查询性能更低；
2. 相比聚簇索引，范围查询更慢，因为聚簇索引的范围查询可以让磁盘一次load出整个结点的数据线性遍历。虽然非聚簇索引的同叶子结点之间的关键字也是逻辑顺序存储，也可以线性遍历，但每线性遍历一个关键字都需要中间再跳转到另一个地方(InnoDB下的聚簇索引)遍历或(MyISAM下的数据文件)访问 。这个中间过程实际都是不同的IO操作，可能触发磁盘不同盘块的数据读取。所以本质还是会造成大量的IO操作；
3. 每当聚簇索引的主键值更新时，可能会触发非聚簇索引的更新，因为非聚簇索引的叶子结点可能存放的是主键信息（比如InnoDB）；
4. 每当数据文件中的数据发生更新时, 也可能会触发非聚簇索引的更新，因为可能会导致非聚簇索引叶子结点的数据地址发生改变（比如MyISAM）。



### 索引密度角度
#### 稠密索引

稠密索引（Dense Index）是有序的，包含所有数据对应的索引，索引数据包含关键字段值和指向数据的指针。

>**Dense Index :**
>
>- An index record appears for every search key value in file.
>- This record contains search key value and a pointer to the actual record.



##### 特点

- 稠密索引的真实数据是按顺序储存的；
- 为每一个键都创建一个索引记录；
- 每个索引记录都包含键本身和指向实际数据的指针；
- 因为每个键都有索引，所以可以直接通过索引就找到目的键对应的数据。



#### 稀疏索引

稀疏索引（Sparse Index）是有序的，包含部分数据对应的索引，索引数据包含关键字段值和指向数据的指针。

>**Sparse Index :**
>
>- Index records are created only for some of the records.
>- To locate a record, we find the index record with the largest search key value less than or equal to the search key value we are looking for.
>- We start at that record pointed to by the index record, and proceed along the pointers in the file (that is, sequentially) until we find the desired record.



##### 特点

- 稀疏索引的真实数据是按顺序存储的；
- 只为部分的键创建索引记录；
- 当在稀疏索引中查找某个目的键时，通常会通过索引，先找到小于或等于目的键的其他键的数据项，既通过索引找到比目的键值要小的数据项（如果目的键有索引，就直接找到目的键的数据）。然后在数据项按顺序遍历(线性)，直到找到目的键的数据记录。



##### 稠密索引和稀疏索引的优缺点

- 相对某列键而言，稠密索引对每个数据都建有索引，要查询起来，直接快速。但是因为要为每个数据都建立对应的索引，所以需要比较大的空间资源
- 而稀疏索引因为只针对部分数据建立索引，所以空间资源占用小，但是查询效率相对比较慢

## 存储引擎支持

### 数据结构角度

| 索引        | INNODB                         | MYISAM | MEMORY | HEAP | NDB  |
| ----------- | ------------------------------ | ------ | ------ | ---- | ---- |
| BTREE索引   | 支持                           | 支持   | 支持   |      |      |
| HASH 索引   | 不支持（支持自适应的HASH索引） | 不支持 | 支持   | 支持 | 支持 |
| R-tree 索引 | 不支持                         | 支持   | 不支持 |      |      |



### 主键角度

| 索引     | INNODB引擎 | MYISAM引擎 | MEMORY引擎 |
| -------- | ---------- | ---------- | ---------- |
| 主键索引 | 支持       | 支持       | 支持       |
| 辅助索引 | 支持       | 支持       | 支持       |



### 应用层次角度

| 索引               | INNODB引擎      | MYISAM引擎 | MEMORY引擎 |
| ------------------ | --------------- | ---------- | ---------- |
| 全文索引(FULLTEXT) | 5.6版本之后支持 | 支持       | 不支持     |



### 数据存储角度

| 索引       | INNODB引擎 | MYISAM引擎 | MEMORY引擎 |
| ---------- | ---------- | ---------- | ---------- |
| 聚簇索引   | 支持       | 不支持     | ？         |
| 非聚簇索引 | 支持       | 支持       | ？         |






## 聚簇索引

### 概述

聚簇索引（Clustered Index）又称`聚集索引`，将根据键值对数据库表中的数据进行排序存储，并将相关的信息聚簇在一起索引就叫聚簇索引（**该顺序是物理上连续的存储空间的顺序**）。

- 如果定义了主键，那么 InnoDB 会使用主键作为聚簇索引
- 如果没有定义主键，那么会使用第一非空的唯一索引（NOT NULL and UNIQUE INDEX）作为聚簇索引
- 如果既没有主键也找不到合适的非空索引，InnoDB会在内部生成一个名为`GEN_CLUST_INDEX`隐式聚簇索引。该索引是基于一个名为`DB_ROW_ID`的隐藏字段，通常称之隐式主键。InnoDB 会自动帮你创建一个不可见的、长度为 6 字节的 row_id，而且 InnoDB 维护了一个全局的 dictsys.row_id，所以未定义主键的表都共享该row_id，每次插入一条数据，都把全局 row_id 当成主键 id，然后全局 row_id 加 1



#### 特点

1. 定义了数据存储在表中的顺序，该表的数据有且仅以一种方式排序。因此，**每个表只能有一个聚簇索引**；
2. 聚簇索引其中一个大特征就是将索引和数据存储在同一个文件中，叶子结点不仅保存键的信息，还保存了位于同一行其他列的信息，**聚簇索引的叶子结点保存的是一个完整行记录数据**；
3. 聚簇索引是一种有序索引，它的具体实现可以是稠密索引，也可以是稀疏索引。



#### 优点

- **聚簇索引可以将相关的数据紧密的关联起来，存储在相邻的连续物理空间，利于范围查询**，比如将相关的数据存放在一个叶子结点上，既一个结点的多个关键字对应的数据都存储在一个数据页中，范围查询时，磁盘一次Load出即可，降低IO操作次数，比如针对MAX, MIN, COUNT等聚集函数都有很好的作用；

- **聚簇索引将数据和索引存储在同一个数据文件。** 既聚簇索引的叶子结点不仅存放键的信息，还存储相关其他列的完全数据。当查询走聚簇索引，不需要中间人跳转，直接就可以获得目的数据，查询效率更快。



#### 缺陷

- 因为聚簇索引是顺序存储的，如果多次的插入操作是以非顺序的方式执行，那么最终聚簇索引需要不断的维护这个顺序，这是需要一定性能消耗的；
- 当聚簇索引中的主键发生更改时，可能需要重新维护顺序，迫使物理空间的交换，所以聚簇索引需要更长的时间来更新记录；
- 支持聚簇索引的存储引擎的辅助键索引的查询结果只是一个中间结果，还需要通过中间结果到聚簇索引上二次查询，即回表，操作相对繁琐。



### 扩展

#### 为什么InnoDB存储引擎一定要有聚簇索引呢？

如果SQL条件是一个非主键列的数据，那么在索引查询中，很可能需要跨树查询，既两次查询。

因为InnoDB的辅助索引的叶子结点并不存储行数据，而是对应的主键值。查询时需要根据辅助键索引查询到的主键值，再去聚簇索引中查询。



没有建立主键的话就没法通过主键来进行索引，查询的时候都是全表扫描，大数据量就会出现性能问题。插入时生成需要共享一个序列，高并发插入时为了保持唯一性就避免不了锁的竞争，进而影响性能。





## 重建索引

索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。



### 重建主键索引

```sql
alter table student engine=InnoDB
```



该语句在innobDB里会触发mysql重建该表，并进行碎片处理。



#### 错误做法

```sql
alter table student drop primary key;
alter table student add primary key(id);
```



不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。



### 重建一般索引

```sql
alter table student drop index key_address_city;
alter table student add index key_address_city(address, city);
```




## 查看索引使用情况

```sql
-- 查看当前会话索引使用情况
mysql> show status like 'Handler_read%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 3     |
| Handler_read_key      | 14    |
| Handler_read_last     | 0     |
| Handler_read_next     | 4     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 7     |
+-----------------------+-------+
7 rows in set (0.00 sec)
```



- Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。
- Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。
- Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。
- Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。
- Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。
- Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。