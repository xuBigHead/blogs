---
layout: post
title: 第004章-Go 运算操作符
categories: [Go]
description: 
keywords: Go 运算操作符.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# Go 运算操作符

二元运算符运算需要其两个操作数类型必须一样时，这指：

- 如果这两个操作数都是类型确定值，则它们的类型必须相同，或者其中一个操作数可以被隐式转换到另一个操作数的类型；
- 如果其中只有一个操作数是类型确定的，则要么另外一个类型不确定操作数可以表示为此类型确定操作数的类型的值，要么此类型不确定操作数的默认类型的任何值可以被隐式转换到此类型确定操作数的类型；
- 如果这两个操作数都是类型不确定的，则它们必须同时都为两个布尔值，同时都为两个字符串值，或者同时都为两个基本数字值；



一个运算符（一元或者二元）运算要求其涉及的某个操作数的类型必须为某个特定类型时，这指：

- 如果操作数是类型确定的，则它的类型必须为所要求的特定类型，或者此操作数可以被隐式转换为所要求的特定类型；
- 如果操作数是类型不确定的，则要么此操作数可以表示为所要求的特定类型值，要么此操作数的默认类型的任何值可以被隐式转换为所要求的特定类型；



### 常量表达式

表达式中涉及到的所有操作数都是常量时，此表达式称为常量表达式；如果表达式中涉及到的操作数中至少有一个不为常量，则此表达式称为非常量表达式。常量表达式的估值是在编译阶段进行的，常量表达式的估值结果依然是常量，常量子表达式的顺序有可能影响到最终的估值结果。

```go
var x = 1.2 + 3/2 // 3/2被优先估值为1，然后估值1.2 + 1，结果为2.2
const x = 3/2*0.1 // 3/2被优先估值为1，然后估值1*0.1，结果为0.1
const y = 0.1*3/2 // 0.1*3被优先估值为0.3，然后估值0.3/2，结果为0.15
```



### 算术运算符

#### 二元算术运算符

Go支持五个基本二元算术运算符：

- 加减乘除（`+、-、*、/`）：两个运算数的类型必须相同并且为基本数值类型；
- 余数（`%`）：两个运算数的类型必须相同并且为基本整数数值类型；

```go
func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// 这些行编译没问题。
	_ = 12 + 'A' // 两个类型不确定操作数（都为数值类型）
	_ = 12 - a   // 12将被当做a的类型（float32）使用。
	_ = a * b    // 两个同类型的类型确定操作数。
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2

	// 这些行编译将失败。
	_ = a % b   // error: a和b都不是整数
	_ = c + e   // error: c和e的类型不匹配
}
```



#### 位运算符

Go支持六种位运算符：

- 位于、位或、异或、清位（`&、|、^、&^`）：两个操作数的类型必须相同并且为基本整数数值类型，清位运算符`&^`是Go中特有的一个运算符。 `m &^ n`等价于`m & (^n)`
- 左移位、右移位（`<<、>>`）：左操作数必须为一个整数，右操作数必须为一个非负整数，但它们的类型可以不同；在右移运算中，左边空出来的高位全部用左操作数的最高位（即正负号位）填充。

```go
func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// 这些行编译没问题。
	_, _, _, _ = c | d, c & d, c ^ d, c &^ d
	_, _, _, _ = d << e, 123 >> e, e >> 3, 0xF << 0

	// 这些行编译将失败。
	_ = a | b   // error: a和b都不是整数
	_ = b >> 5  // error: b不是一个整数
	_ = c >> -5 // error: -5不是一个无符号整数

	_ = e << uint(c) // 编译没问题
	_ = e << c       // 从Go 1.13开始，此行才能编译过
	_ = e << -c      // 从Go 1.13开始，此行才能编译过，将在运行时刻造成恐慌。
	_ = e << -1      // error: 右操作数不能为负（常数）
}
```



可以使用位运算符来声明一个最大的int和uint常量。

```go
const MaxUint = ^uint(0)
const MaxInt = int(^uint(0) >> 1)
```



#### 一元算数运算符

Go也支持三个一元算术运算符：

- 取正数（`+`）：`+n`等价于`0 + n`；
- 取负数（`-`）：`-n`等价于`0 - n`；
- 位反（`^`）：`^n`等价于`m ^ n`，其中`m`和`n`同类型并且它的二进制表示中所有比特位均为1；



一些运算符的使用示例：

```go
func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// 这些行编译没问题。
	_, _, _, _ = -b, +c, ^e, ^-1
}
```



#### 溢出

- 类型确定数字型常量所表示的值是不能溢出它的类型的表示范围的；
- 类型不确定数字型常量所表示的值是可以溢出它的默认类型的表示范围的，当类型不确定数字常量值溢出它的默认类型的表示范围时，此数值不会被截断；
- 将非常量数字值转换为其它数字类型时，此非常量数字值可以溢出转化结果的类型，在此转换中发生溢出时，转化结果为此非常量数字值的截断表示;



对于一个算数运算的结果，上述规则同样适用。示例：

```go
// 结果为非常量
var a, b uint8 = 255, 1
var c = a + b  // c==0，a+b是一个非常量表达式，结果中溢出的高位比特将被截断舍弃，100000000(256) -> 00000000
var d = a << b // d==254，同样，结果中溢出的高位比特将被截断舍弃，111111110 -> 11111110(254)

// 结果为类型不确定常量，允许溢出其默认类型。
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // 没问题，尽管X溢出
const R = 'a' + 0x7FFFFFFF          // 没问题，尽管R溢出

// 运算结果或者转换结果为类型确定常量
var e = X                // error: X溢出int。
var h = R                // error: R溢出rune。
const Y = 128 - int8(1)  // error: 128溢出int8。
const Z = uint8(255) + 1 // error: 256溢出uint8。
```



#### 算术运算的结果

除了移位运算，对于一个二元算术运算：

- 两个操作数都为类型确定值时，则此运算的结果也是一个和这两个操作数类型相同的类型确定值；
- 只有一个操作数是类型确定时，则此运算的结果也是一个和此类型确定操作数类型相同的类型确定值，另一个类型不确定操作数的类型将被推断为（或隐式转换为）此类型确定操作数的类型；
- 两个操作数均为类型不确定值时，则此运算的结果也是一个类型不确定值。在运算中，两个操作数的类型将被设想为它们的默认类型中一个（按照此优先级来选择：`complex128`高于`float64`高于`rune`高于`int`），结果的默认类型同样为此设想类型。比如，如果一个类型不确定操作数的默认类型为`int`，另一个类型不确定操作数的默认类型为`rune`，则前者的类型在运算中也被视为`rune`，运算结果为一个默认类型为`rune`的类型不确定值；



一些非移位算术运算的例子：

```go
func main() {
	const X, Y, Z = 2, 'A', 3i // 三个类型不确定常量，它们的默认类型分别为：int、rune和complex64.
	var a, b int = X, Y // 两个类型确定值
	d := X + Y // 变量d的类型被推断为Y的默认类型：rune（亦即int32）。
	e := Y - a // 变量e的类型被推断为a的类型：int。
	f := a * b // 变量f的类型和a及b的类型一样：int。
	g := Z * Y // 变量g的类型被推断为Z的默认类型：complex64。
	println(X, Y, Z) // 2 65 (+0.000000e+000+3.000000e+000i)
	println(d, e, f, g) // 67 63 130 (+0.000000e+000+1.950000e+002i)
}
```



对于移位运算，结果规则有点小复杂，首先移位运算的结果肯定都是整数：

- 如果左操作数是一个类型确定值（则它的类型必定为整数），则此移位运算的结果也是一个和左操作数类型相同的类型确定值；
- 如果左操作数是一个类型不确定值**并且右操作数是一个常量**，则左操作数将总是被视为一个整数。如果它的默认类型不是一个整数（`rune`或`int`），则它的默认类型将被视为`int`。此移位运算的结果也是一个类型不确定值并且它的默认类型和左操作数的默认类型一致。
- 如果左操作数是一个类型不确定值**并且右操作数是一个非常量**，则左操作数将被首先转化为运算结果的期待设想类型。如果期待设想类型并没有被指定，则左操作数的默认类型将被视为它的期待设想类型。如果此期待设想类型不是一个内置整数类型，则编译报错。当然最终运算结果是一个类型为此期待设想类型的类型确定值。



一个移位算术运算的例子：

```go
const N = 2
const A = 3.0 << N // A == 12，它是一个默认类型为int的类型不确定值。
const B = int8(3.0) << N // B == 12，它是一个类型为int8的类型确定值。
var m = uint(32)
// 下面的三行是相互等价的。
var x int64 = 1 << m  // 1的类型将被设想为int64，而非int
var y = int64(1 << m) // 同上
var z = int64(1) << m // 同上

// 下面这行编译不通过。
/*
var _ = 1.23 << m // error: 浮点数不能被移位
*/
```



上面提到的移位运算结果的最后一点类型推断规则有点反常，这条规则的主要目的是为了防止一些移位运算在32位架构和64位架构的机器上的运算结果出现不一致但不一致却没有被及时发现的情况。比如如果上面一段代码中第*10*行（或第*9*行）的`1`的类型被推断为它的默认类型`int`， 则在32位架构的机器上，`x`的取值在运行时刻将被截断为*0*，而在64位架构的机器上，`x`的取值在运行时刻将为*232*。 因为`m`是一个变量，在32位架构的机器上，第*9*行和第*10*行并不会在编译时刻报错。这将导致Go程序员在不经意间写出没有料到的和难以觉察的bug。因此，第*9*行和第*10*行中的`1`的类型被推断为`int64`（最终的设想结果类型），而不是它们的默认类型`int`。

下面这段代码展示了对于左操作数为类型不确定值的移位运算，编译结果因右操作数是否为常量而带来的不同结果：

```go
const n = uint(2)
var m = uint(2)

// 这两行编译没问题。
var _ float64 = 1 << n
var _ = float64(1 << n)

// 这两行编译失败。
var _ float64 = 1 << m  // error
var _ = float64(1 << m) // error
```



上面这段代码最后两行编译失败是因为它们都等价于下面这两行：

```go
var _ = float64(1) << m
var _ = 1.0 << m // error: shift of type float64
```



另一个例子：

```go
package main

const n = uint(8)
var m = uint(8)

func main() {
	println(a, b) // 2 0
}

var a byte = 1 << n / 128
var b byte = 1 << m / 128
```



上面这个程序打印出`2 0`，因为最后两行等价于：

```go
var a = byte(int(1) << n / 128)
var b = byte(1) << m / 128
```



#### 除法和余数运算

假设两个操作数`x`和`y`的类型为同一个整数类型，则它们通过除法和余数运算得到的商`q`（`= x / y`）和余数`r`（`= x % y`）满足`x == q*y + r`（`|r| < |y|`），如果余数`r`不为零，则它的符号和被除数`x`相同，商`q`的结果为`x / y`向零靠拢截断。

如果除数`y`是一个常量，则它必须不为0，否则编译不通过；如果它是一个整数型非常量，则在运行时刻将抛出一个恐慌（panic），如果除数`y`非整数型的非常量，则运算结果为一个无穷大（Inf，当被除数不为0时）或者NaN（not a number，当被除数为0时）。示例：

```go
println( 5/3,   5%3)  // 1 2
println( 5/-3,  5%-3) // -1 2
println(-5/3,  -5%3)  // -1 -2
println(-5/-3, -5%-3) // 1 -2

println(5.0 / 3.0)     // 1.666667
println((1-1i)/(1+1i)) // -1i

var a, b = 1.0, 0.0
println(a/b, b/b) // +Inf NaN

_ = int(a)/int(b) // 编译没问题，但在运行时刻将造成恐慌。

// 这两行编译不通过。
println(1.0/0.0) // error: 除数为0
println(0.0/0.0) // error: 除数为0
```



#### `op=`运算符

对于一个二元算数运算符`op`，语句`x = x op y`可以被简写为`x op= y`，在这个简写的语句中，`x`只会被估值一次。示例：

```go
var a, b int8 = 3, 5
a += b
println(a) // 8
a *= a
println(a) // 64
a /= b
println(a) // 12
a %= b
println(a) // 2
b <<= uint(a)
println(b) // 20
```



#### 自增和自减操作符

Go也支持自增（`++`）和自减（`--`）操作符，不过和其它语言不一样的是，自增（`aNumber++`）和自减（`aNumber--`）操作没有返回值，所以它们不能当做表达式来使用。另一个区别是，在Go中，自增（`++`）和自减（`--`）操作符只能后置，不能前置。一个例子：

```go
package main

func main() {
	a, b, c := 12, 1.2, 1+2i
	a++ // ok. <=> a += 1 <=> a = a + 1
	b-- // ok. <=> b -= 1 <=> b = b - 1
	c++ // ok.

	// 下面这些行编译不通过。
	/*
	_ = a++
	_ = b--
	_ = c++
	++a
	--b
	++c
	*/
}
```



### 字符串衔接运算符

加法运算符也可用做字符串衔接运算符，两个操作数必须为同一类型的字符串值；`+=`运算符也适用于字符串衔接。如果字符串衔接运算中的一个操作值为类型确定的，则结果字符串是一个类型和此操作数类型相同的类型确定值，否则，结果字符串是一个类型不确定值（肯定是一个常量）。示例：

```go
println("Go" + "lang") // Golang
var a = "Go"
a += "lang"
println(a) // Golang
```



### 布尔/逻辑运算符

Go支持两种布尔二元运算符和一种布尔一元运算符，如果一个布尔运算中的一个操作值为类型确定的，则结果为一个和此操作值类型相同的类型确定值，否则，结果为一个类型不确定布尔值。

- 布尔与、布尔或（`&&、||`）：两个操作值的类型必须为同一布尔类型；
- 布尔否（`!`）：唯一的一个操作值的类型必须为一个布尔类型



机理解释：

```go
// x    y       x && y   x || y   !x      !y
true    true    true     true     false   false
true    false   false    true     false   true
false   true    false    true     true    false
false   false   false    false    true    true
```



### 比较运算符

Go支持6种比较运算符：

- 等于、不等于（`==、!=`）：如果两个操作数都为类型确定的，则它们的类型必须一样，或者其中一个操作数可以隐式转换为另一个操作数的类型，两者的类型必须都为可比较类型。如果只有一个操作数是类型确定的，则另一个类型不确定操作数必须可以隐式转换到类型确定操作数的类型。如果两个操作数都是类型不确定的，则它们必须同时为两个类型不确定布尔值、两个类型不确定字符串值或者两个类型不确定数字值；
- 小于、小于或等于、大于、大于或等于（`<、<=、>、>=`）：两个操作数的类型必须相同并且它们的类型必须为整数类型、浮点数类型或者字符串类型；



比较运算的结果总是一个类型不确定布尔值，如果一个比较运算中的两个操作数都为常量，则结果布尔值也为一个常量。如果说两个值可以比较，即说这两个值可以用`==`或者`!=`运算符来比较。

并非所有的实数在内存中都可以被精确地表示，所以比较两个浮点数或者复数的结果并不可靠，在编程中常常比较两个浮点数的差值是否小于一个阙值来检查两个浮点数是否相等。



### 操作符运算的优先级

Go中的操作符运算的优先级和其它流行语言明显的差别是，移位运算`<<`和`>>`的优先级比加减法`+`和`-`的优先级要高。下面列出了操作符的优先级，同一行中的操作符的优先级是一样的，优先级逐行递减。

```go
*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
```



递增运算符`++`和递减运算符`--`的优先级低于解引用运算符`*`和取地址运算符`&`，解引用运算符和取地址运算符的优先级低于选择器`.`中的属性选择操作符。

```go
type T struct {
	x int
	y *int
}

func TestOperatorsPrecedence(test *testing.T) {
	var t T
	p := &t.x             // <=> p := &(t.x)
	fmt.Printf("%T\n", p) // *int

	*p++ // <=> (*p)++
	*p-- // <=> (*p)--

	t.y = p
	a := *t.y             // <=> *(t.y)
	fmt.Printf("%T\n", a) // int
}
```



一个表达式（做为一个子表达式）可以出现在另一个表达式中，这个子表达式的估值结果将成为另一个表达式的一个操作数。在这样的复杂表达式中，对于相同优先级的运算，它们将从左到右进行估值，也可用一对小括号`()`来提升一个子运算的优先级。