---
layout: post
title: 2024-01-02-Redis 生产应用.md
categories: [Redis]
description: 
keywords: Redis 生产应用.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# Production Solution

## 缓存失效场景

### 缓存穿透

#### 定义

缓存穿透是指查询一个一定不存在的数据，每次请求都要到数据库去查询，失去了缓存的意义。



#### 解决方案

##### 布隆过滤器

采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，不存在的数据会被bitmap拦截掉，从而避免了对底层存储系统的查询压力。



**缺陷**

- 该方案要求技术难度，且可能会有一定的误差（哈希碰撞）。
- 布隆过滤器更新失败。如果使用布隆过滤器，在对 Hash Map 进行数据更新时，需要保证这个数据能 100% 更新成功，可以通过异步、重试的方式，所以这个方案有一定的实现成本和风险。



##### 缓存空结果

如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），仍然把这个空结果进行缓存，并设置一个较短的过期时间。



**缺陷**

在过期时间内可能会查不到最新的数据，导致数据不一致。



### 缓存击穿

#### 定义

缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把数据库压垮，**更强调瞬时性。**



#### 解决方案

##### 分布式锁

缓存失效时，不是立即请求数据库，而是先设置一个缓存互斥锁，如果设置成功，则去查询数据库；如果设置失败，则表示有其他请求正在查询数据库并更新缓存。此时只要重试从缓存中获取数据即可。



**缺陷**

降低了系统的处理并发的能力，存在死锁的风险。



##### 提前互斥

在value内部设置1个超时值(timeout1)，timeout1比实际的超时值(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache，然后再从数据库加载数据并设置到cache中。



**缺陷**

降低了系统的处理并发的能力，存在死锁的风险。



##### 永远不过期

针对某些场景下的缓存数据，可以不设置过期时间，从而使缓存永远不过期。比如热门商品，都先预热到缓存，后续再下线掉。



**缺陷**

该方案缺乏通用性，只能针对某些缓存不会频繁变化的场景使用。



#### 缓存击穿与缓存穿透的区别

缓存击穿是指存在的数据设置的缓存过期那一段时间内有大量请求导致数据库压力过大；缓存穿透指不存在的数据，因为没有缓存而导致不停的请求数据库，导致数据库压力过大。

1. 短时间内有大量缓存同时过期；
2. 缓存服务宕机，导致某一时刻发生大规模的缓存失效。



### 缓存雪崩

#### 定义

缓存雪崩是指设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到数据库，数据库瞬时压力过重雪崩。



#### 解决方案

##### 随机过期时间

在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，从而降低发生缓存雪崩的概率。



**缺陷**

不适用与强制指定规定时长的过期时间的场景。



##### 限流和降级

限制每秒请求数次，剩余的请求走降级处理，返回一些默认的值或友情提示等默认操作。



**缺陷**

用户不友好，部分用户无法使用。



- 事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
- 事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。



##### 分布式锁

加一个分布式锁，第一个请求将数据持久化到缓存后，其它的请求才能进入。



##### 集群部署

Redis 通过集群部署、主从策略，主节点宕机后，会切换到从节点，保证服务的可用性。



## 数据一致性

在分布式环境下，缓存和数据库很容易出现数据一致性问题，如果项目对缓存的要求是强一致性，那就不要使用缓存。

只能在项目中使用策略降低缓存与数据库一致性的概率，是无法保障两者的强一致性，一般策略包括缓存更新机制，更新数据库后及时更新缓存、缓存失败时增加重试机制。



### 延时双删策略

执行流程：

- 先删除缓存

- 再更新数据库

- 休眠一会（比如1秒），再次删除缓存。





### 删除缓存重试机制

延时双删第三步删除失败时，可以进行重试。

执行流程：

- 写请求更新数据库
- 缓存因为某些原因，删除失败
- 把删除失败的key放到消息队列
- 消费消息队列的消息，获取要删除的key
- 重试删除缓存操作



### 读取biglog异步删除缓存

重试删除缓存机制会造成业务代码入侵，可以通过数据库的binlog来异步淘汰key。

可以使用阿里的canal将binlog日志采集发送到MQ队列里面，然后编写一个的缓存删除消息者订阅binlog日志，根据更新log删除缓存，并且通过ACK机制确认处理这条更新log，保证数据缓存一致性。



**如果是主从数据库**的情况下，因为主从DB同步存在延时时间，如果删除缓存之后，数据同步到从库之前已经有请求过来时， **会从从库中读到脏数据**。此时可以通过从从库中获取binlog来解决。





## 缓存模式



### 旁路缓存模式

**旁路缓存模式**（Cache Aside Pattern）指更新 DB，然后直接删除 cache 。删除缓存这一步失败的话，则**增加cache更新重试机制**。