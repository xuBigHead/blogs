# Go 基本流程控制语法

## 概述

Go语言中有三种基本的流程控制代码块：`if-else`条件分支代码块；`for`循环代码块；`switch-case`多条件分支代码块。Go中另外还有几种和特定种类的类型相关的流程控制代码块：用来遍历整数、容器、通道和某些函数的`for-range`循环代码块；接口相关的`type-switch`多条件分支代码块；通道相关的`select-case`多分支代码块。

Go也支持`break`、`continue`和`goto`等跳转语句，Go还支持一个特有的`fallthrough`跳转语句。Go所支持的六种流程控制代码块中，除了`if-else`条件分支代码块，其它五种称为可跳出代码块，可以在一个可跳出代码块中使用`break`语句以跳出此代码块。可以在`for`和`for-range`两种循环代码块中使用`continue`语句提前结束一个循环步。



## 流程控制语句

### if-else 条件分支

一个`if-else`条件分支控制代码块的完整形式如下：

```go
if InitSimpleStatement; Condition {
	// do something
} else {
	// do something
}
```



`if`和`else`是两个关键字，`else`分支是可选的。每个`if-else`流程控制包含一个隐式代码块，一个`if`分支显式代码块和一个可选的`else`分支代码块。这两个分支代码块内嵌在这个隐式代码块中。在程序运行中，如果`Condition`条件表达式的估值结果为`true`，则`if`分支式代码块将被执行；否则`else`分支代码块将被执行。在一个`if-else`条件分支控制代码块中，

- `InitSimpleStatement`部分是可选的，
  - 如果它没被省略掉，则它必须为一条简单语句，该语句会被率先执行；在实际编程中，`InitSimpleStatement`常常为一条变量短声明语句；
  - 如果它被省略掉，它可以被视为一条空语句（简单语句的一种），其后跟随的分号`;`也可一块儿被省略。
- `Condition`必须为一个结果为布尔值的表达式（被称为条件表达式），`Condition`部分可以用一对小括号括起来，但大多数情况下不需要；
- 不能用一对小括号将`InitSimpleStatement`和`Condition`两部分括在一起。



一个例子：

```go
func main() {
	rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要

	if n := rand.Int(); n%2 == 0 {
		fmt.Println(n, "是一个偶数。")
	} else {
		fmt.Println(n, "是一个奇数。")
	}

	n := rand.Int() % 2 // 此n不是上面声明的n
	if n % 2 == 0 {
		fmt.Println("一个偶数。")
	}

	if ; n % 2 != 0 {
		fmt.Println("一个奇数。")
	}
}
```



如果`InitSimpleStatement`语句是一个变量短声明语句，则在此语句中声明的变量被声明在外层的隐式代码块中。可选的`else`分支代码块一般情况下必须为显式的，但是如果此分支为另外一个`if-else`块，则此分支代码块可以是隐式的。另一个例子：

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	if h := time.Now().Hour(); h < 12 {
		fmt.Println("现在为上午。")
	} else if h > 19 {
		fmt.Println("现在为晚上。")
	} else {
		fmt.Println("现在为下午。")
		// 左h是一个新声明的变量，右h已经在上面声明了。
		h := h
		// 刚声明的h遮掩了上面声明的h。
		_ = h
	}

	// 上面声明的两个h在此处都不可见。
}
```



### switch-case 条件分支

`switch-case`流程控制代码块是另外一种多分支代码块，其中`switch`、`case`和`default`是三个关键字，一个`switch-case`流程控制代码块的完整形式为：

```go
switch InitSimpleStatement; CompareOperand0 {
case CompareOperandList1:
	// do something
case CompareOperandList2:
	// do something
...
case CompareOperandListN:
	// do something
default:
	// do something
}
```



在一个`switch-case`流程控制代码块中，

- `InitSimpleStatement`部分必须为一条简单语句，它是可选的；
- `CompareOperand0`部分必须为一个表达式（如果它没被省略的话，见下），此表达式的估值结果总是被视为一个类型确定值。如果它是一个类型不确定值，则它被视为类型为它的默认类型的类型确定值，所以此表达式不能为类型不确定的`nil`值。`CompareOperand0`常被称为switch表达式；
- 每个`CompareOperandListX`部分（`X`表示`1`到`N`）必须为一个用逗号分隔开来的表达式列表，其中每个表达式都必须能和`CompareOperand0`表达式进行比较，每个这样的表达式常被称为case表达式。如果case表达式是一个类型不确定值，则它必须能够自动隐式转化为对应的switch表达式的类型，否则编译将失败；
- 每个`case CompareOperandListX:`部分和`default:`之后形成了一个隐式代码块，每个这样的隐式代码块和它对应的`case CompareOperandListX:`或者`default:`形成了一个分支，每个分支都是可选的；
- 每个`switch-case`流程控制代码块中最多只能有一个`default`分支（默认分支），`default`分支位置没有强制要求，不必一定为最后一个分支；
- `switch-case`代码块属于可跳出流程控制，`break`可以使用在一个`switch-case`流程控制的任何分支代码块之中以提前跳出此`switch-case`流程控制；



当`switch-case`流程控制执行时，`InitSimpleStatement`先被执行（仅一次），随后`CompareOperand0`将被估值（仅一次）。然后此结果值将从上到下从左到右和各个`CompareOperandListX`表达式列表中的各个case表达式逐个依次比较（使用`==`运算符）。 一旦发现某个表达式和`CompareOperand0`相等，比较过程停止并且此表达式对应的分支代码块将得到执行。 如果没有任何一个表达式和`CompareOperand0`相等，则`default`默认分支将得到执行（如果此分支存在的话）。



一个`switch-case`流程控制的例子：

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
	switch n := rand.Intn(100); n%9 { // `rand.Intn`函数将返回一个从`0`到所传实参之间类型为`int`的随机数
	case 0:
		fmt.Println(n, "is a multiple of 9.")
		// 和很多其它语言不一样，程序不会自动自动从当前分支代码块跳到下一个分支代码块去执行，所以，这里不需要一个break语句
	case 1, 2, 3:
		fmt.Println(n, "mod 9 is 1, 2 or 3.")
		break // 这里的break语句可有可无的，效果是一样的，执行不会跳到下一个分支
	case 4, 5, 6:
		fmt.Println(n, "mod 9 is 4, 5 or 6.")
	// case 6, 7, 8:
		// 上一行可能编译不过，因为6和上一个case中的6重复了，是否能编译通过取决于具体编译器实现
	default:
		fmt.Println(n, "mod 9 is 7 or 8.")
	}
}
```



编译器可能会不允许一个`switch-case`流程控制中有任何两个case表达式可以在编译时刻确定相等，比如，当前的官方标准编译器（1.23版本）认为上例中的`case 6, 7, 8`一行是不合法的（如果此行未被注释掉）。但是其它编译器未必这么认为，事实上，当前的官方标准编译器允许重复的布尔case表达式在同一个`switch-case`流程控制中出现，而gccgo（v8.2）允许重复的布尔和字符串类型的case表达式在同一个`switch-case`流程控制中出现。

每个分支代码块的结尾不需要一条`break`语句就可以自动跳出当前的`switch-case`流程控制。



一个`switch-case`流程控制中的`InitSimpleStatement`语句和`CompareOperand0`表达式都是可选的，如果`CompareOperand0`表达式被省略，则它被认为类型为`bool`类型的`true`值；如果`InitSimpleStatement`语句被省略，其后的分号也可一并被省略。

上面已经提到了一个`switch-case`流程控制中的所有分支都可以被省略，所以下面的所有流程控制代码块都是合法的，它们都可以被视为空操作。

```go
switch n := 5; n {
}

switch 5 {
}

switch _ = 5; {
}

switch {
}
```



上例中的后两个`switch-case`流程控制中的`CompareOperand0`表达式都为`bool`类型的`true`值。`switch`流程控制代码块中的switch表达式的缺省默认值为类型确定值`true`，其类型为预声明类型`bool`。下例中的代码将打印出`hello`：

```go
switch { // <=> switch true {
case true: fmt.Println("hello")
default: fmt.Println("bye")
}
```



`switch`表达式总是被估值为类型确定值，如下列`switch`代码块中的switch表达式`123`被视为一个`int`值，而不是一个类型不确定的整数。

```go
func TestSwitchValueKind(t *testing.T) {
    switch 123 {
    case int64(123):  // 编译错误: Invalid case 'int64(123)' in switch on '123' (mismatched types 'int64' and 'int')
    case uint32(789): // 编译错误: Invalid case 'uint32(789)' in switch on '123' (mismatched types 'uint32' and 'int')
    }
}
```



#### case分支

`switch`流程控制代码块中的数字常量case表达式不能重复。

```go
func TestDuplicateCaseValue(t *testing.T) {
	// switch 123 {
	// case 123:
	// case 123: // 编译错误：duplicate case 123 (constant of type int) in expression switchcompilerDuplicateCase
	// }

	switch false {
	case false:
	case false: // 编译正常
	}
}
```



#### default分支

#### fallthrough关键字

`fallthrough`关键字让执行从一个`case`分支代码块的结尾跳入下一个分支代码块。`fallthrough`语句必须为一个分支代码块中的最后一条语句，且不能出现在一个`switch-case`流程控制中的最后一个分支代码块中。

```go
rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
switch n := rand.Intn(100) % 5; n {
case 0, 1, 2, 3, 4:
	fmt.Println("n =", n)
	fallthrough // 跳到下个代码块
case 5, 6, 7, 8:
	n := 99 // 一个新声明的n，它只在当前分支代码快内可见。
	fmt.Println("n =", n) // 99
	fallthrough
default:
	// 下一行中的n和第一个分支中的n是同一个变量，它们均为switch表达式"n"。
	fmt.Println("n =", n)
}
```



比如，下面代码的几个`fallthrough`使用是不合法的。

```go
switch n := rand.Intn(100) % 5; n {
case 0, 1, 2, 3, 4:
	fmt.Println("n =", n)
	// 此整个if代码块为当前分支中的最后一条语句
	if true {
		fallthrough // error: 不是当前分支中的最后一条语句
	}
case 5, 6, 7, 8:
	n := 99
	fallthrough // error: 不是当前分支中的最后一条语句
	_ = n
default:
	fmt.Println(n)
	fallthrough // error: 不能出现在最后一个分支中
}
```



### type-switch 条件分支

`type-switch`流程控制可以被看作是类型断言的增强版，它和`switch-case`流程控制代码块有些相似。一个`type-switch`流程控制代码块的语法如下所示：

```go
switch aSimpleStatement; v := x.(type) {
case TypeA:
	...
case TypeB, TypeC:
	...
case nil:
	...
default:
	...
}
```



其中`aSimpleStatement;`部分是可选的，必须是一个简单语句，`x`必须为一个估值结果为接口值的表达式，它称为此代码块中的断言值，`v`称为此代码块中的断言结果，它必须出现在一个短变量声明形式中。

在一个`type-switch`代码块中，每个`case`关键字后可以跟随预声明的`nil`标识符或者一个由逗号分割的若干个类型名和类型字面表示形式组成的类型列表。在同一个`type-switch`代码块中，这些跟随在所有`case`关键字后的条目不可重复。如果跟随在某个`case`关键字后的条目为一个非接口类型（用一个类型名或类型字面表示），则此非接口类型必须实现了断言值`x`的（接口）类型。

下面是一个使用了`type-switch`代码块的例子：

```go
package main

import "fmt"

func main() {
	values := []interface{}{456, "abc", true, 0.33, int32(789),	[]int{1, 2, 3}, map[int]bool{}, nil}
	for _, x := range values {
		// 这里，虽然变量v只被声明了一次，但是它在不同分支中可以表现为多个类型的变量值。
		switch v := x.(type) {
		case []int: // 一个类型字面表示，在此分支中，v的类型为[]int。
			fmt.Println("int slice:", v)
		case string: // 一个类型名，在此分支中，v的类型为string。
			fmt.Println("string:", v)
		case int, float64, int32: // 多个类型名，在此分支中，v的类型为x的类型interface{}。
			fmt.Println("number:", v)
		case nil: // 在此分支中，v的类型为x的类型interface{}。
			fmt.Println(v)
		default: // 在此分支中，v的类型为x的类型interface{}。
			fmt.Println("others:", v)
		}
		// 注意：在最后的三个分支中，v均为接口值x的一个复制。
	}
}
```

输出结果：

```
number: 456
string: abc
others: true
number: 0.33
number: 789
int slice: [1 2 3]
others: map[]
<nil>
```



上面这个例子程序在逻辑上等价于下面这个：

```go
package main

import "fmt"

func main() {
	values := []interface{}{456, "abc", true, 0.33, int32(789),	[]int{1, 2, 3}, map[int]bool{}, nil}
	for _, x := range values {
		if v, ok := x.([]int); ok {
			fmt.Println("int slice:", v)
		} else if v, ok := x.(string); ok {
			fmt.Println("string:", v)
		} else if x == nil {
			v := x
			fmt.Println(v)
		} else {
			_, isInt := x.(int)
			_, isFloat64 := x.(float64)
			_, isInt32 := x.(int32)
			if isInt || isFloat64 || isInt32 {
				v := x
				fmt.Println("number:", v)
			} else {
				v := x
				fmt.Println("others:", v)
			}
		}
	}
}
```



如果不关心一个`type-switch`代码块中的断言结果，则此`type-switch`代码块可简写为`switch x.(type) {...}`。`type-switch`代码块和`switch-case`代码块有很多共同点：

- 在一个`type-switch`代码块中，最多只能有一个`default`分支存在；
- 在一个`type-switch`代码块中，如果`default`分支存在，它可以为最后一个分支、第一个分支或者中间的某个分支；
- 一个`type-switch`代码块可以不包含任何分支，它可以被视为一个空操作；



但是，和`switch-case`代码块不一样的地方在于`fallthrough`语句不能使用在`type-switch`代码块中。



### select-case 分支条件

Go中有一个专门为通道设计的`select-case`分支流程控制语法。此语法和`switch-case`分支流程控制语法很相似，比如`select-case`流程控制代码块中也可以有若干`case`分支和最多一个`default`分支。但是这两种流程控制也有很多不同点，在一个`select-case`流程控制中，

- `select`关键字和`{`之间不允许存在任何表达式和语句；
- `fallthrough`语句不能被使用；
- `case`关键字后必须跟随一个通道接收数据操作或者一个通道发送数据操作，通道接收数据操作可以做为源值出现在一条简单赋值语句中，以后一个`case`关键字后跟随的通道操作将被称为一个`case`操作；
- 所有的非阻塞`case`操作中将有一个被**随机选择执行**，然后执行此操作对应的`case`分支代码块；
- 在所有的`case`操作均为阻塞的情况下，如果`default`分支存在，则`default`分支代码块将得到执行；否则当前协程将被推入所有阻塞操作中相关的通道的发送数据协程队列或者接收数据协程队列中，并进入阻塞状态；



按照上述规则，一个不含任何分支的`select-case`代码块`select{}`将使当前协程处于永久阻塞状态。



#### case分支随机执行

下面这个程序有50%的几率会因为恐慌而崩溃。 此程序中`select-case`代码块中的两个`case`操作均不阻塞，所以随机一个将被执行。 如果第一个`case`操作（向已关闭的通道发送数据）被执行，则一个恐慌将产生。

```go
func main() {
	c := make(chan struct{})
	close(c)
	select {
	case c <- struct{}{}: // 若此分支被选中，则产生一个恐慌
		fmt.Println("Panic !!!")
	case <-c:
		fmt.Println("No Panic")
	}
}
```



#### default分支

在下面这个例子中，`default`分支将肯定得到执行，因为两个`case`分支后的向nil值通道接收数据和发送数据操作均为阻塞的。`default`分支位置没有强制要求，不必一定为最后一个分支。

```go
func main() {
	var c chan struct{} // nil
	select {
	case <-c: // 阻塞操作
		fmt.Println("Get From Channel")
	case c <- struct{}{}: // 阻塞操作
		fmt.Println("Send To Channel")
	default:
		fmt.Println("All Block")
	}
}
```



下面这个例子中实现了尝试发送（try-send）和尝试接收（try-receive）。 它们都是用含有一个`case`分支和一个`default`分支的`select-case`代码块来实现的。

```go
func main() {
	c := make(chan string, 2)
	trySend := func(v string) {
		select {
		case c <- v:
		default: // 如果c的缓冲已满，则执行默认分支。
		}
	}
	tryReceive := func() string {
		select {
		case v := <-c:
			return v
		default:
			return "-" // 如果c的缓冲为空，则执行默认分支。
		}
	}
	trySend("Hello!") // 发送成功
	trySend("Hi!")    // 发送成功
	trySend("Bye!")   // 发送失败，但不会阻塞。
	// 下面这两行将接收成功。
	fmt.Println(tryReceive()) // Hello!
	fmt.Println(tryReceive()) // Hi!
	// 下面这行将接收失败。
	fmt.Println(tryReceive()) // -
}
```



#### 流程控制的实现机理（没看懂）

`select-case`流程控制是Go中的一个重要和独特的特性，下面列出了官方标准运行时中`select-case`流程控制的实现步骤：

1. 将所有`case`操作中涉及到的通道表达式和发送值表达式按照从上到下，从左到右的顺序一一估值，在赋值语句中做为源值的数据接收操作对应的目标值在此时刻不需要被估值；
2. 将所有分支随机排序，`default`分支总是排在最后，所有`case`操作中相关的通道可能会有重复的；
3. 为了防止在下一步中造成（和其它协程互相）死锁，对所有`case`操作中相关的通道进行排序。排序依据并不重要，官方Go标准编译器使用通道的地址顺序进行排序。排序结果中前`N`个通道不存在重复的情况。`N`为所有`case`操作中涉及到的不重复的通道的数量。下面通道锁顺序是针对此排序结果中的前`N`个通道来说的，通道锁逆序是指此顺序的逆序。
4. 按照上一步中的生成通道锁顺序获取所有相关的通道的锁。
5. 按照第2步中生成的分支顺序检查相应分支：
   1. 如果这是一个`case`分支并且相应的通道操作是一个向关闭了的通道发送数据操作，则按照通道锁逆序解锁所有的通道并在当前协程中产生一个恐慌，结束流程。
   2. 如果这是一个`case`分支并且相应的通道操作是非阻塞的，则按照通道锁逆序解锁所有的通道并执行相应的`case`分支代码块。（此相应的通道操作可能会唤醒另一个处于阻塞状态的协程） 结束流程。
   3. 如果这是`default`分支，则按照通道锁逆序解锁所有的通道并执行此`default`分支代码块，结束流程。（到这里，default分支肯定是不存在的，并且所有的case操作均为阻塞的。）
6. 将当前协程（和对应`case`分支信息）推入到每个`case`操作中对应的通道的发送数据协程队列或接收数据协程队列中。当前协程可能会被多次推入到同一个通道的这两个队列中，因为多个`case`操作中对应的通道可能为同一个。
7. 使当前协程进入阻塞状态并且按照通道锁逆序解锁所有的通道。
8. 当前协程处于阻塞状态，等待其它协程通过通道操作唤醒当前协程
9. 当前协程被另一个协程中的一个通道操作唤醒。此唤醒通道操作可能是一个通道关闭操作，也可能是一个数据发送/接收操作。如果它是一个数据发送/接收操作，则（当前正被解释的`select-case`流程中）肯定有一个相应`case`操作与之配合传递数据。在此配合过程中，当前协程将从相应`case`操作相关的通道的接收/发送数据协程队列中弹出。
10. 按照第*3*步中的生成的通道锁顺序获取所有相关的通道的锁。
11. 将当前协程从各个case操作中对应的通道的发送数据协程队列或接收数据协程队列中（可能以非弹出的方式）移除。
    1. 如果当前协程是被一个通道关闭操作所唤醒，则跳到第*5*步。
    2. 如果当前协程是被一个数据发送/接收操作所唤醒，则相应的`case`分支已经在第*9*步中知晓。按照通道锁逆序解锁所有的通道并执行此`case`分支代码块。



#### 控制代码被执行的几率

可以通过在一个`select`流程控制中使用重复的`case`操作来增加对应分支中的代码的执行几率，在下面这个例子中，函数`f`的调用执行几率大致为函数`g`的两倍：

```go
func TestSelectIncreaseExecuteRate(t *testing.T) {
	foo, bar := make(chan struct{}), make(chan struct{})
	close(foo)
	close(bar) // 仅为演示目的
	x, y := 0.0, 0.0
	f := func() { x++ }
	g := func() { y++ }
	for i := 0; i < 100000; i++ {
		select {
		case <-foo:
			f()
		case <-foo:
			f()
		case <-bar:
			g()
		}
	}
	fmt.Println(x / y) // 大致为2
}
```



#### 从动态数量的分支中选择

每个`select`控制流程中的分支数量在运行中是固定的，但是可以使用`reflect`标准库包中提供的功能在运行时刻来构建动态分支数量的`select`控制流程。但是`select`控制流程中的分支越多，此`select`控制流程的执行效率就越低。



#### 总结

当一个协程被阻塞在一个`select-case`流程控制中并在以后被唤醒时，它可能会从多个通道的发送数据协程队列和接收数据协程队列中被移除。



### for 循环

`for`循环代码块的完整形式如下：

```go
for InitSimpleStatement; Condition; PostSimpleStatement {
	// do something
}
```



`for`是一个关键字，在一个`for`循环代码块中，

- `InitSimpleStatement`（初始化语句）和`PostSimpleStatement`（步尾语句）必须均为简单语句，并且`PostSimpleStatement`不能为一个变量短声明语句；
- `Condition`必须为一个结果为布尔值的表达式（它被称为条件表达式）；
- 所有这三个刚提到的部分都是可选的，在Go中上述三部分不能用小括号括在一起；
- 每个`for`流程控制包括至少两个子代码块，其中一个是隐式的，另一个是显式的（花括号起始和终止的部分，又称循环体），此显式代码块内嵌在隐式代码块之中；



在`for`循环流程控制中，初始化语句（`InitSimpleStatement`）将被率先执行，并且只会被执行一次。在每个循环步的开始，`Condition`条件表达式将被估值，如果估值结果为`false`，则循环立即结束；否则循环体（即显式代码块）将被执行。在每个循环步的结尾，步尾语句（`PostSimpleStatement`）将被执行。

下面是一个使用`for`循环流程控制的例子。此程序将逐行打印出`0`到`9`十个数字。

```go
for i := 0; i < 10; i++ {
	fmt.Println(i)
}
```



在一个`for`循环流程控制中，如果`InitSimpleStatement`和`PostSimpleStatement`两部分同时被省略（可将它们视为空语句），则和它们相邻的两个分号也可被省略。 这样的形式被称为只有条件表达式的`for`循环，只有条件表达式的`for`循环和很多其它语言中的`while`循环类似。

```go
var i = 0
for ; i < 10; {
	fmt.Println(i)
	i++
}
for i < 20 {
	fmt.Println(i)
	i++
}
```



在一个`for`循环流程控制中，如果条件表达式部分被省略，则编译器视其为`true`。

```go
for i := 0; ; i++ { // 等价于：for i := 0; true; i++ {
	if i >= 10 {
		break
	}
	fmt.Println(i)
}

// 下面这几个循环（大多时候）是等价的。
for ; true; {
}
for true {
}
for ; ; {
}
for {
}
```



在一个`for`循环流程控制中，如果初始化语句`InitSimpleStatement`是一个变量短声明语句，则在此语句中声明的循环变量被声明在外层的隐式代码块中。可以在内嵌的循环体（显式代码块）中声明同名变量来遮挡在`InitSimpleStatement`中声明的变量。

```go
for i := 0; i < 3; i++ {
	fmt.Print(i)
	i := i // 这里声明的变量i遮挡了上面声明的i。
	       // 右边的i为上面声明的循环变量i。
	i = 10 // 新声明的i被更改了。
	_ = i
}
```



Go 1.22修改了`for`循环流程控制的语义，在Go 1.22之前，每一个声明的循环变量在整个循环的执行过程中只会被实例化一次，此唯一的实例将被所有循环步共享。从Go 1.22开始，每一个声明的循环变量将会在每个循环步被实例化一次，每个实例只作用于当前循环步。此语义改变有时会造成代码的行为改变，破坏了向后兼容性，为了将此语义改变造成的破坏减至做小，从Go 1.22开始，每个Go源文件都应该被指定一个Go版本号。



一条`break`语句可以用来提前跳出包含此`break`语句的最内层`for`循环。 下面这段代码同样逐行打印出`0`到`9`十个数字。

```go
i := 0
for {
	if i >= 10 {
		break
	}
	fmt.Println(i)
	i++
}
```



一条`continue`语句可以被用来提前结束包含此`continue`语句的最内层`for`循环的当前循环步（步尾语句仍将得到执行）。比如下面这段代码将打印出`13579`。

```go
for i := 0; i < 10; i++ {
	if i % 2 == 0 {
		continue
	}
	fmt.Print(i)
}
```



### for-range 循环

在Go中可以使用如下语法来遍历一个字符串或容器中的键值和元素：

```go
for key, element = range aContainer {
	// 使用key和element ...
}
```



`for`和`range`为两个关键字，`key`和`element`称为循环变量。如果`aContainer`是一个切片、数组或数组指针，则`key`的类型必须为内置类型`int`。等号`=`也可以是一个变量短声明符号`:=`，短声明符号被使用时，`key`和`element`总是两个新声明的变量，这时如果`aContainer`是一个切片、数组或数组指针，则`key`的类型被推断为内置类型`int`。和`for`循环流程控制一样，`break`和`continue`也可以使用在一个`for-range`循环流程控制中的显式代码块中。`for-range`循环代码块有一些变种形式：

```go
for _, element = range aContainer {	// 忽略键值循环变量
	// ...
}

for key, _ = range aContainer {		// 忽略元素循环变量
	element = aContainer[key]
	// ...
}

for key = range aContainer {		// 舍弃元素循环变量。此形式和上一个变种等价
	element = aContainer[key]
	// ...
}

for _, _ = range aContainer {}		// 键值和元素循环变量均被忽略，这个变种形式没有太大实用价值
for range aContainer {}				// 键值和元素循环变量均被舍弃，此形式和上一个变种等价，也没有太大实用价值
```



#### 遍历整数

> 使用`for-range`流程控制代码块来遍历整数是从Go 1.22才开始支持的



```go
// 变量 i 已在前面声明过了
for i = range anInteger {
	...
}
// 等价于
for i = 0; i < anInteger; i++ {
	...
}
```



```go
for i := range anInteger {
	...
}
// 等价于（Go 1.22+语义下的）
for i := 0; i < anInteger; i++ {
	...
}
```



#### 遍历字符串

`for-range`循环控制中的`range`关键字后可以跟随一个字符串，用来遍历此字符串中的码点而非字节元素。字符串中非法的UTF-8编码字节序列将被解读为Unicode替换码点值`0xFFFD`。一个例子：

```go
func main() {
	s := "éक्षिaπ囧"
	for i, rn := range s {
		fmt.Printf("%2v: 0x%x %v \n", i, rn, string(rn))
	}
	fmt.Println(len(s))
}
```

此程序的输出如下：

```
 0: 0x65 e
 1: 0x301 ́
 3: 0x915 क
 6: 0x94d ्
 9: 0x937 ष
12: 0x93f ि
15: 0x61 a
16: 0x3c0 π
18: 0x56e7 囧
21
```

从此输出结果可以看出：

1. 下标循环变量的值并非连续，原因是下标循环变量为字符串中字节的下标，而一个码点可能需要多个字节进行UTF-8编码；
2. 第一个字符`é`由两个码点（共三字节）组成，其中一个码点需要两个字节进行UTF-8编码；
3. 第二个字符`क्षि`由四个码点（共12字节）组成，每个码点需要三个字节进行UTF-8编码；
4. 英语字符`a`由一个码点组成，此码点只需一个字节进行UTF-8编码；
5. 字符`π`由一个码点组成，此码点只需两个字节进行UTF-8编码；
6. 汉字`囧`由一个码点组成，此码点只需三个字节进行UTF-8编码。



使用传统`for`循环遍历一个字符串中的字节：

```go
func main() {
	s := "éक्षिaπ囧"
	for i := 0; i < len(s); i++ {
		fmt.Printf("第%v个字节为0x%x\n", i, s[i])
	}
}
```



也可以利用编译器优化来使用`for-range`循环遍历一个字符串中的字节元素，对于官方标准编译器来说，此方法比刚展示的方法效率更高。

```go
package main

import "fmt"

func main() {
	s := "éक्षिaπ囧"
	for i, b := range []byte(s) { // 这里，[]byte(s)不需要深复制底层字节。
		fmt.Printf("The byte at index %v: 0x%x \n", i, b)
	}
}
```



#### 遍历数组元素

```go
func main() {    
	a := [...]int{2, 3, 5, 7, 11}
    for i, prime := range a {
        fmt.Printf("%v: %v \n", i, prime)
    }
}
```



遍历源数组时，被遍历的数组是复制出来的一个副本，此副本是一个匿名的值，所以它是不可被修改的。遍历过程中对数组元素的修改不会体现到源数组中，原因是被真正遍历的数组和源数组不共享任何元素。

```go
func main() {
	type Person struct {
		name string
		age  int
	}
	persons := [2]Person {{"Alice", 28}, {"Bob", 25}}
	for i, p := range persons {
		fmt.Println(i, p)
		// 此修改将不会体现在这个遍历过程中，因为被遍历的数组是persons的一个副本。
		persons[1].name = "Jack"

		// 此修改不会反映到persons数组中，因为p是persons数组的副本中的一个元素的副本。
		p.age = 31
	}
	fmt.Println("persons:", &persons)
}
```

输出结果：

```
0 {Alice 28}
1 {Bob 25}
persons: &[{Alice 28} {Jack 25}]
```



复制一个大尺寸的数组的代价比较大，所以不建议`for-range`遍历大尺寸数组，可以通过如下方式遍历该数组：

- 从待遍历的大尺寸数组派生出来一个切片；
- 遍历一个指向此数组的指针，复制一个指针比复制一个大尺寸数组的代价低得多；

```go
func main() {
	var a [100]int

	for i, n := range &a { // 复制一个指针的开销很小
		fmt.Println(i, n)
	}

	for i, n := range a[:] { // 复制一个切片的开销很小
		fmt.Println(i, n)
	}
}
```



#### 遍历数组指针元素

如果一个`for-range`循环中的第二个循环变量既没有被忽略，也没有被舍弃，并且`range`关键字后跟随一个nil数组指针，则此循环将造成一个恐慌。在下面这个例子中，前两个循环都将打印出5个下标，但最后一个循环将导致一个恐慌。

> 数组指针不属于容器，但是`range`关键字后可以跟数组指针来遍历数组元素。



```go
func main() {
	var p *[5]int // nil

	for i, _ := range p { // okay
		fmt.Println(i)
	}

	for i := range p { // okay
		fmt.Println(i)
	}

	for i, n := range p { // panic
		fmt.Println(i, n)
	}
}
```



当p为nil数组而不是nil数组指针时，最后一个循环不会导致一个恐慌。



#### 遍历切片元素

```go
s := []string{"go", "defer", "goto", "var"}
for i, keyword := range s {
	fmt.Printf("%v: %v \n", i, keyword)
}
```



遍历nil切片是允许的，这样的遍历可以看作是一个空操作。

```go
var s []string
for i, keyword := range s {
	fmt.Printf("%v: %v \n", i, keyword)
}
```



遍历过程中对切片元素的修改将体现到源切片中，原因是此切片或映射的副本和此切片或映射共享元素或条目。

```go
persons := []Person {{"Alice", 28}, {"Bob", 25}}
for i, p := range persons {
    fmt.Println(i, p)
    // 这次，此修改将反映在此次遍历过程中。
    persons[1].name = "Jack"
    // 这个修改仍然不会体现在persons切片容器中。
    p.age = 31
}
fmt.Println("persons:", &persons)
```

输出结果：

```
0 {Alice 28}
1 {Jack 25}
persons: &[{Alice 28} {Jack 25}]
```



`for-range`循环中不建议使用第二个循环变量存储元素类型的尺寸较大的切片，可以通过如下方式遍历该切片：

- 使用传统`for`循环遍历；
- 忽略第二个循环变量，通过下标获取元素；

```go
type Buffer struct {
	start, end int
	data       [1024]byte
}

func fa(buffers []Buffer) int {
	numUnreads := 0
	for _, buf := range buffers {
		numUnreads += buf.end - buf.start
	}
	return numUnreads
}

func fb(buffers []Buffer) int {
	numUnreads := 0
	for i := range buffers {
		numUnreads += buffers[i].end - buffers[i].start
	}
	return numUnreads
}
```



#### 遍历映射元素

```go
m := map[string]int{"C": 1972, "C++": 1983, "Go": 2009}
for lang, year := range m {
    fmt.Printf("%v: %v \n", lang, year)
}
```



遍历nil映射是允许的，这样的遍历可以看作是一个空操作。

遍历映射条目的细节：

- 映射中的条目的遍历顺序是不确定的，同一个映射中的条目的两次遍历中，条目的顺序很可能是不一致的，即使在这两次遍历之间，此映射并未发生任何改变；
- 如果在一个映射中的条目的遍历过程中，一个还没有被遍历到的条目被删除了，则此条目保证不会被遍历出来；
- 如果在一个映射中的条目的遍历过程中，一个新的条目被添加入此映射，则此条目并不保证将在此遍历过程中被遍历出来；



如果确保没有其它协程操纵一个映射`m`，则下面的代码保证将清空`m`中除了那些键值为`NaN`的所有条目。Go 1.21引入了`clear`内置函数，此函数可以用来清空映射中所有条目，包括那些键值为`NaN`的条目。

```go
for key := range m {
	delete(m, key)
}
```



遍历映射时，键值元素会被复制给循环变量，所以对循环变量的直接部分的修改将不会体现在映射中的对应元素中。因为遍历映射时存在复制流程，所以最好不要使用大尺寸的映射键值和元素类型，以避免较大的复制负担。

```go
func main() {
    m := map[int]struct{ dynamic, strong bool } {
        0: {true, false},
        1: {false, true},
        2: {false, false},
    }

    for _, v := range m {
        // This following line has no effects on the map m.
        v.dynamic, v.strong = true, true
    }

    fmt.Println(m[0]) // {true false}
    fmt.Println(m[1]) // {false true}
    fmt.Println(m[2]) // {false false}
}
```



#### 遍历通道

`for-range`循环控制流程也适用于通道。此循环将不断地尝试从一个通道接收数据，直到此通道关闭并且它的缓冲队列为空为止。和应用于数组、切片、映射的`for-range`语法不同，应用于通道的`for-range`语法中最多只能出现一个循环变量，此循环变量用来存储接收到的值。

```go
for v := range ch { // ch一定不能为一个单向发送通道。如果它是一个nil零值，则此for-range循环将使当前协程永久阻塞。
	// 使用v
}
// 等价于
for {
	v, ok = <-ch
	if !ok {
		break
	}
	// 使用v
}
// 等价于
for v, ok := <-c; ok; v, ok = <-c { // 初始化和步尾语句
    // 使用v
}
```



另一个示例如下：

```go
func main() {
	fibonacci := func() chan uint64 {
		c := make(chan uint64)
		go func() {
			var x, y uint64 = 0, 1
			for ; y < 8; c <- y { // 步尾语句
				x, y = y, x+y
			}
			close(c)
		}()
		return c
	}
	c := fibonacci()
	for x := range c {
		time.Sleep(time.Second)
		fmt.Println(x) // 依次输出 1 2 3 5 8
	}
}
```



#### 版本差异

在Go 1.22之前，对一个如下`for-range`循环代码块（注意`range`前面是`:=`）

```go
for key, element := range aContainer {...}
```

所有被遍历的键值元素对将被赋值给**同一对**循环变量实例。 但是从Go 1.22版本开始，每组键值元素对将被赋值给一对**与众不同**的循环变量实例（既循环变量在每个循环步都会生成一份新的实例）。



下面这个例子展示了Go 1.21-和Go 1.22+之间的行为差异。

```go
// forrange1.go
package main

import "fmt"

func main() {
	for i, n := range []int{0, 1, 2} {
		defer func() {
			fmt.Println(i, n)
		}()
	}
}
```

使用不同版本的Go编译器运行之（[gotv](https://gfw.go101.org/apps-and-libs/gotv.html)是一个管理运行多个Go官方工具链版本的工具；未来的Go 1.22版本将来从tip版本开出来），将得到不同的输出：

```go
$ gotv 1.21. run forrange1.go
[Run]: $HOME/.cache/gotv/tag_go1.21.8/bin/go run forrange1.go
2 2
2 2
2 2
$ gotv 1.22. run forrange1.go
[Run]: $HOME/.cache/gotv/tag_go1.22.1/bin/go run forrange1.go
2 2
1 1
0 0
```



另一个例子：

```go
// forrange2.go
package main

import "fmt"

func main() {
	var m = map[*int]uint32{}
	for i, n := range []int{1, 2, 3} {
		m[&i]++
		m[&n]++
	}
	fmt.Println(len(m))
}
```

使用不同版本的Go编译器运行之，得到如下输出：

```go
$ gotv 1.21. run forrange2.go
[Run]: $HOME/.cache/gotv/tag_go1.21.8/bin/go run forrange2.go
2
$ gotv 1.22. run forrange2.go
[Run]: $HOME/.cache/gotv/tag_go1.22.1/bin/go run forrange2.go
6
```

因此，这是一个破坏了向后兼容性的语义改变。 但是新的语义更符合人们的直觉；并且从理论上，到目前还没有发现在逻辑上正确的旧代码因为此改变而导致行为变化的情况。



#### 和for 循环并不总是一致

对于切片`s`，循环`for i = range s {...}`并不等价于循环`for i = 0; i < len(s); i++ {...}`。

```go
func fa(s []int, n int) int {
	i := n
	for i = 0; i < len(s); i++ {
	}
	return i
}

func fb(s []int, n int) int {
	i := n
	for i = range s {
	}
	return i
}

func TestCompareForRangeAndForWhenLoopSlice(t *testing.T) {
	s := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(fa(s, -1), fb(s, -1)) // 6 5
	s = nil
	fmt.Println(fa(s, -1), fb(s, -1)) // 0 -1
}
```



## 跳转语句

### break 和 continue跳转

`goto`语句必须包含跳转标签名，`break`或`continue`语句也可以包含跳转标签名，但此跳转标签名是可选的。包含跳转标签名的`break`语句一般用于跳出外层的嵌套可跳出流程控制代码块，包含跳转标签名的`continue`语句一般用于提前结束外层的嵌套循环流程控制代码块的当前循环步。

如果`break`语句中包含跳转标签名，则此跳转标签必须刚好声明在包含此`break`语句的可跳出流程控制代码块之前，可以把此跳转标签名看作是其后紧跟随的可跳出流程控制代码块的名称，此`break`语句将立即结束此可跳出流程控制代码块的执行。

如果`continue`语句中包含跳转标签名，则此跳转标签必须刚好声明在包含此`continue`语句的循环流程控制代码块之前，可以把此跳转标签名看作是其后紧跟随的循环流程控制代码块的名称，此`continue`语句将提前结束此循环流程控制代码块的当前步的执行。

下面是一个使用了包含跳转标签名的`break`和`continue`语句的例子。

```go
package main

import "fmt"

func FindSmallestPrimeLargerThan(n int) int {
Outer:
	for n++; ; n++{
		for i := 2; ; i++ {
			switch {
			case i * i > n:
				break Outer
			case n % i == 0:
				continue Outer
			}
		}
	}
	return n
}

func main() {
	for i := 90; i < 100; i++ {
		n := FindSmallestPrimeLargerThan(i)
		fmt.Print("最小的比", i, "大的素数为", n, "\n")
	}
}
```



### goto 跳转

在`goto`跳转语句中，`goto`关键字后必须跟随表明跳转到何处的跳转标签。使用`LabelName:`这样的形式来声明一个名为`LabelName`的跳转标签，其中`LabelName`必须为一个标识符。一个不为空标识符的跳转标签声明后必须被使用至少一次。

跳转标签声明之后必须立即跟随一条语句，如果此声明的跳转标签使用在`goto`语句中，则当此条`goto`语句被执行的时候，执行将跳转到此跳转标签声明后跟随的语句。跳转标签必须声明在函数体内，此跳转标签的使用可以在此跳转标签的声明之后或者之前，但是此跳转标签的使用不能出现在此跳转标签声明所处的最内层代码块之外。下面这个例子使用跳转标签声明和`goto`跳转语句来实现了一个循环：

```go
package main

import "fmt"

func main() {
	i := 0

Next: // 跳转标签声明
	fmt.Println(i)
	i++
	if i < 5 {
		goto Next // 跳转
	}
}
```



上面刚提到了一个跳转标签的使用不能出现在此跳转标签声明所处的最内层代码块之外，所以下面的代码片段中的跳转标签使用都是不合法的。

```go
package main

func main() {
goto Label1 // error
	{
		Label1:
		goto Label2 // error
	}
	{
		Label2:
	}
}
```



如果跳转标签声明在某个变量的作用域内，则此跳转标签的使用不能出现在此变量的声明之前。

```go
package main

import "fmt"

func main() {
	i := 0
Next:
	if i >= 5 {
		// error: goto Exit jumps over declaration of k
		goto Exit
	}

	k := i + i
	fmt.Println(k)
	i++
	goto Next
Exit: // 此标签声明在k的作用域内，但它的使用在k的作用域之外。
}
```



刚提到的这条规则可能会在今后放宽，目前，有两种途径可以对上面的程序略加修改以使之编译通过。第一种途径是缩小变量`k`的作用域：

```go
func main() {
	i := 0
Next:
	if i >= 5 {
		goto Exit
	}
	// 创建一个显式代码块以缩小k的作用域。
	{
		k := i + i
		fmt.Println(k)
	}
	i++
	goto Next
Exit:
}
```



第二种途径是放大变量`k`的作用域：

```go
func main() {
	var k int // 将变量k的声明移到此处。
	i := 0
Next:
	if i >= 5 {
		goto Exit
	}

	k = i + i
	fmt.Println(k)
	i++
	goto Next
Exit:
}
```



# Go 关键字 条件语句相关

## 条件语句

条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。

Go 没有三目运算符，所以不支持 **?:** 形式的条件判断。

| 语句           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| if 语句        | **if 语句** 由一个布尔表达式后紧跟一个或多个语句组成。       |
| if...else 语句 | **if 语句** 后可以使用可选的 **else 语句**, else 语句中的表达式在布尔表达式为 false 时执行。 |
| if 嵌套语句    | 你可以在 **if** 或 **else if** 语句中嵌入一个或多个 **if** 或 **else if** 语句。 |
| switch 语句    | **switch** 语句用于基于不同条件执行不同动作。                |
| select 语句    | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 |



#### if 语句

if 语句由布尔表达式后紧跟一个或多个语句组成。

```
if statement 可选语句; 布尔表达式 {
   /* 在布尔表达式为 true 时执行 */
}
```

- 不需使用括号将条件包含起来
- 大括号{}必须存在，即使只有一行语句
- 左括号必须在if或else的同一行
- 在if之后，条件语句之前，可以添加变量初始化语句，使用；进行分隔
- 在有返回值的函数中，最终的return不能在条件语句中



```go
package main
import "fmt"
func main() {
   /* 定义局部变量 */
   var a int = 10
 
   /* 使用 if 语句判断布尔表达式 */
   if a < 20 {
       /* 如果条件为 true 则执行以下语句 */
       fmt.Printf("a 小于 20\n" ) // 输出
   }
   fmt.Printf("a 的值为 : %d\n", a) // 结果：a 的值为 : 10
}
```



Go 的 if 条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示:

```go
package main
  
import "fmt"
func main() {
    if num := 9; num < 0 {
        fmt.Println(num, "is negative")
    } else if num < 10 {
        fmt.Println(num, "has 1 digit") // 结果：9 has 1 digit
    } else {
        fmt.Println(num, "has multiple digits")
    }
}
```



#### if...else 语句

if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。

```
if statement 可选语句; 布尔表达式 {
   /* 在布尔表达式为 true 时执行 */
} else {
  /* 在布尔表达式为 false 时执行 */
}
```



存在多个布尔表达式时可以使用**if ... else if ... else...** 来执行条件语句：

```go
package main
import "fmt"
func main() {
    var age int = 23
    if age == 25 {
        fmt.Println("true")
    } else if age < 25 {
        fmt.Println("too small") // 输出
    } else {
        fmt.Println("too big")
    }
}
```



#### if 嵌套语句

可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。

```
if 布尔表达式 1 {
   /* 在布尔表达式 1 为 true 时执行 */
   if 布尔表达式 2 {
      /* 在布尔表达式 2 为 true 时执行 */
   }
}
```



#### switch 语句

switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。

switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 **fallthrough** 。

```
switch var1 {
    case val1:
        ...
    case val2:
        ...
    case val3, val4, val5 
    default:
        ...
}
```

变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var grade string = "B"
   var marks int = 90

   switch marks {
      case 90: grade = "A"
      case 80: grade = "B"
      case 50,60,70 : grade = "C" // 支持多条件匹配
      default: grade = "D"  
   }

   switch {
      case grade == "A" :
         fmt.Printf("优秀!\n" ) // 输出
      case grade == "B", grade == "C" :
         fmt.Printf("良好\n" )      
      case grade == "D" :
         fmt.Printf("及格\n" )      
      case grade == "F":
         fmt.Printf("不及格\n" )
      default:
         fmt.Printf("差\n" );
   }
   fmt.Printf("你的等级是 %s\n", grade ); // 结果：你的等级是 A
}
```



##### Type Switch

switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。

```go
switch x.(type){
    case type:
       statement(s);      
    case type:
       statement(s); 
    /* 你可以定义任意个数的case */
    default: /* 可选 */
       statement(s);
}
```



```go
package main

import "fmt"

func main() {
   var x interface{}
     
   switch i := x.(type) {
      case nil:   
         fmt.Printf(" x 的类型 :%T",i) // 结果：x 的类型 :<nil>    
      case int:   
         fmt.Printf("x 是 int 型")                       
      case float64:
         fmt.Printf("x 是 float64 型")           
      case func(int) float64:
         fmt.Printf("x 是 func(int) 型")                      
      case bool, string:
         fmt.Printf("x 是 bool 或 string 型" )       
      default:
         fmt.Printf("未知型")     
   }   
}
```



##### fallthrough

使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。

```go
package main
import "fmt"
func main() {
    switch {
      case false:
              fmt.Println("1、case 条件语句为 false")
              fallthrough
      case true:
              fmt.Println("2、case 条件语句为 true")	// 输出，存在fallthrough，执行后面的case
              fallthrough
      case false:
              fmt.Println("3、case 条件语句为 false") // 输出，存在fallthrough，执行后面的case
              fallthrough
      case true:
              fmt.Println("4、case 条件语句为 true")  // 输出，此时无fallthrough，不再执行后面的case
      case false:
              fmt.Println("5、case 条件语句为 false")
              fallthrough
      default:
              fmt.Println("6、默认 case")
    }
}
```



##### break

不同的 case 之间不使用 break 分隔，默认只会执行一个 case。如果想要执行多个 case，需要使用 fallthrough 关键字，也可用 break 终止。

```go
switch {
    case 1：
      if(...){
          break
      }
    	fallthrough // 此时switch(1)会执行case1和case2，但是如果满足if条件，则只执行case1
    case 2:
    case 3:
}
```



##### default

switch 的 default 不论放在哪都是最后执行，下列两种方式执行结果一致：

```go
a := 10
switch {
   default : {
      fmt.Println("default")
   }
   case a > 0 : {
      fmt.Println("a > 0")
   }
   case a > 5 : {
      fmt.Println("a > 5")
   }
}
```



```go
a := 10
switch {
   case a > 0 : {
      fmt.Println("a > 0")
   }
   case a > 5 : {
      fmt.Println("a > 5")
   }
   default : {
      fmt.Println("default")
   }
}
```



#### select 语句

select 是 Go 中的一个控制结构，类似于 switch 语句。select 语句只能用于通道操作，每个 case 必须是一个通道操作，要么是发送要么是接收。select 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码。

```go
select {
  case <- channel1:
    // 执行的代码
  case value := <- channel2:
    // 执行的代码
  case channel3 <- value:
    // 执行的代码

    // 你可以定义任意数量的 case

  default:
    // 所有通道都没有准备好，执行的代码
}
```



以下描述了 select 语句的语法：

- 每个 case 都必须是一个通道

- 所有 channel 表达式都会被求值

- 所有被发送的表达式都会被求值

- 如果任意某个通道可以进行，它就执行，其他被忽略。

- 如果有多个 case 都可以运行，select 会随机公平地选出一个执行，其他不会执行。否则：

  1. 如果有 default 子句，则执行该语句。
  2. 如果没有 default 子句，select 将阻塞，直到某个通道可以运行；Go 不会重新对 channel 或值进行求值。

  

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 <- "two"
    }()

    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("received", msg1)
        case msg2 := <-c2:
            fmt.Println("received", msg2)
        }
    }
}
```



执行结果：

```
received one
received two
```



以上实例中创建了两个通道 c1 和 c2。select 语句等待两个通道的数据。如果接收到 c1 的数据，就会打印 "received one"；如果接收到 c2 的数据，就会打印 "received two"。

```go
package main

import "fmt"

func main() {
  // 定义两个通道
  ch1 := make(chan string)
  ch2 := make(chan string)

  // 启动两个 goroutine，分别从两个通道中获取数据
  go func() {
    for {
      ch1 <- "from 1"
    }
  }()
  go func() {
    for {
      ch2 <- "from 2"
    }
  }()

  // 使用 select 语句非阻塞地从两个通道中获取数据
  for {
    select {
    case msg1 := <-ch1:
      fmt.Println(msg1)
    case msg2 := <-ch2:
      fmt.Println(msg2)
    default:
      // 如果两个通道都没有可用的数据，则执行这里的语句
      fmt.Println("no message received")
    }
  }
}
```



以下实例中定义了两个通道，并启动了两个协程（Goroutine）从这两个通道中获取数据。在 main 函数中，使用 select 语句在这两个通道中进行非阻塞的选择，如果两个通道都没有可用的数据，就执行 default 子句中的语句。以下实例执行后会不断地从两个通道中获取到的数据，当两个通道都没有可用的数据时，会输出 "no message received"。

```go
package main

import "fmt"

func main() {
  // 定义两个通道
  ch1 := make(chan string)
  ch2 := make(chan string)

  // 启动两个 goroutine，分别从两个通道中获取数据
  go func() {
    for {
      ch1 <- "from 1"
    }
  }()
  go func() {
    for {
      ch2 <- "from 2"
    }
  }()

  // 使用 select 语句非阻塞地从两个通道中获取数据
  for {
    select {
      case msg1 := <-ch1:
        fmt.Println(msg1)
      case msg2 := <-ch2:
        fmt.Println(msg2)
      default:
        // 如果两个通道都没有可用的数据，则执行这里的语句
        fmt.Println("no message received")
    }
  }
}
```



# Go 关键字 循环语句相关



Go 语言提供了以下几种类型循环处理语句：

| 循环类型 | 描述                                 |
| :------- | :----------------------------------- |
| for 循环 | 重复执行语句块                       |
| 循环嵌套 | 在 for 循环中嵌套一个或多个 for 循环 |



循环控制语句可以控制循环体内语句的执行过程。

GO 语言支持以下几种循环控制语句：

| 控制语句      | 描述                                             |
| :------------ | :----------------------------------------------- |
| break 语句    | 经常用于中断当前 for 循环或跳出 switch 语句      |
| continue 语句 | 跳过当前循环的剩余语句，然后继续进行下一轮循环。 |
| goto 语句     | 将控制转移到被标记的语句。                       |



## for循环

### 一般格式

for 循环是一个循环控制结构，可以执行指定次数的循环。Go 语言的 For 循环有 3 种形式，只有其中的一种使用分号。

```go
for init; condition; post { }
for ; condition; { } // 条件循环
for condition { } // 条件循环
for { }	// 无限循环
```



- init： 一般为赋值表达式，给控制变量赋初值；
- condition： 关系表达式或逻辑表达式，循环控制条件；
- post： 一般为赋值表达式，给控制变量增量或减量。

for语句执行过程如下：

- 1、先对表达式 1 赋初值；
- 2、判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。



```go
package main
import "fmt"
func main() {
  sum := 0
	for i := 0; i <= 10; i++ {
     sum += i
  }
  fmt.Println(sum)
}
```



```go
package main
import "fmt"
func main() {
   sum := 1
   for ; sum <= 10; {
      sum += sum
   }
   fmt.Println(sum)

   // 这样写也可以，更像 While 语句形式
   for sum <= 10{
      sum += sum
   }
   fmt.Println(sum)
}
```



### For-each Range格式

for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：

```go
for key, value := range oldMap {
    newMap[key] = value
}
```



以上代码中的 key 和 value 是可以省略。如果只想读取 key，格式如下：

```go
for key := range oldMap // 方式一
for key, _ := range oldMap // 方式二
```



如果只想读取 value，格式如下：

```go
for _, value := range oldMap
```



## 循环控制语句

### break语句

在 Go 语言中，break 语句用于终止当前循环或者 switch 语句的执行，并跳出该循环或者 switch 语句的代码块。

break 语句可以用于以下几个方面：。

- 用于循环语句中跳出循环，并开始执行循环之后的语句。
- break 在 switch 语句中在执行一条 case 后跳出语句的作用。
- break 可应用在 select 语句中。
- 在多重循环中，可以用标号 label 标出想 break 的循环。



- 在 for 循环中使用 break：

```go
package main

import "fmt"

func main() {
    for i := 0; i < 10; i++ {
        if i == 5 {
            break // 当 i 等于 5 时跳出循环
        }
        fmt.Println(i)
    }
}
```

```
0
1
2
3
4
```



- 在变量 a 大于 15 的时候跳出循环：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 10

   /* for 循环 */
   for a < 20 {
      fmt.Printf("a 的值为 : %d\n", a);
      a++
      if a > 15 {
         /* a 大于 15 时使用 break 语句跳出循环 */
         break
      }
   }
}
```

```
a 的值为 : 10
a 的值为 : 11
a 的值为 : 12
a 的值为 : 13
a 的值为 : 14
a 的值为 : 15
```



- 多重循环，使用标记和不使用标记的区别：

```go
package main

import "fmt"

func main() {

   // 不使用标记
   fmt.Println("---- break ----")
   for i := 1; i <= 3; i++ {
      fmt.Printf("i: %d\n", i)
      for i2 := 11; i2 <= 13; i2++ {
         fmt.Printf("i2: %d\n", i2)
         break
      }
   }

   // 使用标记
   fmt.Println("---- break label ----")
   re:
      for i := 1; i <= 3; i++ {
         fmt.Printf("i: %d\n", i)
         for i2 := 11; i2 <= 13; i2++ {
         fmt.Printf("i2: %d\n", i2)
         break re
      }
   }
}
```

```
---- break ----
i: 1
i2: 11
i: 2
i2: 11
i: 3
i2: 11
---- break label ----
i: 1
i2: 11    
```



#### select 语句中的应用

在 Go 语言中，break 语句在 select 语句中的应用是相对特殊的。由于 select 语句的特性，break 语句并不能直接用于跳出 select 语句本身，因为 select 语句是非阻塞的，它会一直等待所有的通信操作都准备就绪。如果需要提前结束 select 语句的执行，可以使用 return 或者 goto 语句来达到相同的效果。



### continue语句

Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。for 循环中，执行 continue 语句会触发 for 增量语句的执行。在嵌套循环中，可以用标号 label 标出想 continue 的循环。



- 在变量 a 等于 15 的时候跳过本次循环执行下一次循环：

```go
package main

import "fmt"

func main() {
   var a int = 10
   for a < 20 {
      if a == 15 {
         a = a + 1;
         continue;
      }
      fmt.Printf("a 的值为 : %d\n", a);
      a++;     
   }  
}
```



- 跳到指定嵌套循环标记

```go
package main

import "fmt"

func main() {
    // 不使用标记
    fmt.Println("---- continue ---- ")
    for i := 1; i <= 3; i++ {
        fmt.Printf("i: %d\n", i)
            for i2 := 11; i2 <= 13; i2++ {
                fmt.Printf("i2: %d\n", i2)
                continue
            }
    }

    // 使用标记
    fmt.Println("---- continue label ----")
    re:
        for i := 1; i <= 3; i++ {
            fmt.Printf("i: %d\n", i)
                for i2 := 11; i2 <= 13; i2++ {
                    fmt.Printf("i2: %d\n", i2)
                    continue re
                }
        }
}
```

```
---- continue ---- 
i: 1
i2: 11
i2: 12
i2: 13
i: 2
i2: 11
i2: 12
i2: 13
i: 3
i2: 11
i2: 12
i2: 13
---- continue label ----
i: 1
i2: 11
i: 2
i2: 11
i: 3
i2: 11
```



### goto语句

Go 语言的 goto 语句可以无条件地转移到过程中指定的行。goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。

**但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。**



- 在变量 a 等于 15 的时候跳过本次循环并回到循环的开始语句 LOOP 处：

```go
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 10

   /* 循环 */
   LOOP: for a < 20 {
      if a == 15 {
         /* 跳过迭代 */
         a = a + 1
         goto LOOP
      }
      fmt.Printf("a的值为 : %d\n", a)
      a++     
   }  
}
```

```
a的值为 : 10
a的值为 : 11
a的值为 : 12
a的值为 : 13
a的值为 : 14
a的值为 : 16
a的值为 : 17
a的值为 : 18
a的值为 : 19
```



### 范围Range

Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。

for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：

```
for key, value := range oldMap { }
for key := range oldMap { }
for _, value := range oldMap { }
```



range遍历的内容是对原内容的一个拷贝，获取到的value和迭代目标中的元素地址不同，值相同所以不能用来修改原切片中内容。

如下所示，range遍历的value地址都是0x140000aa240，和源值地址不同。

```go
func TestRangeWithPointer(t *testing.T) {
	nums := [3]int{5, 6, 7}
	for k, v := range nums {
		fmt.Println("源值：", nums[k], " value：", v)
		fmt.Println("源值地址：", &nums[k], " value地址：", &v)
	}
}
```

```
源值： 5  value： 5
源值地址： 0xc000028618  value地址： 0xc0002705d0
源值： 6  value： 6
源值地址： 0xc000028620  value地址： 0xc0002705d0
源值： 7  value： 7
源值地址： 0xc000028628  value地址： 0xc0002705d0
```



因此如果要通过range遍历将value的值赋值给其他变量，需要通过声明一个中间变量，保存value，并将中间变量赋值给目标变量。

```go
func TestAssignByRange(t *testing.T) {
	s := []int{1, 2, 3, 4}
	m := make(map[int]*int)

	for k, v := range s {
		// 声明中间变量n，再将n赋值给目标变量
		n := v
		m[k] = &n
	}
	for key, value := range m {
		fmt.Printf("map[%v]=%v, 内存地址: %v\n", key, *value, value)
	}
}
```

```
map[0]=1, 内存地址: 0xc00032c560
map[1]=2, 内存地址: 0xc00032c568
map[2]=3, 内存地址: 0xc00032c570
map[3]=4, 内存地址: 0xc00032c578
```

