---
layout: post
title: 第021章-MySQL MVCC
categories: [MySQL]
description: 
keywords: MySQL MVCC.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# MySQL_MVCC
MVCC（Multiversion concurrency control）就是同一份数据保留多版本的一种方式，进而实现并发控制。MVCC是在存储引擎层进行实现的，不同存储引擎对MVCC有不同的实现标准。在查询的时候，通过read view和版本链找到对应版本的数据。

作用：提升并发性能。对于高并发场景，MVCC比行级锁开销更小。

通过一定机制生成一个数据请求**时间点的一致性数据快照（Snapshot)**，并用这个快照来提供一定级别（**语句级或事务级**）的**一致性读取**。从用户的角度来看，好像是**数据库可以提供同一数据的多个版本**。

- MVCC是被Mysql中 `事务型存储引擎InnoDB` 所支持的;
- **应对高并发事务, MVCC比`单纯的加锁`更高效**;
- MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作;
- MVCC可以使用 `乐观(optimistic)锁` 和 `悲观(pessimistic)锁`来实现;
- 各数据库中MVCC实现并不统一
- InnoDB存储引擎在数据库每行数据的后面添加了**三个字段**



1、全称`Multi-Version Concurrency Control`，即`多版本并发控制`。MVCC是一种并发控制的`理念`，维持一个数据的多个版本，使得读写操作没有冲突。

2、MVCC在MySQL InnoDB中实现目的主要是为了**提高数据库并发性能**，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。



MVCC 机制是基于ReadView 机制和 undo log 版本链形成的。主要用来解决多事务间的脏读、不可重复读、幻读等问题，使用无锁机制提高数据库的并发性能。

SQL 标准事务隔离机制有四个级别：RU、RC、RR、S 级。MVCC 在 RC、RR 级别中使用。



## 基础概念

### Undo Log快照

每一次记录变更之前都会先存储一份快照到`Und oLog`中，那么这几个隐式字段也会跟着记录一起保存在`Und oLog`中，每一个快照中都有有一个`DB_TRX_ID`字段记录了本次变更的事务ID，以及一个`DB_ROLL_PTR`字段指向了上一个快照的地址。

![图片](https://oss.xubighead.top/oss/image/202506/1930156834229948417.png)

### 聚簇索引隐藏列

InnoDB存储引擎在数据库每行数据的后面添加了三个字段：



- DB_TRX_ID：`DB_TRX_ID`（6字节）表示最后一次增删改该条记录的事务ID。
- DB_ROLL_PTR：DB_ROLL_PTR（7字节）回滚指针表示指向该条记录在`Undo Log`中的上一个版本地址。
- DB_ROW_ID：数据表没有主键和唯一索引，`InnoDB`会自动为每条记录添加`DB_ROW_ID`（6字节）来产生一个聚簇索引。
- FLAG：一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了。



### 当前读和快照读

1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 "行排他锁+MVCC" 一起实现的, 不仅可以保证可重复读, 还可以**部分**防止幻读, 而非完全防止;

2.为什么是部分防止幻读, 而不是完全防止?

- 效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!
- 因为在innodb中的操作可以分为`当前读(current read)`和`快照读(snapshot read)`:

3.快照读(snapshot read)

```lasso
简单的select操作(不包括 select ... lock in share mode, select ... for update)
```

4.当前读(current read)

- select ... lock in share mode
- select ... for update
- insert
- update
- delete

在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。
innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!



#### 当前读

1、像`select lock in share mode`(共享锁)、`select for updat`e 、`update`、`insert`、`delete`(排他锁)这些操作都是一种`当前读`，就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对`读取的记录进行加锁`。

2、当前读可以认为是`悲观锁`的具体功能实现

读取的是数据最新版本，对当前读取的数据加锁，阻塞其它事务对数据行的修改，比如增删改操作，或者`select * from table for update | insert | delete`。



#### 快照读

读取的是数据历史版本，通过 mvcc 机制读取数据的历史版本，比如普通的 Select 操作。

1、不加锁的select就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即`MVCC`，可以认为`MVCC是行锁的一个变种`，但它在很多情况下，`避免了加锁操作`，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。

2、快照读就是MVCC思想在MySQL的具体非阻塞读功能实现，MVCC的目的就是为了实现读-写冲突不加锁，提高并发读写性能，而这个读指的就是`快照读`。

3、快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。



## Read View

ReadView 机制是基于 undo log 版本链实现的。ReadView 保存当前系统内尚未提交的事务ID，需要说明的是，事务 ID 是 MySQL 按照时间顺序生成的一个版本号。当前读或者隔离级别为读已提交时，事务期间每次查询都会重新生成一个 ReadView；而快照读或隔离级别为可重复读只会在事务开启时生成一次 ReadView，后续事务操作都不会修改这个 ReadView。



Read View 主要是用来做可见性判断的，**因为Read View生成时机的不同, 造成了RC，RR两种隔离级别的不同可见性**。

- RR级别时, 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照Read View, 将当前系统中活跃的其他事务记录记录起来;
- RC级别时，事务中每条select语句都会创建一个Read View



> With REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed.
>
> With READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.



![img](https://oss.xubighead.top/oss/image/202506/1930156937397243906.png)



Read View 有四个重要的字段：

- m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- max_trx_id ：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；
- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**。



通过 ReadView 生成机制可以知道，ReadView 中保存着当前事务开启时，系统内所有未提交事务的ID快照。所有小于 min_trx_id 的事务 ID 都是已经提交的，这个需要明确；所以当前读或 RC 级别下，每次查询都能感知到哪些事务是已经提交的，哪些事务是本事务开启时仍然未提交的，哪些事务是本事务开启后再开启的。通过时间轴可以更加清晰的了解 ReadView 对事务状态的划分：

![图片](https://oss.xubighead.top/oss/image/202506/1930157026555564033.jpg)



m_ids 列表中有一个必然是本事务 ID creator_trx_id；而列表中第一个则是 min_trx_id；列表最后一个的下一个就是系统即将生成的事务 ID max_trx_id；



### 判断机制规则

```java
if (trx_id <= min_trx_id) {
    // 说明修改这行数据的事务已经提交，或者说就是本事务修改的，那么该版本可读。
} else if ( min_trx_id < trx_id && trx_id < max_trx_id) {
    // 这时需要判断修改这行数据的事务 ID trx_id 是否在 m_ids 列表中
    if (m_ids.contains(trx_id)) {
        // 说明生成 ReadView 时，该事务还未提交，那么该版本不可读
        // 根据 undo log 版本链读取最近的历史版本
        // 如果没有合适的历史版本，那么这行数据就是不可读的
    } else {
        // 说明生成 ReadView 时，该事务已提交，那么该版本可读。
    }
} else {
    // 说明修改这行数据的事务，在生成 ReadView 后才开启的，那么该版本不可读
    // 根据 undo log 版本链读取最近的合适的历史版本，
    // 如果没有合适的历史版本，那么这行数据就是不可读的
}
```

这个机制就是事务在读取时，会判断这行数据的 trx_id 和事务本身 ReadView 中的 min_trx_id 的大小关系，以及 trx_id 是否在 m_ids 列表中，来决定这行数据是否可读，以及用什么方式来读。ReadView 机制和 undo log 版本链形成了 MySQL 的 MVCC（Multi-Version Concurrent Control）机制（多版本并发控制机制）。



##  原理

在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：

<img src="https://oss.xubighead.top/oss/image/202506/1930157091034599426.png" alt="img" style="zoom:50%;" />

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：
    - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
    - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**



### 可重复读实现

**可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**。

假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：

<img src="https://oss.xubighead.top/oss/image/202506/1930157164200038401.png" alt="img" style="zoom:50%;" />

事务 A 和 事务 B 的 Read View 具体内容如下：

- 在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。
- 在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，**活跃的事务 id 中最小的事务 id 是事务 A**，下一个事务 id 应该是 53。

接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：

- 事务 B 读取小林的账户余额记录，读到余额是 100 万；
- 事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；
- 事务 B 读取小林的账户余额记录，读到余额还是 100 万；
- 事务 A 提交事务；
- 事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；

接下来，跟大家具体分析下。

事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时**发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的**，也就是事务 B 可以获取到这条记录。

接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成**版本链**，如下图：

<img src="https://oss.xubighead.top/oss/image/202506/1930157226019885057.png" alt="img" style="zoom:50%;" />

你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id = 51）。

然后事务 B 第二次去读取该记录，**发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录**，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。

最后，当事物 A 提交事务后，**由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录**。

就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。



### 读已提交实现

**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**。

也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。

那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。

假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：

- 事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；
- 事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；
- 事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；
- 事务 A 提交事务；
- 事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；

那具体怎么做到的呢？我们重点看事务 B 每次读取数据时创建的 Read View。前两次 事务 B 读取数据时创建的 Read View 如下图：

<img src="https://oss.xubighead.top/oss/image/202506/1930157299629920258.png" alt="img" style="zoom:50%;" />

我们来分析下为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？

事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明**这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录**。而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。

我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？

在事务 A 提交后，**由于隔离级别是「读提交」，所以事务 B 在每次读数据的时候，会重新创建 Read View**，此时事务 B 第三次读取数据时创建的 Read View 如下：

![img](https://oss.xubighead.top/oss/image/202506/1930157336963420161.png)

事务 B 在找到小林这条记录时，**会发现这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了，所以该版本的记录对事务 B 是可见的**。

正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。



### 幻读解决原理

在可重复读隔离级别下，**普通的查询是快照读，是不会看到别的事务插入的数据的**。

可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 Read View，然后后续的查询语句利用这个 Read View，通过 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以每次查询的数据都是一样的。

MySQL 里除了普通查询是快照读，其他都是**当前读**，比如update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。另外，`select ... for update` 这种查询语句是当前读，每次执行的时候都是读取最新的数据。

**要讨论「可重复读」隔离级别的幻读现象，是要建立在「当前读」的情况下。**



假设`select ... for update`当前读是不会加锁的（实际上是会加锁的）：

![img](https://oss.xubighead.top/oss/image/202506/1930157364691963905.png)



这时候，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读。

所以，**Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了 next-key 锁**，就是记录锁和间隙锁的组合。

- 记录锁，锁的是记录本身；
- 间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。

比如，执行这条语句的时候，会锁住，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。

![img](https://oss.xubighead.top/oss/image/202506/1930157387798384642.png)



next-key 锁的加锁规则其实挺复杂的，在一些场景下会退化成记录锁或间隙锁。

需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行数据加上了行锁，还给行两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。

所以，在线上千万不要执行没有带索引的 update 语句，不然会造成业务停滞。



### 可见性比较算法

在可重复度隔离级别下，设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 `trx_id_current`，当前新开事务id为 `new_id`，当前新开事务创建的快照`read view` 中最早的事务id为`up_limit_id`, 最迟的事务id为`low_limit_id`(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)。

比较:

- 1.`trx_id_current < up_limit_id`, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.
- 2.`trx_id_current >= trx_id_last`, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。
- 3.`trx_id_current <= trx_id_current <= trx_id_last`, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。
- 4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 `trx_id_current`，然后跳到步骤1重新开始判断。
- 5.将该可见行的值返回。



MVCC 实现原理如下：

MVCC 的实现依赖于版本链，版本链是通过表的三个隐藏字段实现。

DB_TRX_ID：当前事务id，通过事务id的大小判断事务的时间顺序。
DB_ROLL_PRT：回滚指针，指向当前行记录的上一个版本，通过这个指针将数据的多个版本连接在一起构成undo log版本链。
DB_ROLL_ID：主键，如果数据表没有主键，InnoDB会自动生成主键。
每条表记录大概是这样的：

图片
使用事务更新行记录的时候，就会生成版本链，执行过程如下：

用排他锁锁住该行；
将该行原本的值拷贝到undo log，作为旧版本用于回滚；
修改当前行的值，生成一个新版本，更新事务id，使回滚指针指向旧版本的记录，这样就形成一条版本链。
下面举个例子方便大家理解。

1、初始数据如下，其中DB_ROW_ID和DB_ROLL_PTR为空。

图片
2、事务A对该行数据做了修改，将age修改为12，效果如下：

图片
3、之后事务B也对该行记录做了修改，将age修改为8，效果如下：

图片
4、此时undo log有两行记录，并且通过回滚指针连在一起。

接下来了解下read view的概念。

read view可以理解成将数据在每个时刻的状态拍成“照片”记录下来。在获取某时刻t的数据时，到t时间点拍的“照片”上取数据。

在read view内部维护一个活跃事务链表，表示生成read view的时候还在活跃的事务。这个链表包含在创建read view之前还未提交的事务，不包含创建read view之后提交的事务。

不同隔离级别创建read view的时机不同。

read committed：每次执行select都会创建新的read_view，保证能读取到其他事务已经提交的修改。

repeatable read：在一个事务范围内，第一次select时更新这个read_view，以后不会再更新，后续所有的select都是复用之前的read_view。这样可以保证事务范围内每次读取的内容都一样，即可重复读。

read view的记录筛选方式

前提：DATA_TRX_ID 表示每个数据行的最新的事务ID；up_limit_id表示当前快照中的最先开始的事务；low_limit_id表示当前快照中的最慢开始的事务，即最后一个事务。

图片
如果DATA_TRX_ID < up_limit_id：说明在创建read view时，修改该数据行的事务已提交，该版本的记录可被当前事务读取到。
如果DATA_TRX_ID >= low_limit_id：说明当前版本的记录的事务是在创建read view之后生成的，该版本的数据行不可以被当前事务访问。此时需要通过版本链找到上一个版本，然后重新判断该版本的记录对当前事务的可见性。
如果up_limit_id <= DATA_TRX_ID < low_limit_i：
需要在活跃事务链表中查找是否存在ID为DATA_TRX_ID的值的事务。
如果存在，因为在活跃事务链表中的事务是未提交的，所以该记录是不可见的。此时需要通过版本链找到上一个版本，然后重新判断该版本的可见性。
如果不存在，说明事务trx_id 已经提交了，这行记录是可见的。
总结：InnoDB 的MVCC是通过 read view 和版本链实现的，版本链保存有历史版本记录，通过read view 判断当前版本的数据是否可见，如果不可见，再从版本链中找到上一个版本，继续进行判断，直到找到一个可见的版本。



### 总结

InnoDB 中，MVCC 就是通过 Undo Log + Read View 进行数据读取，**Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见。**从而不需要通过加锁的方式，就可以实现提交读和可重复读这两种隔离级别。



## 相关特性

### 快照读和当前读
表记录有两种读取方式。

快照读：读取的是快照版本。普通的SELECT就是快照读。通过mvcc来进行并发控制的，不用加锁。

当前读：读取的是最新版本。UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。

快照读情况下，InnoDB通过mvcc机制避免了幻读现象。而mvcc机制无法避免当前读情况下出现的幻读现象。因为当前读每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。

下面举个例子说明下：

1、首先，user表只有两条记录，具体如下：
2、事务a和事务b同时开启事务start transaction；

3、事务a插入数据然后提交；
4、事务b执行全表的update；
5、事务b然后执行查询，查到了事务a中插入的数据。（下图左边是事务b，右边是事务a。事务开始之前只有两条记录，事务a插入一条数据之后，事务b查询出来是三条数据）
以上就是当前读出现的幻读现象。

那么MySQL是如何避免幻读？

在快照读情况下，MySQL通过mvcc来避免幻读。
在当前读情况下，MySQL通过next-key来避免幻读（加行锁和间隙锁来实现的）。
next-key包括两部分：行锁和间隙锁。行锁是加在索引上的锁，间隙锁是加在索引之间的。

Serializable隔离级别也可以避免幻读，会锁住整张表，并发性极低，一般不会使用。



## 隔离级别控制



![img](https://oss.xubighead.top/oss/image/202506/1930157486905593857.png)



### 读未提交

防止多事务间的脏写，但是允许脏读。也就是说不允许修改未提交事务修改的数据行，但是允许读取未提交事务修改的数据行。

要实现这个级别，只需要在事务修改数据时添加独占锁即可。此时其它修改数据行的事务会被阻塞，只允许读取。

![图片](https://oss.xubighead.top/oss/image/202506/1930157539888041985.jpg)



当事务执行完成后会唤醒等待的其它事务，并修改它们的锁状态为 false。

![图片](https://oss.xubighead.top/oss/image/202506/1930157725754429441.jpg)



### 读已提交

就是把**释放锁的位置调整到事务提交之后**，此时在事务提交前，其他进程是无法对该行数据进行读取的，包括任何操作。

不可重复读：**一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改**

防止多事务间的脏读，但是允许不可重复读、幻读。也就是说不允许读取未提交事务修改的数据，这个级别事务读取的数据行都是其它事务已经提交的。
这个级别的实现就需要使用 ReadView 机制和 undo log 版本链了，也就是 MVCC 机制。

首先事务**「每发起一次读取都会重新生成一个 ReadView」** 记录查询时系统内尚未提交的事务 ID 快照，这个是非常重要的。



![图片](https://oss.xubighead.top/oss/image/202506/1930157807392362497.jpg)

使用 ReadView 和 undo log 就已经达到防止脏读的目的了，因为在发起读取时，所有被修改的事务未提交的数据都不会被读取到，只会读取已提交的或者历史版本。

然后本事务再次发起读取，再生成一个新的 ReadView，此时刚才修改数据行的事务可能已经提交了，那么这时再根据 ReadView 机制进行读取，就可能读取到刚才被修改的数据了。也就产生了不可重复读的问题。如果刚才那个事务是添加操作，那么根据上述读取规则就会产生幻读的问题。



### 可重复读

- **和不可重复读类似，但虚读(幻读)会读到其他事务的插入的数据，导致前后读取不一致**
- MySQL的`Repeatable read`隔离级别加上GAP间隙锁**已经处理了幻读了**。



防止多事务间的不可重复读和幻读（只针对快照读，当前读需要加锁），也就是说事务开启后读取的数据其实就是一个快照版本，无论其它事务对数据的增删改，是否提交，都不会影响本事务对数据的查询。这个级别的实现也是需要 MVCC 机制实现的。

与 RC 级别不同的是，这个级别的事务在开启后**「首次查询时会生成一个 ReadView」**，后续都不会对其修改，也就是说这个事务所有的读取操作都会基于这个 ReadView 记录的事务ID快照进行读取。就这个 ReadView 生成的区别就会让 RR 级别的事务不会产生不可重复读和幻读的问题，因为**「事务期间所有读取操作都是基于同一个 ReadView」**。还有就是如果数据行是 ReadView 生成后其它事务新增的，那么这行数据是不会有合适的历史版本的。

![图片](https://oss.xubighead.top/oss/image/202506/1930157865131151361.jpg)

综上，RC、RR 主要区别就是 ReadView 生成的规则，就是这个规则才会使 RR 级防止幻读和不可重复读的出现。当然，上述的读，都是**「基于快照读」**而言的。



### 可序列化

加锁，使所有事务串行化，可以避免所有的多事务问题。而后果也是可想而知的，将会导致 MySQL 性能及其低下。

![图片](https://oss.xubighead.top/oss/image/202506/1930157887583260673.jpg)

## 总结

1. 一般我们认为MVCC有下面几个特点：
    - 每行数据都存在一个版本，每次数据更新时都更新该版本
    - 修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰
    - 保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)
    - 就是每行都有版本号，保存时根据版本号决定是否成功，**听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功**
2. 而InnoDB实现MVCC的方式是:
    - 事务以排他锁的形式修改原始数据
    - 把修改前的数据存放于undo log，通过回滚指针与主数据关联
    - 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）
3. **二者最本质的区别是**: 当修改数据时是否要`排他锁定`，如果锁定了还算不算是MVCC？

- Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, `undo log` 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。
- 比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 `第一类更新丢失` 的情况。
- 也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。



事务是在 MySQL 引擎层实现的，我们常见的 InnoDB 引擎是支持事务的，事务的四大特性是原子性、一致性、隔离性、持久性，我们这次主要讲的是隔离性。

当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，SQL 提出了四种隔离级别，分别是读未提交、读已提交、可重复读、串行化，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。

要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。

而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它通过 next-key lock 锁（行锁+间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。

对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：

- 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
- 「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。

这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。

在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。