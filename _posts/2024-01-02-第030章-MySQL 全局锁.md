---
layout: post
title: 2024-01-02-第030章-MySQL 全局锁.md
categories: [MySQL]
description: 
keywords: MySQL 全局锁.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# MySQL 全局锁

锁作用于全局，整个数据库的所有操作全部受到锁限制。



## 语法

### FTWRL

```sql
# 获取全局锁
flush tables with read lock

# 执行释放全局锁命令来释放全局锁，或当会话断开了，全局锁会被自动释放。
unlock tables
```



执行获取全局锁后，**整个数据库就处于只读状态了**，这时其他线程执行以下操作，都会被阻塞：

- 数据更新语句，对数据的增删改操作，比如 insert、delete、update等语句；
- 数据定义语句，对表结构的更改操作，比如 alter table、drop table 等语句。
- 更新类事务的提交语句



在执行完获取全局锁命令后执行更新数据语句，会抛出如下异常：

> ERROR 1223 (HY000): Can't execute the query because you have a conflicting read lock



FTWRL 前有读写的话，FTWRL 都会等待读写执行完毕后才执行。FTWRL 执行的时候要刷脏页的数据到磁盘，因为要保持数据的一致性。



## 应用场景

### 全库逻辑备份

全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。对于支持可重复读的存储引擎中进行数据备份时就可以不适用全局锁来保证数据一致性。



#### 使用全局锁风险

- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。



#### InnoDB存储引擎全库备份

如果数据库的引擎支持的事务支持**可重复读的隔离级别**，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。

备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持可重复读隔离级别的事务的存储引擎。

InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。



#### 设置read_only参数

相比于全局锁，不推荐使用设置read_only为true的方式来避免数据被修改产生不一致，主要原因如下：

- 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库，因此，修改 global 变量的方式影响面更大。
- 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。
