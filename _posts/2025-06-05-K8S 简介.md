# Introduction

**K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。**



## Changes In Deployment Methods

![image-20220909014039574](https://oss.xubighead.top/oss/image/202506/1930508480432672770.jpg)



**传统部署时代**：

早期，各个组织是在物理服务器上运行应用程序。 由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。 例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程式资源利用率不高时，剩余资源无法被分配给其他应用程式， 而且维护许多物理服务器的成本很高。



**虚拟化部署时代**：

因此，虚拟化技术被引入了。虚拟化技术允许你在单个物理服务器的 CPU 上运行多台虚拟机（VM）。 虚拟化能使应用程序在不同 VM 之间被彼此隔离，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。

虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序， 而因此可以具有更高的可扩缩性，以及降低硬件成本等等的好处。 通过虚拟化，你可以将一组物理资源呈现为可丢弃的虚拟机集群。

每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。



**容器部署时代**：

容器类似于 VM，但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）。 因此，容器比起 VM 被认为是更轻量级的。且与 VM 类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。

容器因具有许多优势而变得流行起来，例如：

- 敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。
- 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。
- 关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。
- 可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。
- 跨开发、测试和生产的环境一致性：在笔记本计算机上也可以和在云中运行一样的应用程序。
- 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。
- 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
- 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。
- 资源隔离：可预测的应用程序性能。
- 资源利用：高效率和高密度。



## Container

### What Is Container

容器的本质是一种特殊的进程。

在linux容器中有三个重要的概念：Namespace、Cgroups、rootfs。

Namespace做隔离，让进程只能看到Namespace中的世界；

Cgroups   做限制，让这个“世界”围着一个看不见的墙。

rootfs      做文件系统，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。

这样就实现了进程在我们所看到的一个与世隔绝的房间，这个房间就是Pass项目赖以生存的"沙盒"。

![img](https://oss.xubighead.top/oss/image/202506/1930508504843522050.jpg)

### Namespace

进入容器后，ps命令看到的容器的应用进程都是1号进程，这个其实是pid namespace导致，他其实就是个障眼法，

让你看到的是类似于一个新的虚拟机新环境，其实是不一样的，容器就是一个运行的进程，而容器中的其他进程则是pid为1的子进程。

除了刚刚pid namespace，还有其它的namespace如下：

![img](https://img2018.cnblogs.com/blog/1024482/201908/1024482-20190831154305541-1811424117.png)

**容器是怎么新建namespace的？**

docker创建容器，其实就是linux系统的一次fork的调用，

在进行fork调用时，会传入一些flag参数，这个参数可以控制对linux内核调用新的namespace。



### rootfs

挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。

容器的rootfs由三部分组成，1：只读层、2：可读写层、3：init层

1.只读层:都以增量的方式分别包含了  操作系统的一部分。

2.可读写：就是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。

3.Init 层：是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。



## Kubernetes

Kubernetes (通常称为K8s，K8s是将8个字母“ubernete”替换为“8”的缩写) 是用于**自动部署、扩展和管理容器化（containerized）应用程序的开源系统**。它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。它支持一系列容器工具, 包括Docker等。

Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。



### Feature

容器技术可以解决应用程序打包和部署问题，但是在生产环境中，不光是把应用部署上去就完事了，还需要确保应用能够稳定提供服务，即使挂掉也能快速恢复，当高并发下时能够扩容，低并发下能够缩容以节约资源。Kubernetes提供了如下功能保证服务的运行：

1. **服务发现和负载均衡**：Kubernetes 可以使用 DNS 名称或自己的 IP 地址来曝露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。
2. **存储编排**：Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。
3. **自动部署和回滚**：你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。
4. **自动完成装箱计算**：你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。
5. **自我修复**：Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。
6. **密钥与配置管理**：Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。



1、可移植: 支持公有云，私有云，混合云，多重云（multi-cloud）

2、可扩展: 模块化, 插件化, 可挂载, 可组合

3、自动化: 自动部署，自动重启，自动复制，自动伸缩/扩展

4、快速部署应用，快速扩展应用

5、无缝对接新的应用功能

6、节省资源，优化硬件资源的使用



### Kubernetes规划组件

Kubernetes定义了一组构建块，它们可以共同提供部署、维护和扩展应用程序的机制。组成Kubernetes的组件设计为松耦合和可扩展的，这样可以满足多种不同的工作负载。可扩展性在很大程度上由**Kubernetes API**提供——它被作为扩展的内部组件以及Kubernetes上运行的容器等使用。

- Pod
- 标签和选择器
- 控制器
- 服务



### Kubernetes核心组件

Kubernetes遵循*master-slave architecture*。Kubernetes的组件可以分为管理单个的 node 组件和控制平面的一部分的组件。

Kubernetes Master是集群的主要控制单元，用于管理其工作负载并指导整个系统的通信。Kubernetes控制平面由各自的进程组成，每个组件都可以在单个主节点上运行，也可以在支持*high-availability clusters*的多个主节点上运行。

Kubernetes主要由以下几个核心组件组成：

| **组件名称**           | **说明**                                                     |
| ---------------------- | ------------------------------------------------------------ |
| **etcd**               | 保存了整个集群的状态；                                       |
| **apiserver**          | 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制； |
| **controller manager** | 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；     |
| **scheduler**          | 负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；  |
| **kubelet**            | 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理； |
| **Container runtime**  | 负责镜像管理以及Pod和容器的真正运行（CRI）；                 |
| **kube-proxy**         | 负责为Service提供cluster内部的服务发现和负载均衡；           |



核心组件结构图：

![img](https://oss.xubighead.top/oss/image/202506/1930508530151952385.jpg)



除了核心组件，还有一些推荐的Add-ons：

| **组件名称**              | **说明**                     |
| ------------------------- | ---------------------------- |
| **kube-dns**              | 负责为整个集群提供DNS服务    |
| **Ingress Controller**    | 为服务提供外网入口           |
| **Heapster**              | 提供资源监控                 |
| **Dashboard**             | 提供GUI                      |
| **Federation**            | 提供跨可用区的集群           |
| **Fluentd-elasticsearch** | 提供集群日志采集、存储与查询 |



### Layered Architecture

Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示：

![img](https://oss.xubighead.top/oss/image/202506/1930508554462138369.jpg)



分层说明：

| **分层结构** | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| **核心层**   | Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境 |
| **应用层**   | 部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等） |
| **管理层**   | 系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等） |
| **接口层**   | kubectl命令行工具、客户端SDK以及集群联邦                     |
| **生态系统** | 在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴：<br />**Kubernetes外部**：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS应用、ChatOps等<br />**Kubernetes内部**：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等 |



## K8S三种IP

| **类型**       | **说明**                                                     |
| -------------- | ------------------------------------------------------------ |
| **Node IP**    | 节点设备的IP，如物理机，虚拟机等容器宿主的实际IP。           |
| **Pod IP**     | Pod 的IP地址，是根据docker0网格IP段进行分配的。              |
| **Cluster IP** | Service的IP，是一个虚拟IP，仅作用于service对象，由k8s管理和分配，需要结合service port才能使用，单独的IP没有通信功能，集群外访问需要一些修改。 |



## Additional

### Compare With Docker

Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。

K8S，是基于容器的集群管理平台，它的全称，是kubernetes。
