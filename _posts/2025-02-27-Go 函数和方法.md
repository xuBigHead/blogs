# Go 函数

## 函数声明

> 每个Go程序至少有一个`main()`函数，且`main()`函数必须不带任何输入参数和返回结果

```go
func SquaresOfSumAndDiff(a int64, b int64) (s int64, d int64) {
	x, y := a + b, a - b
	s = x * x
	d = y * y
	return // <=> return s, d
}

// 等价于上述函数
func SquaresOfSumAndDiff(a int64, b int64) (int64, int64) {
	return (a+b) * (a+b), (a-b) * (a-b)
}

// 等价于上述函数
func SquaresOfSumAndDiff(a, b int64) (s, d int64) {
	return (a+b) * (a+b), (a-b) * (a-b)
	// 上面这行等价于下面这行：
	// s = (a+b) * (a+b); d = (a-b) * (a-b); return
}
```

所有函数都必须直接声明在包级代码块中，或者说任何一个函数都不能被声明在另一个函数体内。虽然匿名函数可以定义在函数体内，但匿名函数定义不属于函数声明。函数声明从左到右由以下部分组成：

1. 第一部分是`func`关键字；
2. 第二部分是函数名称，函数名称必须是一个标识符；
   1. 同一个包中声明的函数的名称不能重复，但是原型为`func ()`的名称为`init`的函数和名称为空标识符`_`（该函数不可被调用）的除外；
3. 第三部分是输入参数列表，输入参数声明也称为形参声明，对应函数调用中的实参；
   1. 输入参数由名称和类型组成，名称在前，类型在后；
   2. 如果若干连续的输入参数的类型相同，则在它们的声明中可以共用一个类型；
   3. 输入参数声明列表必须用一对小括号括起来，即使输入参数列表为空；
   4. 如果一个函数声明中的所有输入参数在此函数体内都没有被使用过，则它们也可以都同时是匿名的；
   5. Go不支持输入参数默认值；
   6. 函数体内，具名输入参数可以被当作局部变量来使用，也可以不使用；
4. 第四部分是输出结果声明列表；
   1. 结果声明由名称和类型组成，名称在前，类型在后；
   2. 一个函数可以有多个返回值；
   3. 如果若干连续的返回结果的类型相同，则在它们的声明中可以共用一个类型；
   4. 输出结果声明列表中的结果名称必须同时出现或者同时省略；
   5. 结果名称同时省略时称为具名返回结果，函数体内的返回语句`return`关键字后跟随的一系列返回值可以省略；
   6. 结果名称未同时省略时称为匿名返回结果，函数体内的返回语句`return`关键字后必须跟随一系列返回值，这些返回值和各个返回结果声明一一对应；
   7. 函数声明只包含一个匿名返回结果声明时，此列表可以不用一对小括号括起来；
   8. 函数声明的返回结果列表为空，则此函数声明中的返回结果部分可以完全被省略掉；
   9. 函数体内，具名返回结果可以被当作局部变量来使用，也可以不使用；
   10. 每个返回结果的默认值是它的类型的零值；
5. 最后一部分是函数体，函数体必须用一对大括号括起来，一对大括号和它其间的代码形成了一个显式代码块。在一个函数体内，`return`关键字可以用来结束此函数的正常向前执行流程并进入此函数的退出阶段。



### 变长函数声明

变长函数（Variadic Function）声明和普通函数声明类似，只不过最后一个参数必须为变长参数，一个变长参数在函数体内将被视为一个切片。如果一个变长参数的类型部分为`...T`，则此变长参数的类型实际为`[]T`。

```go
func Sum(values ...int64) (sum int64) {
	// values的类型为[]int64。
	sum = 0
	for _, v := range values {
		sum += v
	}
	return
}

func Concat(sep string, tokens ...string) string {
	// tokens的类型为[]string。
	r := ""
	for i, t := range tokens {
		if i != 0 {
			r += sep
		}
		r += t
	}
	return r
}
```



### 其他特性

#### 函数返回值不必返回

如果一个函数有返回值，则它的函数体内的最后一条语句必须为一条[终止语句](https://golang.google.cn/ref/spec#Terminating_statements)。Go中有多种终止语句，`return`语句只是其中一种。所以一个有返回值的函数的体内不一定需要一个`return`语句。比如下面两个函数（它们均可编译通过）：

```go
func fa() int {
	a:
	goto a
}

func fb() bool {
	for{}
}
```



#### 函数调用返回结果舍弃

自定义函数的调用结果都是可以被舍弃掉的，但是大多数内置函数（除了`recover`和`copy`）的调用结果都是不可被舍弃的，调用结果不可被舍弃的函数是不可以被用做延迟调用函数和协程起始函数的，比如`append`函数。



## 函数签名

函数签名（Function Signature）由输入参数类型列表和输出结果类型列表组成。`func`关键字可以出现在函数签名的字面形式中，也可以不出现，因此常常混淆函数类型和函数签名这两个概念。



## 函数类型

函数类型（Function Type）函数类型是Go中天然支持的一种类型，可以用来定义变量、参数和返回值。函数类型属于不可比较类型，但是和映射值以及切片值类似，函数值可以和类型不确定的`nil`比较，因为函数类型属于不可比较类型，所以函数类型不可用做映射类型的键值类型。

下面是一些函数类型的字面形式:

```go
func (a int, b string, c string) (x int, y int, z bool)
// 连续的同类型参数和结果可以声明在一起
func (a int, b, c string) (x, y int, z bool)
// 参数名称和结果名称并不重要，只要它们不重名即可
func (x int, y, z string) (a, b int, c bool)
// 参数名和结果名可以是空标识符`_`
func (_ int, _, _ string) (_, _ int, _ bool)
// 函数参数列表中的参数名或者结果列表中的结果名可以同时省略（即匿名）
func (int, string, string) (int, int, bool) // 标准函数字面形式
func (a int, b string, c string) (int, int, bool)
func (x int, _ string, z string) (int, int, bool)
func (int, string, string) (x int, y int, z bool)
func (int, string, string) (a int, b int, _ bool)
```

```go
// 这三个函数类型字面形式是等价的。
func () (x int)
func () (int)
func () int

// 这两个函数类型字面形式是等价的。
func (a int, b string) ()
func (a int, b string)
```



### 变长函数类型

函数的最后一个参数可以是一个变长参数，一个函数可以最多有一个变长参数，一个变长参数的类型总为一个切片类型。变长参数在声明的时候必须在它的切片类型的元素类型前面前置三个点`...`，以示这是一个变长参数。变长函数类型和非变长函数类型不可能是同一个类型。两个变长函数类型的例子：

```go
func (values ...int64) (sum int64)
func (sep string, tokens ...string) string
```



## 函数值

函数类型的值称为函数值，函数类型的零值也使用预定义的`nil`来表示。声明函数时，实际上同时声明了一个不可修改的函数值，此函数值用此函数的名称来标识，此函数值的类型的字面表示形式为此函数的原型刨去函数名部分。

任何函数值都可以被当作普通声明函数来调用，调用一个nil函数来开启一个协程将产生一个致命的不可恢复的错误，此错误将使整个程序崩溃。在其它情况下调用一个nil函数将产生一个可恢复的恐慌。

当函数值被赋给另一个函数值后，这两个函数值将共享底层部分（内部的函数结构），换句话说，这两个函数值表示的函数可以看作是同一个函数，调用它们的效果是相同的。

> 注意：内置函数和`init`函数不可被用做函数值。

```go
func Double(n int) int {
	return n + n
}

func Apply(n int, f func(int) int) int {
	return f(n) // f的类型为"func(int) int"
}

func main() {
	fmt.Printf("%T\n", Double) // func(int) int
	// Double = nil // error: Double是不可修改的

	var f func(n int) int // 默认值为nil
	f = Double
	g := Apply
	fmt.Printf("%T\n", g) // func(int, func(int) int) int

	fmt.Println(f(9))         // 18
	fmt.Println(g(6, Double)) // 12
	fmt.Println(Apply(6, f))  // 12，g(6, Double)和Apply(6, f)是等价的。
}
```



在实践中常常将一个匿名函数赋值给一个函数类型的变量，从而可以在以后多次调用此匿名函数。

```go
func main() {
	// 此函数返回一个函数类型的结果，亦即闭包（closure）。
	isMultipleOfX := func (x int) func(int) bool {
		return func(n int) bool {
			return n%x == 0
		}
	}

	var isMultipleOf3 = isMultipleOfX(3)
	var isMultipleOf5 = isMultipleOfX(5)
	fmt.Println(isMultipleOf3(6))  // true
	fmt.Println(isMultipleOf3(8))  // false
	fmt.Println(isMultipleOf5(10)) // true
	fmt.Println(isMultipleOf5(12)) // false

	isMultipleOf15 := func(n int) bool {
		return isMultipleOf3(n) && isMultipleOf5(n)
	}
	fmt.Println(isMultipleOf15(32)) // false
	fmt.Println(isMultipleOf15(60)) // true
}
```



另一个例子：

```go
func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
     return i  
   }
}

func main(){
   /* nextNumber 为一个函数，函数 i 为 0 */
   nextNumber := getSequence()  

   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
   fmt.Println(nextNumber()) // 1
   fmt.Println(nextNumber()) // 2
   fmt.Println(nextNumber()) // 3
   
   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1()) // 1
   fmt.Println(nextNumber1()) // 2
}
```



### 遍历函数值

从Go 1.23开始，底层类型为下列函数类型的函数值可以使用`for-range`循环来遍历，这样的函数值称为推遍历器（push iterator），常简称为遍历器。

```go
// K和V是特定类型

func(yield func() bool)

func(yield func(V) bool)

func(yield func(K, V) bool)
```



当使用一个`for-range`循环遍历这样的一个遍历器函数值时，这个遍历器函数值将被调用（一次）并被传入一个隐式创建的`yield`回调函数。此`yield`回调函数返回一个`bool`结果。当它返回`false`时，这个遍历器函数的调用应该（但并不强求一定）立即退出；否则（当此`yield`回调函数返回`true`时），这个遍历器函数应该继续执行，直到自然退出。下面是一些使用遍历器函数的例子：

```go
func Loop3(yield func() bool) {
	for range 3 {
		if (!yield()) {
			return
		}
	}
}

func OneDigitNumbers(onValue func(int) bool) {
	for i := range 10 {
		if (!onValue(i)) {
			return
		}
	}
}

func SquareLessThan50(onKeyValue func(int, int) bool) {
	for i := range 8 {
		if (!onKeyValue(i, i*i)) {
			return
		}
	}
}

func main() {
	var n = 0
	for range Loop3 {
		fmt.Print(n)
		n++
	}
	fmt.Println()
	// 输出：012
	
	for i := range OneDigitNumbers {
		fmt.Print(i)
	}
	fmt.Println()
	// 输出：0123456789
	
	for i, ii := range SquareLessThan50 {
		fmt.Printf("%v:%v ", i, ii)
	}
	fmt.Println()
	// 输出：0:0 1:1 2:4 3:9 4:16 5:25 6:36 7:49 
}
```



上面这些`for-range`循环和下面这些相应的函数调用是等价的：

```go
func main() {
	var n = 0
	Loop3(func() bool {
		fmt.Print(n)
		n++
		return true
	})
	fmt.Println()
	
	OneDigitNumbers(func(i int) bool {
		fmt.Print(i)
		return true
	})
	fmt.Println()
	
	SquareLessThan50(func(i, ii int) bool {
		fmt.Printf("%v:%v ", i, ii)
		return true
	})
	fmt.Println()
}
```



## 函数原型

函数原型（Function Prototype）由函数名称和函数类型（或者说函数签名）组成，它的字面形式由`func`关键字、函数名和函数签名字面形式组成。换句话说，函数原型可以看作是不带函数体的函数声明；或者说函数声明由函数原型和函数体组成。一个函数原型的例子：

```go
func Double(n int) (result int)
```



## 函数调用

函数可以通过它的名称和实参列表来调用，函数的声明可以出现在它的调用之前，也可以出现在它的调用之后，实参列表必须用小括号括起来，实参列表中的每一个单值实参对应着一个形参。实参值的类型必须要和其对应的形参声明的类型一样，或者能够隐式转换到其对应的形参的类型。

函数传参也属于值（浅）复制操作，在传参中，各个实参被值（浅）复制给各个对应形参。当一个值被复制时，只有它的直接部分被复制了。

```go
func SquaresOfSumAndDiff(a int64, b int64) (int64, int64) {
	return (a+b) * (a+b), (a-b) * (a-b)
}

func CompareLower4bits(m, n uint32) bool {
	r = m&0xF > n&0xf
	return
}

// 使用一个函数调用的返回结果来初始化一个包级变量。
var v = VersionString()

func main() {
	println(v) // v1.0
	x, y := SquaresOfSumAndDiff(3, 6)
	println(x, y) // 81 9
	b := CompareLower4bits(uint32(x), uint32(y))
	println(b) // false
	// "Go"的类型被推断为string；1的类型被推断为int32。
	doNothing("Go", 1)
}

func VersionString() string {
	return "v1.0"
}

func doNothing(string, int32) {
}
```



当函数调用返回后（比如执行了一个`return`语句或者函数中的最后一条语句执行完毕），此调用可能并未立即退出。一个函数调用从返回开始到最终退出的阶段称为此函数调用的退出阶段（exiting phase）。



### 参数浅复制

函数如果使用参数，该变量可称为函数的形参，形参就像定义在函数体内的局部变量。默认情况下，Go语言使用的是值传递，调用函数时将实际参数复制一份传递到函数中，在函数中如果对参数进行修改，将不会影响到实际参数。

```go
func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200

   fmt.Printf("交换前 a 的值为 : %d\n", a ) // 交换前 a 的值为 : 100
   fmt.Printf("交换前 b 的值为 : %d\n", b ) // 交换前 b 的值为 : 200

   /* 通过调用函数来交换值 */
   swap(a, b)

   fmt.Printf("交换后 a 的值 : %d\n", a ) // 交换后 a 的值 : 100
   fmt.Printf("交换后 b 的值 : %d\n", b ) // 交换后 b 的值 : 200
}

/* 定义相互交换值的函数 */
func swap(x, y int) int {
   var temp int

   temp = x /* 保存 x 的值 */
   x = y    /* 将 y 值赋给 x */
   y = temp /* 将 temp 值赋给 y*/

   return temp;
}
```



#### 引用类型参数

引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：

```go
func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int= 200

   fmt.Printf("交换前，a 的值 : %d\n", a ) // 交换前，a 的值 : 100
   fmt.Printf("交换前，b 的值 : %d\n", b ) // 交换前，b 的值 : 200

   /* 调用 swap() 函数
   * &a 指向 a 指针，a 变量的地址
   * &b 指向 b 指针，b 变量的地址
   */
   swap(&a, &b)

   fmt.Printf("交换后，a 的值 : %d\n", a ) // 交换后，a 的值 : 200
   fmt.Printf("交换后，b 的值 : %d\n", b ) // 交换后，b 的值 : 100
}

func swap(x *int, y *int) {
   var temp int
   temp = *x    /* 保存 x 地址上的值 */
   *x = *y      /* 将 y 值赋给 x */
   *y = temp    /* 将 temp 值赋给 y */
}
```



#### 数组型参数

在做函数调用时，slice 按引用传递，array 按值传递：

```go
func main() {
	arr1 := []int{1, 2, 3}
	arr2 := [3]int{1, 2, 3}
	arr3 := [3]int{1, 2, 3}

	fmt.Println("before change arr1, ", arr1) // before change arr1,  [1 2 3]
	changeSlice(arr1) // slice 按引用传递
	fmt.Println("after change arr1, ", arr1) // after change arr1,  [9999 2 3]

	fmt.Println("before change arr2, ", arr2) // before change arr2,  [1 2 3]
	changeArray(arr2) // array 按值传递
	fmt.Println("after change arr2, ", arr2) // after change arr2,  [1 2 3]

	fmt.Println("before change arr3, ", arr3) // before change arr3,  [1 2 3]
	changeArrayByPointer(&arr3) // 可以显式取array的 指针
	fmt.Println("after change arr3, ", arr3) // after change arr3,  [6666 2 3]
}

func changeSlice(arr []int) {
	arr[0] = 9999
}

func changeArray(arr [3]int) {
	arr[0] = 6666
}

func changeArrayByPointer(arr *[3]int) {
	arr[0] = 6666
}
```



#### 切片类型参数

当把 slice 作为参数，本身传递的是值，但其内容就 **byte\* array**，实际传递的是引用，所以可以在函数内部修改，但如果对 slice 本身做 append，而且导致 slice 进行了扩容，实际扩容的是函数内复制的一份切片，对于函数外面的切片没有变化。



```go
func main() {
	slice_test := []int{1, 2, 3, 4, 5} // 24
	fmt.Println(unsafe.Sizeof(slice_test))
	fmt.Printf("main:%#v, %#v, %#v\n", slice_test, len(slice_test), cap(slice_test)) // main:[]int{1, 2, 3, 4, 5}, 5, 5
	slice_value(slice_test)
	fmt.Printf("main:%#v, %#v, %#v\n", slice_test, len(slice_test), cap(slice_test)) // main:[]int{1, 100, 3, 4, 5}, 5, 5
	slice_ptr(&slice_test)
	fmt.Printf("main:%#v, %#v,%#v\n", slice_test, len(slice_test), cap(slice_test)) // main:[]int{1, 100, 3, 4, 5, 7}, 6,10
	fmt.Println(unsafe.Sizeof(slice_test)) // 24
}

func slice_value(slice_test []int) {
	slice_test[1] = 100                // 函数外的slice确实有被修改
	slice_test = append(slice_test, 6) // 函数外的不变
	fmt.Printf("slice_value:%#v, %#v, %#v\n", slice_test, len(slice_test), cap(slice_test)) // slice_value:[]int{1, 100, 3, 4, 5, 6}, 6, 10
}

func slice_ptr(slice_test *[]int) { // 这样才能修改函数外的slice
	*slice_test = append(*slice_test, 7)
	fmt.Printf("slice_ptr:%#v, %#v, %#v\n", *slice_test, len(*slice_test), cap(*slice_test)) // slice_ptr:[]int{1, 100, 3, 4, 5, 7}, 6, 10
}
```



slice 的底层是数组指针，所以 slice **a** 和 **s** 指向的是同一个底层数组，所以当修改 **s[0]** 时，**a** 也会被修改。

```go
func main() {
	s := []int{1, 2, 3} // len=3, cap=3
	a := s
	s[0] = 888
	s = append(s, 4)
	fmt.Println(a, len(a), cap(a)) // 输出：[888 2 3] 3 3
	fmt.Println(s, len(s), cap(s)) // 输出：[888 2 3 4] 4 6
}
```



#### 函数类型参数

在 Go 语言中，type 可以定义任何自定义的类型。所以 func 也是可以作为类型自定义的，`type myFunc func(int) int`，意思是自定义了一个叫 myFunc 的函数类型，这个函数的类型必须符合输入为 int，输出为 int。

```go
type Function func(a, b int) int
func calFunction(fu Function, a, b int) int {
	return fu(a, b)
}

func max(num1, num2 int) int {
	if num1 > num2 {
		return num1
	} 
	return num2
}

type Consumer func(a int)
func calConsumer(con Consumer, a int) {
	con(a)
}

func printArgs(a int) {
	fmt.Printf("输入参数为%d\n", a) // 输入参数为1
}

func TestFuncType(t *testing.T) {
	var result = calFunction(max, 1, 2)
	fmt.Printf("计算结果为%d\n", result) // 计算结果为2

	calConsumer(printArgs, 1)
}
```



### 带返回值函数（方法）调用表达式

- 只有一个返回值的函数（方法）调用可以当作源值使用，可以和其他源值一起进行赋值；

```go
func funcWithOneReturn() float64              { return 1 }

type T struct{}
func (T) methodWithOneReturn() float64            { return 1 }

func TestFuncWithReturn(t *testing.T) {
 	a1 := funcWithOneReturn()
	a2, a3 := funcWithOneReturn(), 1.0
	fmt.Println(a1, a2, a3)   
    
    A1 := T{}.methodWithOneReturn()
	A2, A3 := T{}.methodWithOneReturn(), 1.0
	fmt.Println(A1, A2, A3)
}
```



- 有多返回值的函数（方法）调用也可以当作源值使用，但是不可以和其他源值一起进行赋值；

```go
func funcWithMultiReturn() (float64, int64) { return 1, 2 }

func (T) methodWithMultiReturn() (float64, int64) { return 1, 2 }

func TestFuncWithReturn(t *testing.T) {
	b1, b2 := funcWithMultiReturn()
	fmt.Println(b1, b2)
	// 下述方式会提示编译错误，Assignment count mismatch: 3 = 2
	// b3, b4, b5 := funcWithMultiReturn(), 1.0

	B1, B2 := T{}.methodWithMultiReturn()
	fmt.Println(B1, B2)
	// 下述方式会提示编译错误，Assignment count mismatch: 3 = 2
	// B3, B4, B5 := T{}.methodWithMultiReturn(), 1.0
}
```



- 只有一个返回值的函数（方法）调用可以当作实参使用，可以和其他实参一起进行传参；

```go
func funcWithOneParam(float64)              {}
func funcWithMultiParams(float64, int64)    {}

func TestFuncWithReturn(t *testing.T) {
	funcWithOneParam(funcWithOneReturn())
	funcWithMultiParams(funcWithOneReturn(), 123)
    
    funcWithOneParam(T{}.methodWithOneReturn())
	funcWithMultiParams(T{}.methodWithOneReturn(), 123)
}
```



- 有多个返回值的函数（方法）调用可以当作实参使用，但是不可以和其他实参一起进行传参；

```go
func funcWithMoreMultiParams(float64, int64, float64) {}

func TestFuncWithReturn(t *testing.T) {
    	funcWithMultiParams(funcWithMultiReturn())
	// 下述方式会提示编译错误，Not enough arguments in call to 'funcWithMoreMultiParams'
	// funcWithMoreMultiParams(funcWithMultiReturn(), 1.0)

	funcWithMultiParams(T{}.methodWithMultiReturn())
	// 下述方式会提示编译错误，Not enough arguments in call to 'funcWithMoreMultiParams'
	// funcWithMoreMultiParams(T{}.methodWithMultiReturn(), 1.0)
}
```



### 变长函数调用

在变长参数函数调用中，可以使用两种风格的方式将实参传递给类型为`[]T`的变长形参：

1. 传递一个切片做为实参，此切片必须可以被赋值给类型为`[]T`的值，或者说此切片可以被隐式转换为类型`[]T`，此实参切片后必须跟随三个点`...`；
2. 传递零个或者多个可以被隐式转换为`T`的实参，或者说这些实参可以赋值给类型为`T`的值，这些实参将被添加入一个匿名的在运行时刻创建的类型为`[]T`的切片中，然后此切片将被传递给此函数调用。



注意，这两种风格的方式不可在同一个变长参数函数调用中混用。下面这个例子展示了一些变长参数函数调用：

```go
func main() {
	a0 := Sum()
	a1 := Sum(2)
	a3 := Sum(2, 3, 5)
	// 上面三行和下面三行是等价的。
	b0 := Sum([]int64{}...) // <=> Sum(nil...)
	b1 := Sum([]int64{2}...)
	b3 := Sum([]int64{2, 3, 5}...)
	fmt.Println(a0, a1, a3) // 0 2 10
	fmt.Println(b0, b1, b3) // 0 2 10
}
```



另一个展示了一些变长参数函数调用的例子：

```go
func main() {
	tokens := []string{"Go", "C", "Rust"}
	langsA := Concat(",", tokens...)        // 风格1
	langsB := Concat(",", "Go", "C","Rust") // 风格2
	fmt.Println(langsA == langsB)           // true
}
```



下面这个例子编译不通过，因为两种调用风格混用了。

```go
func main() {
	// 下面两行报同样的错：实参数目太多了。
	_ = Sum(2, []int64{3, 5}...)
	_ = Concat(",", "Go", []string{"C", "Rust"}...)
}
```



### 函数调用编译期估值

大多数函数调用都是在运行时刻被估值的，但`unsafe`标准库包中的函数，和某些其它内置函数（比如`len`和`cap`等）的调用在所传实参满足一定的条件的时候也将在编译时刻估值。如果一个函数调用在编译时刻被估值，则估值结果为一个常量。

| 函数                                                   | 返回类型                                    | 其调用是否总是在编译时刻估值                                 |
| :----------------------------------------------------- | :------------------------------------------ | :----------------------------------------------------------- |
| unsafe.Sizeof<br />unsafe.Alignof<br />unsafe.Offsetof | uintptr                                     | 是。如果函数调用的实参类型为一个类型参数，则此函数调用的结果将不被视为一个常量。 |
| len<br />cap                                           | int                                         | 否。如果表达式`s`表示一个字符串常量，则表达式`len(s)`将在编译时刻估值；如果表达式`s`表示一个数组或者数组的指针，并且`s`中不含有数据接收操作和估值结果为非常量的函数调用，则表达式`len(s)`和`cap(s)`将在编译时刻估值。如果函数调用的实参类型为一个类型参数，则此函数调用的结果将不被视为一个常量。 |
| real<br />imag                                         | 默认类型为float64（结果为类型不确定值）     | 否。表达式`real(s)`和`imag(s)`在`s`为一个复数常量表达式时才在编译时刻估值。 |
| complex                                                | 默认类型为complex128 （结果为类型不确定值） | 否。表达式`complex(sr, si)`只有在`sr`和`si`都为常量表达式的时候才在编译时刻估值。 |



## 匿名函数

Go支持匿名函数，定义一个匿名函数和声明一个函数类似，但是一个匿名函数的定义中不包含函数名称部分。**注意匿名函数定义不是一个函数声明。**一个匿名函数在定义后可以被立即调用，也可以赋值给某个函数类型的值，在以后合适的时候再调用它：

```go
func main() {
	x, y := func() (int, int) { // 这个匿名函数没有输入参数，但有两个返回结果。
		println("This function has no parameters.")
		return 3, 4
	}() // 一对小括号表示立即调用此函数。不需传递实参。

	// 下面这些匿名函数没有返回结果。
	func(a, b int) {
		println("a*a + b*b =", a*a + b*b) // a*a + b*b = 25
	}(x, y) // 立即调用并传递两个实参。

	func(x int) { // 形参x遮挡了外层声明的变量x。
		println("x*x + y*y =", x*x + y*y) // x*x + y*y = 32
	}(y) // 将实参y传递给形参x。

	func() {
		println("x*x + y*y =", x*x + y*y) // x*x + y*y = 25
	}() // 不需传递实参。
}
```



上例中的最后一个匿名函数处于变量`x`和`y`的作用域内，所以在它的函数体内可以直接使用这两个变量，这样的函数称为闭包（closure）。Go中的所有的自定义函数（包括声明的函数和匿名函数）都可以被视为闭包，这就是为什么Go中的函数使用起来和动态语言中的函数一样灵活。



### 匿名函数作用域

匿名函数也可以和普通函数一样，作为函数值赋值给变量，然后通过变量多次调用。声明在函数内的匿名函数为局部匿名函数，其作用域在函数内；声明在包内的匿名函数为全局匿名函数，作用域在包内。

```go
var (
    myRes = func (a int, b int) int {
        return a - b
    }
)

func TestAnonymousFunction(t *testing.Test){
     // 将匿名函数用全局变量接收，则该函数为全局匿名函数
    res4 := myRes(10,25)
    fmt.Printf("res4 =%d\n", res4) // res4 =-15
    
    // 匿名函数赋给变量用变量来调用,可多次使用，但作用域有限
    res2 := func (a int, b int) int {
        return a * b
    }
    res3 := res2(10,25)
    fmt.Printf("res3 =%d\n", res3) // res3 =250
}
```



## 内置函数

Go中有一些内置函数，这些函数展示在`builtin`和`unsafe`标准包中，比如`println`和`print`函数，可以不引入任何库包来调用内置函数。

可以使用内置函数`real`和`imag`来得到一个复数的实部和虚部（均为浮点数类型），如果这两个函数的任何一个调用的实参是一个常量，则此调用将在编译时刻被估值，其返回结果也是一个常量，此调用将被视为一个常量表达式；如果此实参是一个类型不确定值，则返回结果也是一个类型不确定值。一个例子：

```go
// c是一个类型不确定复数常量。
const c = complex(1.6, 3.3)

// 函数调用real(c)和imag(c)的结果都是类型不确定浮点数值。在下面这句赋值中，它们都被推断为float32类型的值。
var a, b float32 = real(c), imag(c)

// 变量d的类型被推断为内置类型complex64，函数调用real(d)和imag(d)的结果都是类型为float32的类型确定值。
var d = complex(a, b)

// 变量e的类型被推断为内置类型complex128，函数调用real(e)和imag(e)的结果都是类型为float64的类型确定值。
var e = c
```



### print和println

内置函数`print`和`println`提供了和`fmt`标准库包中的对应函数相似的功能，可以将不定数量参数的字符串表示形式输出到标准输出中，`print`和`println`这两个内置函数不推荐使用在生产环境，因为它们不保证一定会出现在以后的Go版本中。

1. 内置的`print`/`println`函数总是写入标准错误，`fmt`标准包里的打印函数总是写入标准输出，`log`标准包里的打印函数会默认写入标准错误，然而也可以通过`log.SetOutput`函数来配置；
2. 内置`print`/`println`函数的调用不能接受数组和结构体参数；
3. 对于组合类型的参数，内置的`print`/`println`函数将输出参数的底层值部的地址，而`fmt`和`log`标准库包中的打印函数将输出接口参数的动态值的字面形式；
4. 调用内置的`print`/`println`函数不会使调用参数引用的值逃逸到堆上，而`fmt`和`log`标准库包中的打印函数将使调用参数引用的值逃逸到堆上；
5. 如果一个实参有`String() string`或`Error() string`方法，那么`fmt`和`log`标准库包里的打印函数在打印参数时会调用这两个方法，而内置的`print`/`println`函数则会忽略参数的这些方法；
6. 内置的`print`/`println`函数不保证在未来的Go版本中继续存在。



### copy

当一个实参被传递给对应的形参时，此实参必须能够赋值给此形参类型。如果内置函数`copy`和`append`的调用的第一个形参为一个字节切片，则第二个形参可以是一个字符串，即使字符串不能被赋给一个字节切片。

```go
	var bs = []byte{1, 2, 3}
	var s = "xyz"

	copy(bs, s)
	// 上一行是下一行的语法糖和优化。
	copy(bs, []byte(s))

	bs = append(bs, s...)
	// 上一行是下一行的语法糖和优化。
	bs = append(bs, []byte(s)...)
```



### append



## 特殊函数

### main函数



### init函数

在一个代码包甚至一个源文件中，可以声明若干名为`init`的函数，这些`init`函数必须不带任何输入参数和返回结果。不能声明名为`init`的包级变量、常量或者类型。程序运行在进入`main`入口函数之前，每个`init`函数在此包加载的时候将被（串行）执行并且只执行一遍。下面这个简单的程序中有两个`init`函数：

```go
package main

import "fmt"

func init() {
	fmt.Println("hi,", bob)
}

func main() {
	fmt.Println("bye")
}

func init() {
	fmt.Println("hello,", smith)
}

func titledName(who string) string {
	return "Mr. " + who
}

var bob, smith = titledName("Bob"), titledName("Smith")
```

此程序的运行结果：

```
hi, Mr. Bob
hello, Mr. Smith
bye
```



在加载一个代码包的过程中，所有的声明在此包中的`init`函数将被串行调用并且仅调用执行一次。一个代码包中声明的`init`函数的调用肯定晚于此代码包所依赖的代码包中声明的`init`函数。所有的`init`函数都将在调用`main`入口函数之前被调用执行。

在同一个源文件中声明的`init`函数将按从上到下的顺序被调用执行，对于声明在同一个包中的两个不同源文件中的两个`init`函数，Go语言白皮书推荐按照它们所处于的源文件的名称的词典序列（对英文来说，即字母顺序）来调用，所以最好不要让声明在同一个包中的两个不同源文件中的两个`init`函数存在依赖关系。

在加载一个代码包的时候，此代码包中声明的所有包级变量都将在此包中的任何一个`init`函数执行之前初始化完毕。



# Go 方法

## 方法声明

在Go中，可以为类型`T`和`*T`显式地声明一个方法（Method），其中类型`T`必须满足四个条件：

1. `T`必须是一个定义类型；
2. `T`必须和此方法声明定义在同一个代码包中；
3. `T`不能是一个指针类型；
4. `T`不能是一个接口类型；



方法名可以是空标识符`_`，一个类型可以拥有若干名称是空标识符的方法，但是这些方法无法被调用。只有导出的方法才可以在其它代码包中调用。类型`T`和`*T`称为它们各自的方法的属主类型（receiver type），类型`T`被称作为类型`T`和`*T`声明的所有方法的属主基类型（receiver base type）。也可以为满足上列条件的类型`T`和`*T`的别名声明方法，这样做的效果和直接为类型`T`和`*T`声明方法是一样的。如果为某个类型声明了一个方法，以后可以说此类型拥有此方法。

不能为下列类型（显式地）声明方法：

- 内置基本类型，比如`int`和`string`，因为这些类型声明在内置`builtin`标准包中，不能在标准包中声明方法；
- 接口类型；
- 除了满足上面条件的形如`*T`的指针类型之外的无名组合类型；



一个方法声明和一个函数声明很相似，但是比函数声明多了一个额外的参数声明部分，此额外的参数声明部分只能含有一个类型为此方法的属主类型的参数，此参数称为此方法声明的属主参数（receiver parameter）：

- 属主参数声明必须包裹在一对小括号`()`之中，且处于`func`关键字和方法名之间；
- 属主参数传参也是值传递的过程，该参数可以在函数体中作为局部变量使用；
- 属主参数包含参数名称和参数类型，参数名称在没有被函数体作为局部变量使用的场景下省略；



下面是一个方法声明的例子：

```go
// Age和int是两个不同的类型。我们不能为int和*int类型声明方法，但是可以为Age和*Age类型声明方法
type Age int
func (age Age) LargerThan(a Age) bool {
	return age > a
}
func (age *Age) Increase() {
	*age++
}

// 为自定义的函数类型FilterFunc声明方法。
type FilterFunc func(in int) bool
func (ff FilterFunc) Filte(in int) bool {
	return ff(in)
}

// 为自定义的映射类型StringSet声明方法。
type StringSet map[string]struct{}
func (ss StringSet) Has(key string) bool {
	_, present := ss[key]
	return present
}
func (ss StringSet) Add(key string) {
	ss[key] = struct{}{}
}
func (ss StringSet) Remove(key string) {
	delete(ss, key)
}

// 为自定义的结构体类型Book和它的指针类型*Book声明方法。
type Book struct {
	pages int
}

func (b Book) Pages() int {
	return b.pages
}

func (b *Book) SetPages(pages int) {
	b.pages = pages
}
```



从上面的例子可以看出可以为各种种类（kind）的类型声明方法，而不仅仅是结构体类型。在很多其它面向对象的编程语言中，属主参数名总是为隐式声明的`this`或者`self`，这样的名称不推荐在Go编程中使用。



### 指针类型属主和值类型属主

**指针类型的属主参数称为指针类型属主，非指针类型的属主参数称为值类型属主。**

在方法声明中使用指针类型属主不会产生任何逻辑问题，仅仅是为了程序效率考虑有时候才会在函数声明中使用值类型属主。对于值类型属主还是指针类型属主都可以接受的方法声明，下面列出了一些考虑因素：

- 太多的指针可能会增加垃圾回收器的负担；
- 如果一个值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略，指针类型都是小尺寸类型；
- 在并发场合下，同时调用值类型属主和指针类型属主方法比较易于产生数据竞争；
- `sync`标准库包中的类型的值不应该被复制，所以如果一个结构体类型内嵌了这些类型，则不应该为这个结构体类型声明值类型属主的方法；



如果实在拿不定主意在一个方法声明中应该使用值类型属主还是指针类型属主，那么请使用指针类型属主。



为类型`*T`显式声明的方法不是类型`T`的方法，但是可寻址的`T`值可以用做这些方法的调用的属主实参。

```go
func TestPointerMethodInvoke(t *testing.T) {
	// Book{3}.SetPages(1) // error: Cannot call a pointer method on 'Book{3}'

	var book = Book{3}
	book.SetPages(1) // 现在：t.x == 6
	(&book).SetPages(1) // 上一行本行的语法糖，现在：t.x == 12
}
```



### 方法对应隐式声明的函数

对每个方法声明，编译器将自动隐式声明一个相对应的函数，比如对于上一节的例子中为类型`Book`和`*Book`声明的两个方法，编译器将自动声明下面的两个函数：

```go
func Book.Pages(b Book) int {
	return b.pages // 此函数体和Book类型的Pages方法体一样
}

func (*Book).SetPages(b *Book, pages int) {
	b.pages = pages // 此函数体和*Book类型的SetPages方法体一样
}
```



在上面的两个隐式函数声明中，它们各自对应的方法声明的属主参数声明被插入到了普通参数声明的第一位，它们的函数体和各自对应的显式方法的方法体是一样的。两个隐式函数名`Book.Pages`和`(*Book).SetPages`都是`aType.MethodName`这种形式的。不能显式声明名称为这种形式的函数，因为这种形式中的函数名不属于合法标识符，这样的函数只能由编译器隐式声明，但是可以在代码中调用这些隐式声明的函数：

```go
func TestImplicitDeclarationMethodInvoke(t *testing.T) {
	var book Book
	// 调用这两个隐式声明的函数。
	(*Book).SetPages(&book, 123)
	fmt.Println(Book.Pages(book)) // 123
}
```



### 为指针类型属主隐式声明的方法

对每一个为值类型属主`T`声明的方法，一个相应的同名方法将自动隐式地为其对应的指针类型属主`*T`而声明。以上面的为类型`Book`声明的`Pages`方法为例，一个同名方法将自动为类型`*Book`而声明：

```go
// 注意：这不是合法的Go语法。这里这样表示只是为了解释目的。它表明表达式(&aBook).Pages将被估值为aBook.Pages。
func (b *Book) Pages = (*b).Pages
```



为一个非指针类型显式声明一个方法的时候，事实上两个方法被声明了，一个方法是为非指针类型显式声明的，另一个是为指针类型隐式声明的。每一个方法对应着一个编译器隐式声明的函数，所以对于刚提到的隐式方法，编译器也将隐式声明一个相应的函数。即对于每一个为值类型属主显式声明的方法，同时将有一个隐式方法和两个隐式函数被自动声明。

```go
func (*Book).Pages(b *Book) int {
	return Book.Pages(*b)
}
```



在Go语言中，为了方便，对于一个非指针和非接口类型`T`，

- 一个`T`类型的值可以调用为`*T`类型的方法，但是仅当此`T`的值是可寻址的情况下。编译器在调用指针属主方法前，会自动取此`T`值的地址。因为不是任何`T`值都是可寻址的，所以并非任何`T`值都能够调用为类型`*T`的方法。这种便利只是一个语法糖，而不是一种固有的规则。
- 一个`*T`类型的值可以调用为类型`T`的方法，这是因为解引用指针总是合法的。这种便利不仅仅是一个语法糖，它也是一种固有的规则。

所以`*T`的方法集总是`T`方法集的超集，但反之不然。可以认为对于每一个为类型`T`声明的方法，编译器都会为类型`*T`自动隐式声明一个同名和同签名的方法。

```go
func (t T) MethodX(v0 ParamType0, ...) (ResultType0, ...) {
	...
}

// 编译器将会为*T隐式声明一个如下的方法。
func (pt *T) MethodX(v0 ParamType0, ...) (ResultType0, ...) {
	return (*pt).MethodX(v0, ...)
}
```



## 方法描述

方法描述（method specification）可以看作是一个不带`func`关键字的函数原型，可以把每个方法声明看作是由一个`func`关键字、一个属主参数声明部分、一个方法描述和一个方法体组成。比如上面的例子中的`Pages`和`SetPages`的描述如下：

```go
Pages() int
SetPages(pages int)
```



## 方法集

每个类型都有个方法集（method set），一个非接口类型的方法集由所有为它声明的（不管是显式的还是隐式的，但不包含方法名为空标识符的）方法描述组成，方法集中的方法描述的次序并不重要。比如在上面的例子中，`Book`类型的方法集为：

```go
Pages() int
```



而`*Book`类型的方法集为：

```go
Pages() int
SetPages(pages int)
```



对于一个方法集，如果其中的每个方法描述都处于另一个方法集中，则说前者方法集为后者方法集的子集，后者为前者的超集。如果两个方法集互为子集或超集，则这两个方法集必等价。

给定一个类型`T`，假设它既不是一个指针类型也不是一个接口类型，因为上一节中提到的原因，类型`T`的方法集总是类型`*T`的方法集的子集。比如在上面的例子中，`Book`类型的方法集为`*Book`类型的方法集的子集。请注意：**不同代码包中的同名非导出方法将总被认为是不同名的。**下列类型的方法集总为空：

- 内置基本类型；
- 定义的指针类型；
- 基类型为指针类型或者接口类型的指针类型；
- 无名数组、切片、映射、函数和通道类型。



### 定义类型没有源类型的方法

在下面的代码中，定义类型`Age`并不像它的源类型`MyInt`一样拥有一个`IsOdd`方法。

```go
package main

type MyInt int
func (mi MyInt) IsOdd() bool {
	return mi%2 == 1
}

type Age MyInt

func main() {
	var x MyInt = 3
	_ = x.IsOdd() // okay
	
	var y Age = 36
	// _ = y.IsOdd() // error: y.IsOdd undefined
	_ = y
}
```



## 方法值



### 方法值的正规化

在编译阶段，编译器将正规化各个方法值表达式，简而言之，正规化就是将方法值表达式中的隐式取地址和解引用操作均转换为显式操作。

假设值`v`的类型为`T`，并且`v.m`是一个合法的方法值表达式，

- 如果`m`是一个为类型`*T`显式声明的方法，那么编译器将把它正规化`(&v).m`；
- 如果`m`是一个为类型`T`显式声明的方法，那么`v.m`已经是一个正规化的方法值表达式。

假设值`p`的类型为`*T`，并且`p.m`是一个合法的方法值表达式，

- 如果`m`是一个为类型`T`显式声明的方法，那么编译器将把它正规化`(*p).m`；
- 如果`m`是一个为类型`*T`显式声明的方法，那么`p.m`已经是一个正规化的方法值表达式。



### 方法值的估值

假设`v.m`是一个已经正规化的方法值表达式，在运行时刻，当`v.m`被估值的时候，属主实参`v`的估值结果的一个副本将被存储下来以供后面调用此方法值的时候使用。以下面的代码为例：

- `b.Pages`是一个已经正规化的方法值表达式。 在运行时刻对其进行估值时，属主实参`b`的一个副本将被存储下来。 此副本等于`b`的当前值：`Book{pages: 123}`，此后对`b`值的修改不影响此副本值。 这就是为什么调用`f1()`打印出`123`。
- 在编译时刻，方法值表达式`p.Pages`将被正规化为`(*p).Pages`。 在运行时刻，属主实参`*p`被估值为当前的`b`值，也就是`Book{pages: 123}`。 这就是为什么调用`f2()`也打印出`123`。
- `p.Pages2`是一个已经正规化的方法值表达式。 在运行时刻对其进行估值时，属主实参`p`的一个副本将被存储下来，此副本的值为`b`值的地址。 当`b`被修改后，此修改可以通过对此地址值解引用而反映出来，这就是为什么调用`g1()`打印出`789`。
- 在编译时刻，方法值表达式`b.Pages2`将被正规化为`(&b).Pages2`。 在运行时刻，属主实参`&b`的估值结果的一个副本将被存储下来，此副本的值为`b`值的地址。 这就是为什么调用`g2()`也打印出`789`。

```go
package main

import "fmt"

type Book struct {
	pages int
}

func (b Book) Pages() int {
	return b.pages
}

func (b *Book) Pages2() int {
	return (*b).Pages()
}

func main() {
	var b = Book{pages: 123}
	var p = &b
	var f1 = b.Pages
	var f2 = p.Pages
	var g1 = p.Pages2
	var g2 = b.Pages2
	b.pages = 789
	fmt.Println(f1()) // 123
	fmt.Println(f2()) // 123
	fmt.Println(g1()) // 789
	fmt.Println(g2()) // 789
}
```



## 方法调用

方法事实上是特殊的函数，方法也常被称为成员函数。当一个类型拥有一个方法，则此类型的每个值将拥有一个不可修改的函数类型的成员（类似于结构体的字段）。此成员的名称为此方法名，它的类型和此方法的声明中不包括属主部分的函数声明的类型一致，一个值的成员函数也可以称为此值的方法。

一个方法调用其实是调用了一个值的成员函数，假设一个值`v`有一个名为`m`的方法，则此方法可以用选择器语法形式`v.m`来表示。下面这个例子展示了如何调用为`Book`和`*Book`类型声明的方法：

```go
func main() {
	var book Book

	fmt.Printf("%T \n", book.Pages)       // func() int
	fmt.Printf("%T \n", (&book).SetPages) // func(int)
	// &book值有一个隐式方法Pages。
	fmt.Printf("%T \n", (&book).Pages)    // func() int

	// 调用这三个方法。
	(&book).SetPages(123)
	book.SetPages(123)           // 等价于上一行
	fmt.Println(book.Pages())    // 123
	fmt.Println((&book).Pages()) // 123
}
```



`(&book).SetPages(123)`可以被简化为`book.SetPages(123)`，这是Go中为了让代码看上去更简洁而特别设计的语法糖，此语法糖只对可寻址的值类型的属主有效，编译器会隐式地将`book.SetPages(123)`改写为`(&book).SetPages(123)`。但另一方面，应该总是认为`aBookExpression.SetPages`是一个合法的选择器（从语法层面讲），即使表达式`aBookExpression`被估值为一个不可寻址的`Book`值，在这种情况下，`aBookExpression.SetPages`是一个无效但合法的选择器。



如上面刚提到的，当为一个类型声明了一个方法后，每个此类型的值将拥有一个和此方法同名的成员函数。此类型的零值也不例外，不论此类型的零值是否用`nil`来表示。一个例子：

```go
type StringSet map[string]struct{}
func (ss StringSet) Has(key string) bool {
	_, present := ss[key] // 永不会产生恐慌，即使ss为nil。
	return present
}

type Age int
func (age *Age) IsNil() bool {
	return age == nil
}
func (age *Age) Increase() {
	*age++ // 如果age是一个空指针，则此行将产生一个恐慌。
}

func main() {
	_ = (StringSet(nil)).Has   // 不会产生恐慌
	_ = ((*Age)(nil)).IsNil    // 不会产生恐慌
	_ = ((*Age)(nil)).Increase // 不会产生恐慌

	_ = (StringSet(nil)).Has("key") // 不会产生恐慌
	_ = ((*Age)(nil)).IsNil()       // 不会产生恐慌

	// 下面这行将产生一个恐慌，但是此恐慌不是在调用方法的时候产生的，而是在此方法体内解引用空指针的时候产生的。
	((*Age)(nil)).Increase()
}
```



### 属主参数的传参是一个值复制过程

和普通参数传参一样，属主参数的传参也是一个值复制过程，所以在方法体内对属主参数的直接部分的修改将不会反映到方法体外。一个例子：

```go
type Book struct {
	pages int
}

func (b Book) SetPages(pages int) {
	b.pages = pages
}

func main() {
	var b Book
	b.SetPages(123)
	fmt.Println(b.pages) // 0
}
```



另一个例子：

```go
type Book struct {
	pages int
}

type Books []Book

func (books Books) Modify() {
	// 对属主参数的间接部分的修改将反映到方法之外。
	books[0].pages = 500
	// 对属主参数的直接部分的修改不会反映到方法之外。
	books = append(books, Book{789})
}

func main() {
	var books = Books{{123}, {456}}
	books.Modify()
	fmt.Println(books) // [{500} {456}]
}
```



如果将上例中`Modify`方法中的两行代码次序调换，那么此方法中的两处修改都不能反映到此方法之外。

```go
func (books Books) Modify() {
	books = append(books, Book{789})
	books[0].pages = 500
}

func main() {
	var books = Books{{123}, {456}}
	books.Modify()
	fmt.Println(books) // [{123} {456}]
}
```



这两处修改都不能反映到`Modify`方法之外的原因是`append`函数调用将开辟一块新的内存来存储它返回的结果切片的元素，而此结果切片的前两个元素是属主参数切片的元素的副本，对此副本所做的修改不会反映到`Modify`方法之外。为了将此两处修改反映到`Modify`方法之外，`Modify`方法的属主类型应该改为指针类型：

```go
func (books *Books) Modify() {
	*books = append(*books, Book{789})
	(*books)[0].pages = 500
}

func main() {
	var books = Books{{123}, {456}}
	books.Modify()
	fmt.Println(books) // [{500} {456} {789}]
}
```

