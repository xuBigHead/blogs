---
layout: post
title: MySQL 事务.md
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# MySQL 事务

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**

数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。数据库事务通常包含了一个序列的对数据库的读/写操作。包含有以下两个目的：

- 为数据库操作序列提供了一个**从失败中恢复到正常状态**的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
- 当多个应用程序在**并发访问数据库**时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

当事务被提交给了数据库管理系统（DBMS），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。



## 事务特性

### 原子性

**原子性**（`Atomicity`）：一个事务必须是一系列操作的最小单元，这系列操作的过程中，要么整个执行，要么整个回滚，不存在只执行了其中某一个或者某几个步骤。



### 一致性

**一致性**（`Consistency`）：事务要保证数据库整体数据的完整性和业务数据的一致性，事务成功提交整体数据修改，事务错误则回滚到数据回到原来的状态。



### 隔离性

**隔离性**（`Isolation`）：隔离性是说两个事务的执行都是独立隔离开来的，事务之前不会相互影响，多个事务操作一个对象时会以串行等待的方式保证事务相互之间是隔离的。



### 持久性

**持久性**（`Durability`）：持久性是指一旦事务成功提交后，只要修改的数据都会进行持久化（通常是指数据成功保存到磁盘），不会因为异常、宕机而造成数据错误或丢失。



### 实现ACID的方式

影响数据库ACID实现的因素有两个：并发和系统故障，相应地，数据库系统通过并发控制技术和日志恢复技术来实现数据库的ACID特性。

- **持久性是通过 redo log （重做日志）来保证的；**
- **原子性是通过 undo log（回滚日志） 来保证的；**
- **隔离性在可重复读隔离级别下是通过 MVCC（多版本并发控制），在串行化隔离级别下是通过锁来保证的；**
- **一致性则是通过持久性+原子性+隔离性来保证；**



#### 数据库的并发控制

并发控制技术是实现事务隔离性以及不同隔离级别的关键,实现方式有很多,按照其对可能冲突的操作采取的不同策略可以分为乐观并发控制和悲观并发控制两大类。

- 乐观并发控制:对于并发执行可能冲突的操作,假定其不会真的冲突,允许并发执行,直到真正发生冲突时才去解决冲突,比如让事务回滚。
- 悲观并发控制:对于并发执行可能冲突的操作,假定其必定发生冲突,通过让事务等待(锁)或者中止(时间戳排序)的方式使并行的操作串行执行。

其实现方式有多种： 基于封锁的并发控制、基于时间戳的并发控制、基于有效性检查的并发控制、基于快照隔离的并发控制。



#### 数据库的日志

数据库运行过程中可能会出现故障,这些故障包括事务故障和系统故障两大类

- 事务故障:比如非法输入,系统出现死锁,导致事务无法继续执行。
- 系统故障:比如由于软件漏洞或硬件错误导致系统崩溃或中止。

这些故障可能会对事务和数据库状态造成破坏,因而必须提供一种技术来对各种故障进行恢复,保证数据库一致性,事务的原子性以及持久性。数据库通常以日志的方式记录数据库的操作从而在故障时进行恢复,因而可以称之为日志恢复技术。数据库日志包含undo和redo日志。



## 异常场景

### 写-写异常

- **一类丢失更新**：两个事物读同一数据，一个修改字段1，一个修改字段2，后提交的恢复了先提交修改的字段。**事务A的事务回滚覆盖了事务B已提交的结果。**
- **二类丢失更新（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 **事务A的提交覆盖了事务B已提交的结果。**



### 读-写异常

- **脏读**（dirty read）是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- **不可重复读**（non-repeatable read）是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。
- **幻读**（phantom read）是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录或删除了记录，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样，这就是发生了幻读。

**不可重复读和脏读的区别**是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

幻读和不可重复读都是读取了另一条已经提交的事务，不同的是不可重复读的重点是修改，幻读的重点在于新增或者删除。



## 隔离级别

MySQL数据库为了解决上面提到的脏读、不可重复读、幻读这几个问题，提供了四种隔离级别：

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。





### 读未提交

读未提交(Read Uncommitted)指的是所有事务都可以看到其他未提交事务的执行结果。能够读取到其他事务中未提交的内容，存在脏读问题。

对于读未提交隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；



### 读已提交

读已提交(Read Committed)指的是一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。只能读取其他事务已经提交的内容，存在不可重复读问题。

对于读已提交隔离级别的事务来说，是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。读已提交隔离级别是在每个语句执行前都会重新生成一个 Read View，而可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。



> 在数据库的 **RC 这种隔离级别中，还支持"半一致读"** ，一条update语句，如果 where 条件匹配到的记录已经加锁，那么InnoDB会返回记录最近提交的版本，由MySQL上层判断此是否需要真的加锁。



### 可重复读

可重复读(Repeated Read)是MySQL的**默认事务隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。在读取某行后不允许其他事务操作此行，直到事务结束。MySQL通过加锁的方式，在一定层度上也解决了幻读的问题。

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)** 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED(读取提交内容)** ，但是你要知道的是InnoDB 存储引擎默认使用 **REPEAaTABLE-READ（可重读）** 并不会有任何性能损失。

**InnoDB 引擎的默认隔离级别虽然是可重复读，但是它通过next-key lock 锁（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。**



### 串行读

串行读(Serializable)指的是通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。一个事务的开始必须等待另一个事务的完成。对于串行化隔离级别的事务来说，通过加读写锁的方式来避免并行访问。



### 总结

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| 读未提交         | ✓    | ✓          | ✓    |
| 读已提交         | ×    | ✓          | ✓    |
| 可重复读（默认） | ×    | ×          | ✓    |
| 串行读           | ×    | ×          | ×    |



#### 读已提交和可重复读对比

RR 和 RC 两种事务隔离级别。他们主要在加锁机制、主从同步以及一致性读方面存在一些差异。**为了提升并发度和降低死锁发生的概率，会把数据库的隔离级别从默认的 RR 调整成 RC。**当然，这样做也不是完全没有问题，首先使用 RC 之后，就需要自己解决幻读的问题，这个其实还好，很多时候幻读问题其实是可以忽略的，或者可以用其他手段解决。

读已提交虽然每次都需要重新建立视图，但是建立视图没什么成本的，就是拷贝一个事务数组；所以对性能影响不大。

**RC 在加锁的过程中，是不需要添加Gap Lock和 Next-Key Lock 的，只对要修改的记录添加行级锁就行了。**这就使得并发度要比 RR 高很多。**因为 RC 还支持"半一致读"，可以大大的减少了更新语句时行锁的冲突；对于不满足更新条件的记录，可以提前释放锁，提升并发度。**

RR这种事务隔离级别会增加Gap Lock和 Next-Key Lock，这就使得锁的粒度变大，那么就会使得死锁的概率增大。可重复读还是使锁的生效时间更长，在事务结束时才释放锁。

使用 RC 的时候，不能使用statement格式的 binlog，这种影响其实可以忽略不计了，因为MySQL是在5.1.5版本开始支持row的、在5.1.8版本中开始支持mixed，后面这两种可以代替 statement格式。



## 长事务

### 风险

在使用时应该避免出现长事务，主要有以下原因：

- 长事务会因为要保证事务在执行期间的数据是一致的，所以会导致大量老的事务视图和undolog无法被删除，占用大量空间；
- 长事务会占用较多锁资源，降低系统性能，提高出现死锁的概率。



### 解决方案

为了避免和降低长事务对系统的影响，可以从以下几个方面入手：



#### 应用端解决方案

- 确认是否有不必要的只读事务，比如查询事务，就没必要多次使用begin-commit，避免浪费资源
- 查询set_autocommit是否为0，如果不是，就将set_antocommit设置为1，有些框架连接成功后，默认会将set_autocommit设置为0，所以要手动设置为0 
- 通过配置参数`max_execution_time`来控制每个语句执行的最长时间，避免单个语句意外执行太长时间
- 业务开发中尽量减少事务范围，避免长事务；



#### 数据库端解决方案

- 监控information_schema.innodb_trix表，设置长事务阈值，超过阈值就报警/或者kill
- 在业务功能测试阶段要求输出所有的 `general_log`，分析日志行为提前发现问题；
- 设置innodb_undo_tablespaces设置成2或更大的值，如果出现大事务导致回滚段过大，方便之后处理
- 增加undo表空间；
- 使用Percona 的 pt-kill 这个工具，推荐使用；



## 相关语法

### 设置隔离级别

设置当前会话隔离级别

```sql
set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
set session transaction isolation level repeatable read;
set session transaction isolation level serializable;
```



设置全局事务隔离级别

```sql
set global transaction isolation level read uncommitted;
```



### 事务启动

事务开启、提交和回滚：

```sql
# 开启事务
start transaction;
# 开启事务
begin;
# 立即开启事务并创建一致性视图
start transaction with consistent snapshot;

# 提交事务
commit;
# 提交事务并开启下一个事务，相当于commit + begin；节省了再一次执行begin语句的开销。
commit work and chain;

# 回滚事务
rollback;
```



注意，执行开始事务命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：

- begin/start transaction：执行该命令后并不代表事务启动了，只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；
- start transaction with consistent snapshot：马上启动事务。



## 相关参数

### transaction_isolation

```sql
mysql> show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)
```



`transaction_isolation`参数表示当前数据库的隔离级别。



### autocommit

```sql
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.02 sec)
```



`autocommit`参数表示是否自动提交事务。

- 为0时表示执行完更新语句后，不会自动提交事务，必须显示执行commit或rollback命令；
- 为1时表示执行完更新语句后会自动提交事务。



> 当autocommit设为0时，即使只是执行了一条select语句，也会创建事务，然后在information_schema.innodb_trx表中生成一条数据。此时如果一直没有提交，就会变成长事务。
>
> 可以通过如下语句查看：
>
> ```sql
> select * from information_schema.innodb_trx;
> ```



**设置autocommit值**

```sql
mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set (0.01 sec)

mysql> set autocommit=1;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)
```



### max_execution_time

```sql
mysql> show variables like 'max_execution_time';
+--------------------+-------+
| Variable_name      | Value |
+--------------------+-------+
| max_execution_time | 0     |
+--------------------+-------+
1 row in set (0.01 sec)
```



max_execution_time参数用于控制每个语句执行的最长时间。

# 其他
## TCL
### 概念

TCL（Transaction Control Language）事务控制语言。



### 语法

#### SAVEPOINT 设置保存点

#### ROLLBACK  回滚

#### SET TRANSACTION



#### 查看和设置

```sql
## 查看隔离级别
select @@transaction_isolation;
## 设置隔离级别
set session transaction isolation level read uncommitted;
set global transaction isolation level repeatable read;
```