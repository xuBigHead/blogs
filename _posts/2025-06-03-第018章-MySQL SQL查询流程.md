---
layout: post
title: 2025-06-03-第018章-MySQL SQL查询流程.md
categories: [MySQL]
description: 
keywords: MySQL SQL查询流程.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# MySQL SQL查询流程

## SQL查询流程

MySQL 可以分为 Server 层和存储引擎层两部分。

<img src="https://oss.xubighead.top/oss/image/202506/1929824945824698369.png" alt="img" style="zoom:25%;" />

### Server层

Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。



> 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。



#### 连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令如下：

```sh
# 参数 -p 后可以输入密码，但是这种方式会导致密码明文，有泄露风险。
mysql -h$ip -P$port -u$user -p
```



用户名密码认证失败时，会提示`Access denied for user`错误，客户端结束执行。

用户名密码认证通过后，连接器会到权限表里面查出你拥有的权限。之后这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。



可以通过 `show processlist` 命令来查看当前 `MySQL` 的所有链接状态。

```sql
mysql> show processlist;
+----+-----------------+-----------+------+---------+------+------------------------+------------------+
| Id | User            | Host      | db   | Command | Time | State                  | Info             |
+----+-----------------+-----------+------+---------+------+------------------------+------------------+
|  5 | event_scheduler | localhost | NULL | Daemon  |  101 | Waiting on empty queue | NULL             |
| 17 | root            | localhost | NULL | Query   |    0 | init                   | show processlist |
+----+-----------------+-----------+------+---------+------+------------------------+------------------+
2 rows in set (0.00 sec)
```



结果列说明：

- Id
- User：建立连接用户信息
- Host：建立连接用户IP信息
- db
- Command：连接类型
- State：连接状态
  - sleep：空闲连接
- Info：连接信息

  

一段时间没有操作后，建立的连接就处于空闲状态，`Command` 列此时会显示为 `Sleep` 值，表示该连接是一个空闲连接。**空闲连接会占用内存，因此空闲连接较多时会极其耗费资源，可以通过给空闲连接设置过期时间，或者设置代理层，由代理层来管理连接。**

连接指定时间内（由[wait_timeout](mysql-system_args.md#wait_timeout)设置）未操作时，连接器会自动断开连接。



##### 长连接和短连接

长连接指建立连接后在较长的一段时间内一直使用的连接；短连接与之相对，在较短时间后就断开的连接称之为短连接。

因为建立连接的过程比较占用资源，因此为了减少建立连接的过程，需要尽量使用长连接。长连接过多时又会导致占用内存太大，可能会被系统强制断开，表现为MySQL异常重启。此时可以通过如下几种方式管理和释放内存资源：

- 定期断开长连接，然后重新建立连接进行操作；
- 基于MySQL 5.7或更高的版本时，可以执行`mysql_reset_connection`来重新初始化连接，这个过程不需要重新建立连接和权限验证，将连接恢复到刚刚建立的状态；
- 使用数据库连接池来管理连接，如Druid数据库连接池。



> `mysql_reset_connection`是MySQL提供的API，不是SQL语句。



#### 查询缓存

> MySQL 8.0 已删除该模块

连接成功后，语句会同时传给缓存和分析器，如果能在缓存中匹配到该语句，则会直接返回，执行器里的该语句停止运行，如果缓存中没有匹配到，则分析器继续执行，到执行器才会真正被执行。MySQL的缓存是以key-value的形式存储在内存中，key为之前查询过的语句。查询语句如果命中查询缓存则直接返回，否则继续往下执行。

查询缓存往往是弊大于利，主要有以下几点问题：

- 缓存命中需要语句完全相等，包括参数；
- 对表的更新会导致所有针对该表数据的缓存失效；
- 需要花费资源进行缓存的维护。



可以通过使用 [query_cache_type](mysql-system_args.md#query_cache_type) 参数来设置是否开启缓存等配置。



#### 分析器

分析器对 SQL 查询语句进行词法分析和语法分析。

- 词法分析：识别语句中的表名、字段名等并校验其是否正确（从`information schema`里面获得表的结构信息进行校验），方便后续模块读取表名、字段、语句类型。
- 语法分析：检查语法是否有错误，然后构建语法树。



如果语句错误会返回 `You have an error in your SQL syntax` 错误提示：

```sql
mysql> selec * from student;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'selec * from student' at line 1
```



#### 优化器

优化器会基于查询成本的考虑，选择查询成本最小的执行计划。MySQL 会在优化器阶段里看下选择哪个索引，查询速度会更快。一般主要考虑几个因素，比如：

- 选择这个索引大概要扫描**多少行**（rows）；
- 为了把这些行取出来，需要读**多少个16kb的页**；
- 走普通索引需要回表，主键索引则不需要，**回表成本**是多少。



##### 索引选择

通过**索引的区分度**来判断走什么索引，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为**基数**，即区分度越高，基数越大。

索引系统是通过遍历部分数据，也就是通过**采样**的方式，来预测索引的基数的。**因此可能会由于统计的失误，导致系统没有走索引，而是走了全表扫描。**系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。



#### 执行器

**执行器**执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。

在开始执行时，会先判断当前连接的权限，是否能够查询指定的表或字段，如果没有就会返回没有权限的提示。

>  权限验证不仅仅在执行器这部分会做，在分析器之后，也会先做一次权限验证。叫做precheck。而precheck是无法对**运行时涉及到的表进行权限验证的，比如使用了触发器的情况**。因此在执行器这里也要做一次执行时的权限验证。



权限验证通过后，执行器就会根据表定义的存储引擎，去调用该存储引擎提供的接口实现。可以通过慢查询日志中的[row_examined](mysql-slow-query-log.md#row_examined)字段来查看SQL执行过程中扫描了多少行。



### 存储引擎

查询SQL到了InnoDB中。会根据前面优化器里计算得到的索引，去**查询相应的索引页**，如果不在buffer pool里则从磁盘里加载索引页。**再通过索引页加速查询，得到数据页**的具体位置。如果这些数据页不在buffer pool中，则从磁盘里加载进来。



## 连接查询流程

mysql中连接查询的原理是先对驱动表进行查询操作，然后再用从驱动表得到的数据作为条件，逐条的到被驱动表进行查询。

每次驱动表加载一条数据到内存中，然后被驱动表所有的数据都需要往内存中加载一遍进行比较。效率很低，所以mysql中可以指定一个缓冲池的大小，缓冲池大的话可以同时加载多条驱动表的数据进行比较，放的数据条数越多性能io操作就越少，性能也就越好。

如果此时使用`select *`放一些无用的列，只会白白的占用缓冲空间，浪费本可以提高性能的机会。



## SQL执行顺序

**MySQL执行顺序如下**：`FROM` > `ON` > `JOIN` > `WHERE` > `GROUP BY` > `HAVING` > `SELECT` > `DISTINCT` > `UNION` > `ORDER BY` > `OFFSET & LIMIT`。

- 先执行`FROM`，`JOIN`来确定要查询表的范围及表之间的连接关系，得到初步的数据；
- `WHERE`对数据进行普通的初步的筛选；
- `GROUP BY`对数据进行分组，此时不会筛选数据；
- 各组分别执行`HAVING`中的普通筛选或者聚合函数筛选，一般情况下有`HAVING`可以不写`WHERE`，把条件放到`HAVING`中；
- 然后再根据需要的数据进行`SELECT`，可以是普通字段查询也可以是获取聚合函数的查询结果，如果是聚合函数，`SELECT`的查询结果会新增一条字段；
- 将查询结果去重`DISTINCT`；
- 然后合并各组的查询结果，按照`ORDER BY`的条件进行排序；
- 最后从排序好的结果中，根据`OFFSET & LIMIT`取出指定位置指定行数的数据。



> 使用`WHERE`再`GROUP BY`和使用`GROUP BY`再``HAVING``几乎没有区别，不同的是，`HAVING`语法支持聚合函，`HAVING`的意思就是针对每组的条件进行筛选。普通的筛选条件是不影响的，但是`HAVING`还支持聚合函数，这是`WHERE`无法实现的。
