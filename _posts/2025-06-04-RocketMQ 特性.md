# 功能特性

## 事务消息

RocketMQ 4.3+提供分布事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致。



### 实现原理

![img](https://oss.xubighead.top/oss/image/202506/1930159770892865538.png)

**Half Message：**预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中

**检查事务状态：**Broker会开启一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，Broker会定时去回调在重新检查。

**超时：**如果超过回查次数，默认回滚消息。

也就是他并未真正进入Topic的queue，而是用了临时queue来放所谓的half message，等提交事务后才会真正的将half message转移到topic下的queue。



#### 免疫时间

在一个事务消息被发送后，对应事务的执行当然需要一定的执行时间，如果我们不设置这个时间立刻进行回查，那么很有可能时候事务还没执行完，对于大多数情况下还没执行完的事务进行回查，毫无疑问带来的收益很低。所以我们需要设定一个时间，在这个时间内的事务先暂时不回查，这个时间就叫做"免疫时间"。



### 实现流程

**1.Producer发送半消息（Half Message）到broker。**

- Half Message又叫预发送消息（prepare message），发送成功后开始执行本地事务。
- 如果本地事务执行成功的话则返回commit，如果执行失败则返回rollback。（这个是在事务消息的回调方法里由开发者自己决定commit or rollback）



Producer发送上一步的commit还是rollback到broker，这里有两种情况：

**1.如果broker收到了commit/rollback消息 ：**

- 如果收到了commit，则broker认为整个事务是没问题的，执行成功的。那么会下发消息给Consumer端消费。
- 如果收到了rollback，则broker认为本地事务执行失败了，broker将会删除Half Message，不下发给Consumer端。



**2.如果broker未收到消息（如果执行本地事务突然宕机了，相当本地事务执行结果返回unknow，则和broker未收到确认消息的情况一样处理。）：**

- broker会定时回查本地事务的执行结果：如果回查结果是本地事务已经执行则返回commit，若未执行，则返回rollback。
- Producer端回查的结果发送给Broker。Broker接收到的如果是commit，则broker视为整个事务执行成功，如果是rollback，则broker视为本地事务执行失败，broker删除Half Message，不下发给consumer。如果broker未接收到回查的结果（或者查到的是unknow），则broker会**定时进行重复回查**，以确保查到最终的事务结果。重复回查的时间间隔和次数都可配。



1、生产者向MQ服务器发送half消息。
2、half消息发送成功后，MQ服务器返回确认消息给生产者。
3、生产者开始执行本地事务。
4、根据本地事务执行的结果（`UNKNOW`、`commit`、`rollback`）向MQ Server发送提交或回滚消息。
5、如果错过了（可能因为网络异常、生产者突然宕机等导致的异常情况）提交/回滚消息，则MQ服务器将向同一组中的每个生产者发送回查消息以获取事务状态。
6、回查生产者本地事物状态。
7、生产者根据本地事务状态发送提交/回滚消息。
8、MQ服务器将丢弃回滚的消息，但已提交（进行过二次确认的half消息）的消息将投递给消费者进行消费。

`Half Message`：预处理消息，当broker收到此类消息后，会存储到`RMQ_SYS_TRANS_HALF_TOPIC`的消息消费队列中

`检查事务状态`：Broker会开启一个定时任务，消费`RMQ_SYS_TRANS_HALF_TOPIC`队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，Broker会定时去回调在重新检查。

超时：如果超过回查次数，默认回滚消息。
也就是他并未真正进入Topic的queue，而是用了临时queue来放所谓的`half message`，等提交事务后才会真正的将half message转移到topic下的queue。



1.producer(本例中指A系统)发送半消息到broker，这个半消息不是说消息内容不完整， 它包含完整的消息内容， 在producer端和普通消息的发送逻辑一致

2.broker存储半消息，半消息存储逻辑与普通消息一致，只是属性有所不同，topic是固定的RMQ_SYS_TRANS_HALF_TOPIC，queueId也是固定为0，这个tiopic中的消息对消费者是不可见的，所以里面的消息永远不会被消费。这就保证了在半消息提交成功之前，消费者是消费不到这个半消息的

3.broker端半消息存储成功并返回后，A系统执行本地事务，并根据本地事务的执行结果来决定半消息的提交状态为提交或者回滚

4.A系统发送结束半消息的请求，并带上提交状态(提交 or 回滚)

5.broker端收到请求后，首先从RMQ_SYS_TRANS_HALF_TOPIC的queue中查出该消息，设置为完成状态。如果消息状态为提交，则把半消息从RMQ_SYS_TRANS_HALF_TOPIC队列中复制到这个消息原始topic的queue中去(之后这条消息就能被正常消费了)；如果消息状态为回滚，则什么也不做。

6.producer发送的半消息结束请求是 oneway 的，也就是发送后就不管了，只靠这个是无法保证半消息一定被提交的，rocketMq提供了一个兜底方案，这个方案叫消息反查机制，Broker启动时，会启动一个TransactionalMessageCheckService 任务，该任务会定时从半消息队列中读出所有超时未完成的半消息，针对每条未完成的消息，Broker会给对应的Producer发送一个消息反查请求，根据反查结果来决定这个半消息是需要提交还是回滚，或者后面继续来反查

7.consumer(本例中指B系统)消费消息，执行本地数据变更(至于B是否能消费成功，消费失败是否重试，这属于正常消息消费需要考虑的问题)



### 源码解析

> 基于版本 5.0.1-SNAPSHOT



#### 发送消息

在设置好了事务监听器后（执行事务 与 事务回查），就可以发送事务消息。



> org.apache.rocketmq.client.producer.TransactionMQProducer

```java
@Override
public TransactionSendResult sendMessageInTransaction(final Message msg,
                                                      final Object arg) throws MQClientException {
    if (null == this.transactionListener) {
        throw new MQClientException("TransactionListener is null", null);
    }

    msg.setTopic(NamespaceUtil.wrapNamespace(this.getNamespace(), msg.getTopic()));
    return this.defaultMQProducerImpl.sendMessageInTransaction(msg, null, arg);
}
```



> org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl

```java
public TransactionSendResult sendMessageInTransaction(final Message msg,
                                                      final LocalTransactionExecuter localTransactionExecuter, final Object arg)
    throws MQClientException {
    // 如果没有设置事务监听器，此处就会抛异常
    TransactionListener transactionListener = getCheckListener();
    if (null == localTransactionExecuter && null == transactionListener) {
        throw new MQClientException("tranExecutor is null", null);
    }

    // 忽略延迟队列参数
    if (msg.getDelayTimeLevel() != 0) {
        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);
    }

    Validators.checkMessage(msg, this.defaultMQProducer);

    SendResult sendResult = null;
    // 为消息添加事务消息的标识
    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, "true");
    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());
    try {
        // 然后将该事务消息会像普通的同步消息一样发送（且是同步发送）
        sendResult = this.send(msg);
    } catch (Exception e) {
        throw new MQClientException("send message Exception", e);
    }
	// ...
}
```



#### 接收消息

在 Broker 端接收到消息以后，会走与普通消息相同的底层通道（因为这个消息本身就只是个加上了 事务flag 的普通消息），然后由 `TransactionalMessageService` 来对这个消息进行额外处理。

首先会对该消息放入 `real topic` 属性和 `real queue` 属性，然后将消息 Topic 替换为用于处理所有事务消息的特殊的 Topic，当然该 Topic 对消费者是不可见的。

> org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl

```java
@Override
public PutMessageResult prepareMessage(MessageExtBrokerInner messageInner) {
    return transactionalMessageBridge.putHalfMessage(messageInner);
}
```



> org.apache.rocketmq.broker.transaction.queue.TransactionalMessageBridge

```java
public PutMessageResult putHalfMessage(MessageExtBrokerInner messageInner) {
    return store.putMessage(parseHalfMessageInner(messageInner));
}

private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) {
    String uniqId = msgInner.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);
    if (uniqId != null && !uniqId.isEmpty()) {
        MessageAccessor.putProperty(msgInner, TransactionalMessageUtil.TRANSACTION_ID, uniqId);
    }
    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());
    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,
                                String.valueOf(msgInner.getQueueId()));
    // 设置标记为未收到结果
    msgInner.setSysFlag(
        MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));
    // 替换到特殊的 Topic (RMQ_SYS_TRANS_HALF_TOPIC)
    msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());
    msgInner.setQueueId(0);
    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));
    return msgInner;
}
```

完成后，会送到 MessageStore 像普通消息一样处理。



#### 发送事务结果

> org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl

```java
public TransactionSendResult sendMessageInTransaction(final Message msg,
                                                      final LocalTransactionExecuter localTransactionExecuter,
                                                      final Object arg){
    // ...
    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;
    Throwable localException = null;
    switch (sendResult.getSendStatus()) {
        case SEND_OK: {
            try {
                if (sendResult.getTransactionId() != null) {
                    msg.putUserProperty("__transactionId__", sendResult.getTransactionId());
                }
                String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);
                if (null != transactionId && !"".equals(transactionId)) {
                    msg.setTransactionId(transactionId);
                }
                if (null != localTransactionExecuter) {
                    localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);
                } else if (transactionListener != null) {
                    log.debug("Used new transaction API");
                    // 执行本地事务，更新事务获取状态
                    localTransactionState = transactionListener.executeLocalTransaction(msg, arg);
                }
                if (null == localTransactionState) {
                    localTransactionState = LocalTransactionState.UNKNOW;
                }

                if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
                    log.info("executeLocalTransactionBranch return: {}");
                }
            } catch (Throwable e) {

                localException = e;
            }
        }
            break;
        case FLUSH_DISK_TIMEOUT:
        case FLUSH_SLAVE_TIMEOUT:
        case SLAVE_NOT_AVAILABLE:
            localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;
            break;
        default:
            break;
    }

    try {
        // 然后对本地的事务执行状态进行处理，也就是将该执行状态上报
        this.endTransaction(msg, sendResult, localTransactionState, localException);
    } 
    // ...
    TransactionSendResult transactionSendResult = new TransactionSendResult();
    transactionSendResult.setSendStatus(sendResult.getSendStatus());
    transactionSendResult.setMessageQueue(sendResult.getMessageQueue());
    transactionSendResult.setMsgId(sendResult.getMsgId());
    transactionSendResult.setQueueOffset(sendResult.getQueueOffset());
    transactionSendResult.setTransactionId(sendResult.getTransactionId());
    transactionSendResult.setLocalTransactionState(localTransactionState);
    return transactionSendResult;
}

public void endTransaction(
    final Message msg,
    final SendResult sendResult,
    final LocalTransactionState localTransactionState,
    final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException {
    final MessageId id;
    if (sendResult.getOffsetMsgId() != null) {
        id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());
    } else {
        id = MessageDecoder.decodeMessageId(sendResult.getMsgId());
    }
    String transactionId = sendResult.getTransactionId();
    final String destBrokerName = this.mQClientFactory.getBrokerNameFromMessageQueue(defaultMQProducer.queueWithNamespace(sendResult.getMessageQueue()));
    final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(destBrokerName);
    EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();
    requestHeader.setTransactionId(transactionId);
    requestHeader.setCommitLogOffset(id.getOffset());
    requestHeader.setBname(destBrokerName);
    switch (localTransactionState) {
        case COMMIT_MESSAGE:
            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);
            break;
        case ROLLBACK_MESSAGE:
            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);
            break;
        case UNKNOW:
            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);
            break;
        default:
            break;
    }

    doExecuteEndTransactionHook(msg, sendResult.getMsgId(), brokerAddr, localTransactionState, false);
    requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());
    requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());
    requestHeader.setMsgId(sendResult.getMsgId());
    String remark = localException != null ? ("executeLocalTransactionBranch exception: " + localException.toString()) : null;
    this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,
                                                                   this.defaultMQProducer.getSendMsgTimeout());
}
```



这里会发送一条 oneway 命令给 Broker 端，且使用的是 `RequestCode.END_TRANSACTION` 请求码。完成处理后，该方法会将事务的发送结果和本地事务的执行结构都返回给上层 API。



> org.apache.rocketmq.client.impl.MQClientAPIImpl

```java
public void endTransactionOneway(
    final String addr,
    final EndTransactionRequestHeader requestHeader,
    final String remark,
    final long timeoutMillis
) throws RemotingException, InterruptedException {
    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.END_TRANSACTION, requestHeader);

    request.setRemark(remark);
    this.remotingClient.invokeOneway(addr, request, timeoutMillis);
}
```



#### 处理事务消息

在 Broker 端，这里会由 `EndTransactionProcessor` 处理器来处理该请求码，然后根据事务的执行结果来做不同的处理。

> org.apache.rocketmq.broker.processor.EndTransactionProcessor

```java
@Override
public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws
    RemotingCommandException {
    final RemotingCommand response = RemotingCommand.createResponseCommand(null);
    final EndTransactionRequestHeader requestHeader =
        (EndTransactionRequestHeader) request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);
    LOGGER.debug("Transaction request:{}", requestHeader);
    if (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) {
        response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);
        LOGGER.warn("Message store is slave mode, so end transaction is forbidden. ");
        return response;
    }

    if (requestHeader.getFromTransactionCheck()) {
        switch (requestHeader.getCommitOrRollback()) {
            case MessageSysFlag.TRANSACTION_NOT_TYPE: {                
                return null;
            }
            case MessageSysFlag.TRANSACTION_COMMIT_TYPE: {
                break;
            }
            case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: {
                break;
            }
            default:
                return null;
        }
    } else {
        switch (requestHeader.getCommitOrRollback()) {
            case MessageSysFlag.TRANSACTION_NOT_TYPE: {
                return null;
            }
            case MessageSysFlag.TRANSACTION_COMMIT_TYPE: {
                break;
            }
            case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: {
                break;
            }
            default:
                return null;
        }
    }
    OperationResult result = new OperationResult();
    if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) {
        // ...
    } else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) {
        // ...
    }
    response.setCode(result.getResponseCode());
    response.setRemark(result.getResponseRemark());
    return response;
}
```



> org.apache.rocketmq.broker.processor.EndTransactionProcessor

```java
if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) {
    // 事务执行成功，尝试完成事务，获取 half 消息
    result = this.brokerController.getTransactionalMessageService().commitMessage(requestHeader);
    if (result.getResponseCode() == ResponseCode.SUCCESS) {
        RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
        if (res.getCode() == ResponseCode.SUCCESS) {
            MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());
            msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));
            msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());
            msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());
            msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());
            MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TRANSACTION_PREPARED);
            // 将 half 消息取出，构造真实消息，然后投入实际上的 Topic
            RemotingCommand sendResult = sendFinalMessage(msgInner);
            if (sendResult.getCode() == ResponseCode.SUCCESS) {
                // 找到半消息，进行删除，
                // 删除并不是物理上的删除,因为物理上的删除的代价十分的高昂,而是写入一条具有相同事务id的消息到 op Topic
                this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());
            }
            return sendResult;
        }
        return res;
    }
}
```



如果需要回滚，则对相应的半消息进行删除，且和上面一样，并不是物理上的删除，而是发送具有相同事务 id 的消息到 OP Topic，来标记这个事务已经完成了(Commit/Rollback)， OP Topic 也是一个特殊的 Topic，同样对消费者不可见。当这些都做完后，一次事务就完成了。



> org.apache.rocketmq.broker.processor.EndTransactionProcessor

```java
if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) {
    result = this.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);
    if (result.getResponseCode() == ResponseCode.SUCCESS) {
        RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
        if (res.getCode() == ResponseCode.SUCCESS) {
            this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());
        }
        return res;
    }
}
```



#### 补偿逻辑

在一段时间后，如果客户端没有对事务的状态进行上报（或者上报的状态不是 Commit 或 Rollback，而是 Unknown）， Broker 端当然就要进行事务状态的回查。

在 `BrokerController` 启动的时候，会开启事务状态检测服务，该服务会通过循环调用 `TransactionalMessageServiceImpl.check()` 方法，不断的扫描未结束的事务，同时对超过指定时间还不知道状态的事务进行回查操作。`check() `方法是事务回查的核心。



##### 获取事务消息

> org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl

```java
@Override
public void check(long transactionTimeout, int transactionCheckMax,
                  AbstractTransactionalMessageCheckListener listener) {
    try {
        // 首先找到存储所有 half 消息的 Topic
        String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;
        Set<MessageQueue> msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);
        // ...
        // 对其中每一个 queue 进行检查
        for (MessageQueue messageQueue : msgQueues) {
            long startTime = System.currentTimeMillis();
            // 获得对应的 op 消息所在的 queue
            MessageQueue opQueue = getOpQueue(messageQueue);
            // 获取未处理的 half 消息的起始偏移量
            long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);
            // 获取 op 消息的 queue 的起始偏移量
            long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);
            if (halfOffset < 0 || opOffset < 0) {
                continue;
            }
			// 用来记录已经被处理了的 op 消息的偏移量
            List<Long> doneOpOffset = new ArrayList<>();
            // 用来记录已经完成了的 half 消息的偏移量
            HashMap<Long, Long> removeMap = new HashMap<>();
            HashMap<Long, HashSet<Long>> opMsgMap = new HashMap<Long, HashSet<Long>>();
            PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, opMsgMap, doneOpOffset);
            // ...
        }
    }
}
```



在 `fillOpRemoveMap` 方法中，主要是将 op 消息取出，来标记可以被移除的 half 消息（**op 消息的存在代表对应事务的结束**）。



> org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl

```java
/**
 * 读取op消息，解析op消息，填充removeMap
 *
 * @param removeMap 要删除的半消息，key: halfOffset，value: opOffset
 * @param opQueue Op message queue.
 * @param pullOffsetOfOp op message queue 的起始偏移量
 * @param miniOffset half message queue 的当前最小偏移量
 * @param doneOpOffset 存储已处理的 op 消息
 * @return 获取到的 Op 消息
 */
private PullResult fillOpRemoveMap(HashMap<Long, Long> removeMap, MessageQueue opQueue,
                                   long pullOffsetOfOp, long miniOffset, Map<Long, HashSet<Long>> opMsgMap, List<Long> doneOpOffset) {
    // 首先通过 queue 获取 op 消息，最大数量为 32 条
    PullResult pullResult = pullOpMsg(opQueue, pullOffsetOfOp, OP_MSG_PULL_NUMS);
    if (null == pullResult) {
        // 消息的意外状态的处理
        return null;
    }
    if (pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL
        || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) {
        transactionalMessageBridge.updateConsumeOffset(opQueue, pullResult.getNextBeginOffset());
        return pullResult;
    } else if (pullResult.getPullStatus() == PullStatus.NO_NEW_MSG) {
        return pullResult;
    }
    List<MessageExt> opMsg = pullResult.getMsgFoundList();
    if (opMsg == null) {
        return pullResult;
    }
    for (MessageExt opMessageExt : opMsg) {
        if (opMessageExt.getBody() == null) {
            doneOpOffset.add(opMessageExt.getQueueOffset());
            continue;
        }
        HashSet<Long> set = new HashSet<Long>();
        // op 消息的 body 存储的是对应的 half 消息的偏移量, 现在将其取出
        String queueOffsetBody = new String(opMessageExt.getBody(), TransactionalMessageUtil.CHARSET);
        if (TransactionalMessageUtil.REMOVE_TAG.equals(opMessageExt.getTags())) {
            String[] offsetArray = queueOffsetBody.split(TransactionalMessageUtil.OFFSET_SEPARATOR);
            for (String offset : offsetArray) {
                Long offsetValue = getLong(offset);                
                if (offsetValue < miniOffset) {
                    continue;
                }
				// 否则放入需要移除的 half 的消息的集合
                removeMap.put(offsetValue, opMessageExt.getQueueOffset());
                set.add(offsetValue);
            }
        } else {
            log.error("Found a illegal tag in opMessageExt= {} ", opMessageExt);
        }

        if (set.size() > 0) {
            opMsgMap.put(opMessageExt.getQueueOffset(), set);
        } else {
            // 在 已处理偏移量 之前的话则可直接放入 已处理偏移量集合
            doneOpOffset.add(opMessageExt.getQueueOffset());
        }
    }

    log.debug("Remove map: {}", removeMap);
    log.debug("Done op list: {}", doneOpOffset);
    log.debug("opMsg map: {}", opMsgMap);
    return pullResult;
}
```



##### 整理事务消息

对于已经被标记结束的事务的处理、和未结束事务的补足。



> org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl

```java
@Override
public void check(long transactionTimeout, int transactionCheckMax,
                  AbstractTransactionalMessageCheckListener listener) {
    // ...
    while (true) {
        if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) {
            log.info("Queue={} process time reach max={}", messageQueue, MAX_PROCESS_TIME_LIMIT);
            break;
        }
        // 推进最小已处理偏移量，
        if (removeMap.containsKey(i)) {
            // 如果该 half 消息存在对应的 op 消息，说明已经被处理了(commit/rollback)，取出放入到已处理偏移量队列
            Long removedOpOffset = removeMap.remove(i);
            opMsgMap.get(removedOpOffset).remove(i);
            if (opMsgMap.get(removedOpOffset).size() == 0) {
                opMsgMap.remove(removedOpOffset);
                doneOpOffset.add(removedOpOffset);
            }
        } else {
            // 否则说明当前 half 消息悬而未决， 取出对应的半消息
            GetResult getResult = getHalfMsg(messageQueue, i);
            MessageExt msgExt = getResult.getMsg();
            // 半消息不存在时的意外处理
            if (msgExt == null) {
                if (getMessageNullCount++ > MAX_RETRY_COUNT_WHEN_HALF_NULL) {
                    break;
                }
                if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {
                    break;
                } else {
                    i = getResult.getPullResult().getNextBeginOffset();
                    newOffset = i;
                    continue;
                }
            }

            if (this.transactionalMessageBridge.getBrokerController().getBrokerConfig().isEnableSlaveActingMaster()
                && this.transactionalMessageBridge.getBrokerController().getMinBrokerIdInGroup()
                == this.transactionalMessageBridge.getBrokerController().getBrokerIdentity().getBrokerId()
                && BrokerRole.SLAVE.equals(this.transactionalMessageBridge.getBrokerController().getMessageStoreConfig().getBrokerRole())
               ) {
                final MessageExtBrokerInner msgInner = this.transactionalMessageBridge.renewHalfMessageInner(msgExt);
                final boolean isSuccess = this.transactionalMessageBridge.escapeMessage(msgInner);

                if (isSuccess) {
                    escapeFailCnt = 0;
                    newOffset = i + 1;
                    i++;
                } else {
                    if (escapeFailCnt < MAX_RETRY_TIMES_FOR_ESCAPE) {
                        escapeFailCnt++;
                        Thread.sleep(100L * (2 ^ escapeFailCnt));
                    } else {
                        escapeFailCnt = 0;
                        newOffset = i + 1;
                        i++;
                    }
                }
                continue;
            }
            /*
         * 检测是否要丢弃或跳过
         * 丢弃条件: 当前事务已经超过了最大回查次数(15次)
         * 跳过条件: 已经超过了过期文件最大保留时间(72小时)
         */
            if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {
                // 处理并推进偏移量，具体的处理方法是: 投入 TRANS_CHECK_MAX_TIME_TOPIC 这个 Topic，等待手动处理
                listener.resolveDiscardMsg(msgExt);
                // 进入到下一个 half 消息
                newOffset = i + 1;
                i++;
                continue;
            }
            if (msgExt.getStoreTimestamp() >= startTime) {
                break;
            }
            // ...
        }
    }
    // ...
}
```



> org.apache.rocketmq.broker.transaction.queue.DefaultTransactionalMessageCheckListener

```java
@Override
public void resolveDiscardMsg(MessageExt msgExt) {
    log.error("MsgExt:{} has been checked too many times, so discard it by moving it to system topic TRANS_CHECK_MAXTIME_TOPIC", msgExt);

    try {
        MessageExtBrokerInner brokerInner = toMessageExtBrokerInner(msgExt);
        PutMessageResult putMessageResult = this.getBrokerController().getMessageStore().putMessage(brokerInner);
        if (putMessageResult != null && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) {
            log.info("Put checked-too-many-time half message to TRANS_CHECK_MAXTIME_TOPIC OK. Restored in queueOffset={}, " +
                     "commitLogOffset={}, real topic={}", msgExt.getQueueOffset(), msgExt.getCommitLogOffset(), msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC));
        } else {
            log.error("Put checked-too-many-time half message to TRANS_CHECK_MAXTIME_TOPIC failed, real topic={}, msgId={}", msgExt.getTopic(), msgExt.getMsgId());
        }
    } catch (Exception e) {
        log.warn("Put checked-too-many-time message to TRANS_CHECK_MAXTIME_TOPIC error. {}", e);
    }

}
```



##### 发送事务回查

对未结束事务的补足，与进行可能的回查操作。下面这段代码主要围绕 "是否进行回查" 展开，且涉及到 "免疫时间"。

然后再来看下需要进行回查的三种情况：

1. 当 op 消息的集合为空，说明当前还没有收到让当前事务结束的通知，且超过了"免疫时间"，故回查；
2. 当前 op 消息最大偏移量的生成时间超过了"免疫时间"，说明该事务的提交消息可能丢失了，故回查；
3. 不启用 "免疫时间"。



> org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl

```java
@Override
public void check(long transactionTimeout, int transactionCheckMax,
                  AbstractTransactionalMessageCheckListener listener) {
    // ...
    while (true) {
        // ...
        if (removeMap.containsKey(i)) {
            // ...
        } else {
            // ...
            // // half 消息具有最小的检查时间(免疫时间), 检测时间以内可以跳过回查, 重新投入 half 消息的 Topic
            long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();
            long checkImmunityTime = transactionTimeout;
            String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);
            if (null != checkImmunityTimeStr) {
                checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);
                if (valueOfCurrentMinusBorn < checkImmunityTime) {
                    if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt, checkImmunityTimeStr)) {
                        newOffset = i + 1;
                        i++;
                        continue;
                    }
                }
            } else {
                if (0 <= valueOfCurrentMinusBorn && valueOfCurrentMinusBorn < checkImmunityTime) {
                    break;
                }
            }

            /*
         * 对于当前事务的回查操作，需要满足三个条件之一
         *  1.当前 op 消息的集合为空，且已经超过了最小检查时间(免疫时间)
         *  2.最大偏移量的 op 消息的生成时间 已经超过了 最小检查时间
         *  3.关闭最小检查时间
         */
            List<MessageExt> opMsg = pullResult == null ? null : pullResult.getMsgFoundList();
            boolean isNeedCheck = opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime
                || opMsg != null && opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout
                || valueOfCurrentMinusBorn <= -1;

            if (isNeedCheck) {
                // 先将当前 half 消息放回
                if (!putBackHalfMsgQueue(msgExt, i)) {
                    continue;
                }
                putInQueueCount++;
                // 然后向 Product 发送检测消息
                listener.resolveHalfMsg(msgExt);
            } else {
                nextOpOffset = pullResult != null ? pullResult.getNextBeginOffset() : nextOpOffset;
                // 否则更新 op 消息集合,以确保能够断言该 half 消息的状态
                pullResult = fillOpRemoveMap(removeMap, opQueue, nextOpOffset,
                                             halfOffset, opMsgMap, doneOpOffset);
                if (pullResult == null || pullResult.getPullStatus() == PullStatus.NO_NEW_MSG
                    || pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL
                    || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) {

                    try {
                        Thread.sleep(SLEEP_WHILE_NO_OP);
                    } catch (Throwable ignored) {
                    }

                } else {

                }
                continue;
            }
        }
        newOffset = i + 1;
        i++;
    }
    // ...
}

private boolean putBackHalfMsgQueue(MessageExt msgExt, long offset) {
    PutMessageResult putMessageResult = putBackToHalfQueueReturnResult(msgExt);
    if (putMessageResult != null
        && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) {
        msgExt.setQueueOffset(
            putMessageResult.getAppendMessageResult().getLogicsOffset());
        msgExt.setCommitLogOffset(
            putMessageResult.getAppendMessageResult().getWroteOffset());
        msgExt.setMsgId(putMessageResult.getAppendMessageResult().getMsgId());
        return true;
    } else {
        return false;
    }
}
```



回查事务状态

> org.apache.rocketmq.broker.transaction.AbstractTransactionalMessageCheckListener

```java
public void resolveHalfMsg(final MessageExt msgExt) {
    if (executorService != null) {
        executorService.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    sendCheckMessage(msgExt);
                } catch (Exception e) {
                    LOGGER.error("Send check message error!", e);
                }
            }
        });
    } else {
        LOGGER.error("TransactionalMessageCheckListener not init");
    }
}

public void sendCheckMessage(MessageExt msgExt) throws Exception {
    CheckTransactionStateRequestHeader checkTransactionStateRequestHeader = new CheckTransactionStateRequestHeader();
    checkTransactionStateRequestHeader.setCommitLogOffset(msgExt.getCommitLogOffset());
    checkTransactionStateRequestHeader.setOffsetMsgId(msgExt.getMsgId());
    checkTransactionStateRequestHeader.setMsgId(msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));
    checkTransactionStateRequestHeader.setTransactionId(checkTransactionStateRequestHeader.getMsgId());
    checkTransactionStateRequestHeader.setTranStateTableOffset(msgExt.getQueueOffset());
    checkTransactionStateRequestHeader.setBname(brokerController.getBrokerConfig().getBrokerName());
    msgExt.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC));
    msgExt.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID)));
    msgExt.setStoreSize(0);
    String groupId = msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);
    Channel channel = brokerController.getProducerManager().getAvailableChannel(groupId);
    if (channel != null) {
        brokerController.getBroker2Client().checkProducerTransactionState(groupId, channel, checkTransactionStateRequestHeader, msgExt);
    } else {
        LOGGER.warn("Check transaction failed, channel is null. groupId={}", groupId);
    }
}
```



其中发送的回查消息的请求码为 `RequestCode.CHECK_TRANSACTION_STATE` ，发送的也是 oneway 消息。



> org.apache.rocketmq.broker.client.net.Broker2Client

```java
public void checkProducerTransactionState(
    final String group,
    final Channel channel,
    final CheckTransactionStateRequestHeader requestHeader,
    final MessageExt messageExt) throws Exception {
    RemotingCommand request =
        RemotingCommand.createRequestCommand(RequestCode.CHECK_TRANSACTION_STATE, requestHeader);
    request.setBody(MessageDecoder.encode(messageExt, false));
    try {
        this.brokerController.getRemotingServer().invokeOneway(channel, request, 10);
    } catch (Exception e) {
    }
}
```



##### 客户端事务回查

> org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl

```java
@Override
public void check(long transactionTimeout, int transactionCheckMax,
                  AbstractTransactionalMessageCheckListener listener) {
    // ...
    // 对所有的 half 消息计算完成后，更新偏移量
    if (newOffset != halfOffset) {
        transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);
    }
    // 根据已经被标记为完成的 op 消息更新偏移量
    long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);
    if (newOpOffset != opOffset) {
        // 如果不等，说明并不是所有的 op 消息都被标记为完成了
  		// 所以我们只将偏移量更新到第一个未完成的 op 消息的位置，其后面的 op 消息会在下次重复处理
        transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);
    }
    // ...
}
```



在 Producer 这边，将由 `ClientRemotingProcessor.checkTransactionState()` 来处理回查操作。



> org.apache.rocketmq.client.impl.ClientRemotingProcessor

```java
public RemotingCommand checkTransactionState(ChannelHandlerContext ctx,
                                             RemotingCommand request) throws RemotingCommandException {
    final CheckTransactionStateRequestHeader requestHeader =
        (CheckTransactionStateRequestHeader) request.decodeCommandCustomHeader(CheckTransactionStateRequestHeader.class);
    final ByteBuffer byteBuffer = ByteBuffer.wrap(request.getBody());
    final MessageExt messageExt = MessageDecoder.decode(byteBuffer);
    if (messageExt != null) {
        if (StringUtils.isNotEmpty(this.mqClientFactory.getClientConfig().getNamespace())) {
            messageExt.setTopic(NamespaceUtil
                                .withoutNamespace(messageExt.getTopic(), this.mqClientFactory.getClientConfig().getNamespace()));
        }
        // 获取事务 ID
        String transactionId = messageExt.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);
        if (null != transactionId && !"".equals(transactionId)) {
            messageExt.setTransactionId(transactionId);
        }
        final String group = messageExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);
        if (group != null) {
            // 从 MQClientFactory 找到注册的对应 Producer
            MQProducerInner producer = this.mqClientFactory.selectProducer(group);
            if (producer != null) {
                final String addr = RemotingHelper.parseChannelRemoteAddr(ctx.channel());
                // 让 Producer 检查在对应 IP 上的事务状态
                producer.checkTransactionState(addr, messageExt, requestHeader);
            } else {
                logger.debug("checkTransactionState, pick producer by group[{}] failed", group);
            }
        } else {
            logger.warn("checkTransactionState, pick producer group failed");
        }
    } else {
        logger.warn("checkTransactionState, decode message failed");
    }

    return null;
}
```



最后发回的方法做的事情和在一开始发送事务状态的方法，所做的事情是一样的。Broker 做的处理也是一样的。至此，补偿流程就执行完了。



> org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl

```java
@Override
public void checkTransactionState(final String addr, final MessageExt msg,
                                  final CheckTransactionStateRequestHeader header) {
    Runnable request = new Runnable() {
        private final String brokerAddr = addr;
        private final MessageExt message = msg;
        private final CheckTransactionStateRequestHeader checkRequestHeader = header;
        private final String group = DefaultMQProducerImpl.this.defaultMQProducer.getProducerGroup();

        @Override
        public void run() {
            TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.this.checkListener();
            // 取出当前 Producer 的事务监听器
            TransactionListener transactionListener = getCheckListener();
            if (transactionCheckListener != null || transactionListener != null) {
                LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;
                Throwable exception = null;
                try {
                    if (transactionCheckListener != null) {
                        localTransactionState = transactionCheckListener.checkLocalTransactionState(message);
                    } else {
                        log.debug("TransactionCheckListener is null, used new check API, producerGroup={}", group);
                        // 调用其的事务回查方法
                        localTransactionState = transactionListener.checkLocalTransaction(message);
                    }
                } catch (Throwable e) {
                    log.error("Broker call checkTransactionState, but checkLocalTransactionState exception", e);
                    exception = e;
                }
				// 再将事务执行结果其发回给 Broker
                this.processTransactionState(
                    localTransactionState,
                    group,
                    exception);
            } else {
                log.warn("CheckTransactionState, pick transactionCheckListener by group[{}] failed", group);
            }
        }

        private void processTransactionState(
            final LocalTransactionState localTransactionState,
            final String producerGroup,
            final Throwable exception) {
            final EndTransactionRequestHeader thisHeader = new EndTransactionRequestHeader();
            thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());
            thisHeader.setProducerGroup(producerGroup);
            thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());
            thisHeader.setFromTransactionCheck(true);
            thisHeader.setBname(checkRequestHeader.getBname());

            String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);
            if (uniqueKey == null) {
                uniqueKey = message.getMsgId();
            }
            thisHeader.setMsgId(uniqueKey);
            thisHeader.setTransactionId(checkRequestHeader.getTransactionId());
            switch (localTransactionState) {
                case COMMIT_MESSAGE:
                    thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);
                    break;
                case ROLLBACK_MESSAGE:
                    thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);
                    log.warn("when broker check, client rollback this transaction, {}", thisHeader);
                    break;
                case UNKNOW:
                    thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);
                    log.warn("when broker check, client does not know this transaction state, {}", thisHeader);
                    break;
                default:
                    break;
            }

            String remark = null;
            if (exception != null) {
                remark = "checkLocalTransactionState Exception: " + UtilAll.exceptionSimpleDesc(exception);
            }
            doExecuteEndTransactionHook(msg, uniqueKey, brokerAddr, localTransactionState, true);

            try {
                DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,
                                                                                                     3000);
            } catch (Exception e) {
                log.error("endTransactionOneway exception", e);
            }
        }
    };

    this.checkExecutor.submit(request);
}
```



### 扩展

**Spring事务、常规的分布式事务不行吗？Rocketmq的事务是否多此一举了呢？**

MQ用于解耦，分布式事务直接操作了不同的系统，那么这些系统之间就是强耦合。果中间插了个mq，账号系统操作完发消息到mq，这时候只要保证发送成功就提交，发送失败则回滚，这步怎么保证，就是靠事务了。而且用RocketMQ做分布式事务的也蛮多的。



## 批量消息

批量消息不允许延时、不允许发送到重试 Topic，且要求发送到的 Topic 必须是同一个 Topic。



### 源码解析

#### 发送消息

首先，在调用 `send()` 的 batch 版本后，会先对批量消息进行校验，在校验完成，且都放到一个 List 之后，接下来的步骤和普通的消息发送都差不多，只是在编码上理所当然的存在着不同。

> org.apache.rocketmq.client.producer.DefaultMQProducer

```java
@Override
public SendResult send(Collection<Message> msgs,
                       long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
    return this.defaultMQProducerImpl.send(batch(msgs), timeout);
}

private MessageBatch batch(Collection<Message> msgs) throws MQClientException {
    MessageBatch msgBatch;
    try {
        msgBatch = MessageBatch.generateFromList(msgs);
        for (Message message : msgBatch) {
            Validators.checkMessage(message, this);
            MessageClientIDSetter.setUniqID(message);
            message.setTopic(withNamespace(message.getTopic()));
        }
        MessageClientIDSetter.setUniqID(msgBatch);
        msgBatch.setBody(msgBatch.encode());
    } catch (Exception e) {
        throw new MQClientException("Failed to initiate the MessageBatch", e);
    }
    msgBatch.setTopic(withNamespace(msgBatch.getTopic()));
    return msgBatch;
}
```



> org.apache.rocketmq.common.message.MessageBatch

```java
public static MessageBatch generateFromList(Collection<? extends Message> messages) {
    assert messages != null;
    assert messages.size() > 0;
    List<Message> messageList = new ArrayList<>(messages.size());
    Message first = null;
    for (Message message : messages) {
        if (message.getDelayTimeLevel() > 0) {
            throw new UnsupportedOperationException("TimeDelayLevel is not supported for batching");
        }
        if (message.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
            throw new UnsupportedOperationException("Retry Group is not supported for batching");
        }
        if (first == null) {
            first = message;
        } else {
            if (!first.getTopic().equals(message.getTopic())) {
                throw new UnsupportedOperationException("The topic of the messages in one batch should be the same");
            }
            if (first.isWaitStoreMsgOK() != message.isWaitStoreMsgOK()) {
                throw new UnsupportedOperationException("The waitStoreMsgOK of the messages in one batch should the same");
            }
        }
        messageList.add(message);
    }
    MessageBatch messageBatch = new MessageBatch(messageList);

    messageBatch.setTopic(first.getTopic());
    messageBatch.setWaitStoreMsgOK(first.isWaitStoreMsgOK());
    return messageBatch;
}
```



> org.apache.rocketmq.common.message.MessageBatch

```java
public byte[] encode() {
    return MessageDecoder.encodeMessages(messages);
}
```



> org.apache.rocketmq.common.message.MessageDecoder

```java
public static byte[] encodeMessages(List<Message> messages) {
    //TO DO refactor, accumulate in one buffer, avoid copies
    List<byte[]> encodedMessages = new ArrayList<>(messages.size());
    int allSize = 0;
    for (Message message : messages) {
        // 编码每一个消息
        byte[] tmp = encodeMessage(message);
        encodedMessages.add(tmp);
        allSize += tmp.length;
    }
    
    // 放到最后的大集合中
    byte[] allBytes = new byte[allSize];
    int pos = 0;
    for (byte[] bytes : encodedMessages) {
        System.arraycopy(bytes, 0, allBytes, pos, bytes.length);
        pos += bytes.length;
    }
    return allBytes;
}
```



然后使用 `RequestCode.SEND_BATCH_MESSAGE` 这个状态码发送出去。

> org.apache.rocketmq.client.impl.MQClientAPIImpl

```java
public SendResult sendMessage(
    // ...
) throws RemotingException, MQBrokerException, InterruptedException {
    // ...
    if (isReply) {
        // ...
    } else {
        if (sendSmartMsg || msg instanceof MessageBatch) {
            SendMessageRequestHeaderV2 requestHeaderV2 = SendMessageRequestHeaderV2.createSendMessageRequestHeaderV2(requestHeader);
            request = RemotingCommand.createRequestCommand(msg instanceof MessageBatch ? RequestCode.SEND_BATCH_MESSAGE : RequestCode.SEND_MESSAGE_V2, requestHeaderV2);
        } else {
            request = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, requestHeader);
        }
    }
	// ...
}
```



#### 接受消息

在 Broker 端，其投入的过程大体上和普通消息类似，但是其最后的持久化到硬盘时，这块批量消息被拆分为了普通的单条消息。即 RocketMQ 使用批量消息只减少了发送时的宽带传输，对于存储与交给消费者的部分并没有获得优化



> org.apache.rocketmq.store.CommitLog.DefaultAppendMessageCallback

```java
public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank,
                                    final MessageExtBatch messageExtBatch, PutMessageContext putMessageContext) {
    // ...
    // 
    while (messagesByteBuff.hasRemaining()) {
        // 1 TOTALSIZE
        final int msgPos = messagesByteBuff.position();
        final int msgLen = messagesByteBuff.getInt();

        // 当作普通消息存储

        putMessageContext.getPhyPos()[index++] = wroteOffset + totalMsgLen - msgLen;
        queueOffset++;
        msgNum++;
        messagesByteBuff.position(msgPos + msgLen);
    }
    // ...
}
```



## 延迟消息

定时消息是指消息发到**Broker**后，不能立刻被**Consumer**消费，要到特定的时间点或者等待特定的时间后才能被消费。

如果要支持任意的时间精度，在**Broker**层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销。

**RocketMQ**支持定时消息，但是不支持任意时间精度，支持特定的level，例如定时5s，10s，1m等。RocketMQ定义的延时级别有 18 个。



> org.apache.rocketmq.store.config.MessageStoreConfig

```java
private String messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";
```



**延时消息的延时时间并不精确，这个时间是 Broker 调度线程把消息重新投递到原始的 MessageQueue 的时间，如果发生消息积压或者 RocketMQ 客户端发生流量管控，客户端拉取到消息后进行处理的时间可能会超出预设的延时时间。**



### 源码解析

#### 写入消息

> org.apache.rocketmq.broker.util.HookUtils

```java
public static PutMessageResult handleScheduleMessage(BrokerController brokerController,
                                                     final MessageExtBrokerInner msg) {
    final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());
    if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE
        || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {
        // ...
        // Delay Delivery
        if (msg.getDelayTimeLevel() > 0) {
            transformDelayLevelMessage(brokerController, msg);
        }
    }
    return null;
}

public static void transformDelayLevelMessage(BrokerController brokerController, MessageExtBrokerInner msg) {
    if (msg.getDelayTimeLevel() > brokerController.getScheduleMessageService().getMaxDelayLevel()) {
        msg.setDelayTimeLevel(brokerController.getScheduleMessageService().getMaxDelayLevel());
    }

    // Backup real topic, queueId
    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());
    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));
    msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));

    msg.setTopic(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC);
    msg.setQueueId(ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel()));
}
```



> org.apache.rocketmq.broker.schedule.ScheduleMessageService

```java
public static int delayLevel2QueueId(final int delayLevel) {
    return delayLevel - 1;
}
```



Broker 收到消息后，会将消息写入 CommitLog。在写入时，会判断消息 DELAY 属性是否大于 0。CommitLog 写入时并没有直接写入，而是把 Topic 改为 SCHEDULE_TOPIC_XXXX，把 queueId 改为延时级别减 1。因为延时级别有 18 个，所以这里有 18 个队列。

![图片](https://oss.xubighead.top/oss/image/202506/1930159905915899906.jpg)



#### 调度消息

延时消息写入后，会有一个调度任务不停地拉取这些延时消息，这个逻辑在类 ScheduleMessageService。



> org.apache.rocketmq.broker.schedule.ScheduleMessageService

```java
public void start() {
    // 保证只被执行一次
    if (started.compareAndSet(false, true)) {
        // 加载本地快照
        this.load();
        // 延时任务执行一开始是用Timer实现的，后面改成ScheduledThreadPoolExecutor
        this.deliverExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl("ScheduleMessageTimerThread_"));
        if (this.enableAsyncDeliver) {
            this.handleExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl("ScheduleMessageExecutorHandleThread_"));
        }
        for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {
            // 取出每一个级别
            Integer level = entry.getKey();
            // 当前延迟级别对应的延迟时间
            Long timeDelay = entry.getValue();
            // 该延迟级别之前消费到的自己的队列的偏移量
            Long offset = this.offsetTable.get(level);
            if (null == offset) {
                offset = 0L;
            }
			// 每一个延迟级别设置一个定时任务
            if (timeDelay != null) {
                if (this.enableAsyncDeliver) {
                    this.handleExecutorService.schedule(new HandlePutResultTask(level), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);
                }
                this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);
            }
        }
		 // 定时持久化各个延迟级别的偏移量
        this.deliverExecutorService.scheduleAtFixedRate(new Runnable() {

            @Override
            public void run() {
                try {
                    if (started.get()) {
                        ScheduleMessageService.this.persist();
                    }
                } catch (Throwable e) {
                    log.error("scheduleAtFixedRate flush exception", e);
                }
            }
        }, 10000, this.brokerController.getMessageStore().getMessageStoreConfig().getFlushDelayOffsetInterval(), TimeUnit.MILLISECONDS);
    }
}
```



上面的 load() 方法会加载一个 delayLevelTable（ConcurrentHashMap类型），key 保存延时级别（从 1 开始），value 保存延时时间(单位是 ms)。

load() 方法结束后，创建了一个有 18 个核心线程的定时线程池，然后遍历 delayLevelTable，创建 18 个任务（DeliverDelayedMessageTimerTask）进行每个延时级别的任务调度。任务调度的代码逻辑如下：



> org.apache.rocketmq.broker.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask

```java
@Override
public void run() {
    try {
        if (isStarted()) {
            // 每一个延迟级别的 Queue 都有对应的定时任务，且都会执行以下方法
            this.executeOnTimeup();
        }
    } catch (Exception e) {
        // XXX: warn and notify me
        log.error("ScheduleMessageService, executeOnTimeup exception", e);
        this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_PERIOD);
    }
}

public void executeOnTimeup() {
    // 找到自己延迟级别的消费队列
    ConsumeQueueInterface cq = ScheduleMessageService.this
        .brokerController.getMessageStore()
        .getConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel2QueueId(delayLevel));

    if (cq == null) {
        this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_WHILE);
        return;
    }

    // 根据消费偏移量将指定的 MappedFile 文件加载进来
    ReferredIterator<CqUnit> bufferCQ = cq.iterateFrom(this.offset);
    if (bufferCQ == null) {
        long resetOffset;
        if ((resetOffset = cq.getMinOffsetInQueue()) > this.offset) {
            log.error("schedule CQ offset invalid);
        } else if ((resetOffset = cq.getMaxOffsetInQueue()) < this.offset) {
            log.error("schedule CQ offset invalid);
        } else {
            resetOffset = this.offset;
        }

        this.scheduleNextTimerTask(resetOffset, DELAY_FOR_A_WHILE);
        return;
    }

    long nextOffset = this.offset;
    try {
        while (bufferCQ.hasNext() && isStarted()) {
            // 遍历每一个消息的索引
            CqUnit cqUnit = bufferCQ.next();
            long offsetPy = cqUnit.getPos();
            int sizePy = cqUnit.getSize();
            long tagsCode = cqUnit.getTagsCode();

            if (!cqUnit.isTagsCodeValid()) {
                //can't find ext content.So re compute tags code.
                log.error("[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}",
                          tagsCode, offsetPy, sizePy);
                long msgStoreTime = ScheduleMessageService.this.brokerController.getMessageStore().getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);
                tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);
            }

            long now = System.currentTimeMillis();
            long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);

            long currOffset = cqUnit.getQueueOffset();
            assert cqUnit.getBatchNum() == 1;
            nextOffset = currOffset + cqUnit.getBatchNum();

            long countdown = deliverTimestamp - now;
            if (countdown > 0) {
                this.scheduleNextTimerTask(currOffset, DELAY_FOR_A_WHILE);
                // 更新消费偏移量
                ScheduleMessageService.this.updateOffset(this.delayLevel, currOffset);
                return;
            }

            // 目标时间小于当起时间，可以执行
            // 根据偏移量取出消息
            MessageExt msgExt = ScheduleMessageService.this.brokerController.getMessageStore().lookMessageByOffset(offsetPy, sizePy);
            if (msgExt == null) {
                // 否则，这个消息需要被消费的时间到了再通知我
                continue;
            }

            // 将延迟消息恢复成原本消息的样子
            MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt);
            if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) {
                log.error("[BUG] the real topic of schedule msg is {}, discard the msg. msg={}",
                          msgInner.getTopic(), msgInner);
                continue;
            }

            boolean deliverSuc;
            if (ScheduleMessageService.this.enableAsyncDeliver) {
                deliverSuc = this.asyncDeliver(msgInner, msgExt.getMsgId(), currOffset, offsetPy, sizePy);
            } else {
                deliverSuc = this.syncDeliver(msgInner, msgExt.getMsgId(), currOffset, offsetPy, sizePy);
            }

            if (!deliverSuc) {
                this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);
                return;
            }
        }
    } catch (Exception e) {
        log.error("ScheduleMessageService, messageTimeup execute error, offset = {}", nextOffset, e);
    } finally {
        bufferCQ.release();
    }

    this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);
}
```



> org.apache.rocketmq.broker.schedule.ScheduleMessageService

```java
private MessageExtBrokerInner messageTimeup(MessageExt msgExt) {
    MessageExtBrokerInner msgInner = new MessageExtBrokerInner();
    msgInner.setBody(msgExt.getBody());
    msgInner.setFlag(msgExt.getFlag());
    MessageAccessor.setProperties(msgInner, msgExt.getProperties());

    TopicFilterType topicFilterType = MessageExt.parseTopicFilterType(msgInner.getSysFlag());
    long tagsCodeValue =
        MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());
    msgInner.setTagsCode(tagsCodeValue);
    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));

    msgInner.setSysFlag(msgExt.getSysFlag());
    msgInner.setBornTimestamp(msgExt.getBornTimestamp());
    msgInner.setBornHost(msgExt.getBornHost());
    msgInner.setStoreHost(msgExt.getStoreHost());
    msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());

    msgInner.setWaitStoreMsgOK(false);
    MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);
    MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TIMER_DELIVER_MS);
    MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TIMER_DELAY_SEC);

    msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));

    String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);
    int queueId = Integer.parseInt(queueIdStr);
    msgInner.setQueueId(queueId);

    return msgInner;
}
```



> org.apache.rocketmq.broker.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask

```java
private boolean syncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,
                            int sizePy) {
    // 投入真实的 Topic
    PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, false);
    PutMessageResult result = resultProcess.get();
    boolean sendStatus = result != null && result.getPutMessageStatus() == PutMessageStatus.PUT_OK;
    if (sendStatus) {
        ScheduleMessageService.this.updateOffset(this.delayLevel, resultProcess.getNextOffset());
    }
    return sendStatus;
}
```



可以看出，延迟消息的实现还是十分简单的，由于先投入的延时消息必先快于后投入的消息的到期，所以只需要不断的拉取各个延迟级别对应的队列 的头部的延迟消息即可。这也是只支持固定级别的延迟消息带来的好处。

![图片](https://oss.xubighead.top/oss/image/202506/1930159985947414530.jpg)



上面有一个修正投递时间的函数，这个函数的意义是如果已经过了投递时间，那么立即投递。



> org.apache.rocketmq.broker.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask

```java
private long correctDeliverTimestamp(final long now, final long deliverTimestamp) {

    long result = deliverTimestamp;

    long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);
    if (deliverTimestamp > maxTimestamp) {
        result = now;
    }

    return result;
}
```



**消息从 CommitLog 转发到 ConsumeQueue 时，会判断是否是延时消息（Topic = SCHEDULE_TOPIC_XXXX 并且延时级别大于 0），如果是延时消息，就会修改 tagsCode 值为消息投递的时间戳，而 tagsCode 原值是 tag 的 HashCode。代码如下：**

> org.apache.rocketmq.store.CommitLog

```java
public DispatchRequest checkMessageAndReturnSize(java.nio.ByteBuffer byteBuffer, final boolean checkCRC,
                                                 final boolean checkDupInfo, final boolean readBody) {
    // ...
    String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);
    if (TopicValidator.RMQ_SYS_SCHEDULE_TOPIC.equals(topic) && t != null) {
        int delayLevel = Integer.parseInt(t);

        if (delayLevel > this.defaultMessageStore.getMaxDelayLevel()) {
            delayLevel = this.defaultMessageStore.getMaxDelayLevel();
        }

        if (delayLevel > 0) {
            tagsCode = this.defaultMessageStore.computeDeliverTimestamp(delayLevel,
                                                                        storeTimestamp);
        }
    }
    // ...
}
```



> org.apache.rocketmq.store.DefaultMessageStore

```java
public long computeDeliverTimestamp(final int delayLevel, final long storeTimestamp) {
    Long time = this.delayLevelTable.get(delayLevel);
    if (time != null) {
        return time + storeTimestamp;
    }

    return storeTimestamp + 1000;
}
```

![图片](https://oss.xubighead.top/oss/image/202506/1930160048316715009.jpg)



**而 ScheduleMessageService 调度线程将消息从 ConsumeQueue 重新投递到原始队列中时，会把 tagsCode 再次修改为 tag 的 HashCode，代码如下：**

> org.apache.rocketmq.common.message.MessageExtBrokerInner

```java
public static long tagsString2tagsCode(final TopicFilterType filter, final String tags) {
    if (null == tags || tags.length() == 0) { return 0; }

    return tags.hashCode();
}
```



![图片](https://oss.xubighead.top/oss/image/202506/1930160096773509122.jpg)



### 应用范例

```java
public static void main(String[] args) throws Exception {
    // Instantiate a producer to send scheduled messages
    DefaultMQProducer producer = new DefaultMQProducer("ExampleProducerGroup");
    // Launch producer
    producer.start();
    int totalMessagesToSend = 100;
    for (int i = 0; i < totalMessagesToSend; i++) {
        Message message = new Message("TestTopic", ("Hello scheduled message " + i).getBytes());
        // This message will be delivered to consumer 10 seconds later.
        message.setDelayTimeLevel(3);
        // Send the message
        producer.send(message);
    }

    // Shutdown producer after use.
    producer.shutdown();
}
```



### 扩展

#### 延时增长

**如果有一个业务场景，要求延时消息 3 小时才能消费，而 RocketMQ 的延时消息最大延时级别只支持延时 2 小时，怎么处理？**

这里提供两个思路供大家参考：

- 在 Broker 上修改 messageDelayLevel 的默认配置；
- 在客户端缓存 msgId，先设置延时级别是 18（2h），当客户端拉取到消息后首先判断有没有缓存，如果有缓存则再次发送延时消息，这次延时级别是 17（1h），如果没有缓存则进行消费。
