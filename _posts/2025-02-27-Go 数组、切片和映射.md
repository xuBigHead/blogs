---
layout: post
title: Go 数组、切片和映射.md
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# Go 数组、切片和映射

## 容器概述

Go中有三种容器类型：数组、切片和映射。每个容器（值）用来表示和存储一个元素序列或集合，容器中所有元素的类型是相同的，此相同的类型称为此容器的类型的元素类型（或简称此容器的元素类型）。



存储在一个容器中的每个元素值都关联着一个键值（key），每个元素可以通过它的键值而被访问到。数组和切片类型的键值类型均为内置类型`int`，键值是一个非负整数下标，此非负整数表示该元素在该数组或切片所有元素中的顺序位置，此非负整数下标亦常称为一个元素索引（index）；映射类型的键值类型必须为一个可比较类型。

每个容器值有一个长度属性，用来表明此容器中当前存储了多少个元素。数组或切片中的每个元素所关联的非负整数索引键值的合法取值范围为左闭右开区间`[0, 此数组或切片的长度)`；映射值类型的容器值中的元素关联的键值可以是任何此映射类型的键值类型的任何值。

可以通过元素的键值来访问此元素，对于这三种容器，元素访问的时间复杂度均为`O(1)`，映射元素访问消耗的时长要数倍于数组和切片元素访问消耗的时长，但是映射相对于数组和切片有两个优点：

- 映射的键值类型可以是任何可比较类型。
- 对于大多数元素为零值的情况，使用映射可以节省大量的内存。



这三种容器类型的值在使用上有很多的差别，这些差别多源于它们的内存结构的差异，数组值仅由一个直接部分组成，切片或映射值是由一个直接部分和一个可能的被此直接部分引用着的间接部分组成。

数组或切片的所有元素紧挨着存放在一块连续的内存中，数组中的所有元素均存放在此数组值的直接部分，切片中的所有元素均存放在此切片值的间接部分。在官方标准编译器和运行时中，映射是使用哈希表算法来实现的，映射中的所有元素也均存放在一块连续的内存中，但是映射中的元素并不一定紧挨着存放。另外一种常用的映射实现算法是二叉树算法，无论使用何种算法，映射中的所有元素的键值也存放在此映射值（的间接部分）中。

在任何赋值中，源值的底层间接部分不会被复制，当赋值结束后，含有间接部分的源值和目标值将共享底层间接部分，这就是数组和切片/映射值会有很多行为差异的原因。



### 广义容器类型

可以被用做内置函数`len`调用的参数的值的类型都可以被称为（广义上的）容器类型，这些容器类型的值都可以跟在`for-range`循环的`range`关键字后。广义容器类型可以作为实参调用的内置函数关系如下：

|                    | len  | cap  | close | delete | make |
| :----------------: | :--: | :--: | :---: | :----: | :--: |
|      字符串值      | 可以 |      |       |        |      |
| 数组或者数组指针值 | 可以 | 可以 |       |        |      |
|       切片值       | 可以 | 可以 |       |        | 可以 |
|       映射值       | 可以 |      |       |  可以  | 可以 |
|       通道值       | 可以 | 可以 | 可以  |        | 可以 |



广义容器区别如下：

|     类型     | 是否支持添加新的元素 | 元素是否可以被替换 | 元素是否可寻址 | 访问元素是否会更改容器长度 | 是否可以有间接底层部分 |
| :----------: | :------------------: | :----------------: | :------------: | :------------------------: | :--------------------: |
| 字符串容器值 |          否          |         否         |       否       |             否             |         是(1)          |
|  数组容器值  |          否          |       是(2)        |     是(2)      |             否             |           否           |
|  切片容器值  |        否(3)         |         是         |       是       |             否             |           是           |
|  映射容器值  |          是          |         是         |       否       |             否             |           是           |
|  通道容器值  |        是(4)         |         否         |       否       |             是             |           是           |



- (1) 对于标准编译器和运行时来说。
- (2) 对于可寻址的数组值来说。
- (3) 一般说来，一个切片的长度只能通过将另外一个切片赋值给它来被整体替换修改，这里我们不视这种情况为“添加新的元素”。 其实，切片的长度也可以通过调用`reflect.SetLen`来单独修改。增加切片的长度可以看作是一种变相的向切片添加元素。 但`reflect.SetLen`函数的效率很低，因此很少使用。
- (4) 对于带缓冲并且缓冲未满的通道来说。



## 数组 array

### 数组声明和创建

#### 无名数组类型的字面表示形式

无名数组类型的字面表示形式如下：`[N]T`，`T`可为任意类型，它表示一个容器类型的元素类型，某个特定容器类型的值中只能存储此容器类型的元素类型的值。`N`必须为一个非负整数常量，它指定了一个数组类型的长度，或者说它指定了此数组类型的任何一个值中存储了多少个元素。数组类型的长度是此数组类型的一部分，比如`[5]int`和`[8]int`是两个不同的类型。

 数组类型的尺寸等于它的元素类型的尺寸和它的长度的乘积，长度为零的数组的尺寸为零，元素类型尺寸为零的任意长度的数组类型的尺寸也为零。

```go
const Size = 32

type Person struct {
	name string
	age  int
}

[5]string
[Size]int
[16][]byte  // 元素类型为一个切片类型：[]byte
[100]Person // 元素类型为一个结构体类型：Person
```



#### 数组字面量的表示形式

和结构体值类似，数组容器值的文字表示也可以用组合字面量形式（composite literal）来表示。一个数组零值中的所有元素均为对应数组元素类型的零值。下面是一些容器字面量：

```go
[4]bool{false, true, true, false} // 一个含有4个布尔元素的数组值。

// 下面这些数组字面量都是等价的。
[4]bool{false, true, true, false}
[4]bool{0: false, 1: true, 2: true, 3: false} // 声明大小为4的数组，并通过指定下标来初始化元素
[4]bool{1: true, true}
[4]bool{2: true, 1: true}

// ...表示声明长度不确定的数组，编译器根据元素个数自行推断数组的长度
[...]bool{false, true, true, false}
[...]bool{3: false, 1: true, true}

var a uint = 1
var _ = [5]int{a: 100} // error: 数组下标必须为常量
```



从上面的例子中可以看出数组组合字面量中的索引下标（即数组的键值）是可选的，在一个数组组合字面量中：

- 如果索引下标出现，类型不必是数组类型的键值类型`int`，但必须是可以表示为int值的非负常量；如果是一个类型确定值，则类型必须为一个内置整数类型；
- 在数组组合字面量中，如果索引下标缺失，则编译器认为索引下标为出现在它之前的元素的索引下标加一；
- 如果出现的第一个元素的索引下标缺失，则它的索引下标被认为是0；



##### 数组类型零值的字面量表示形式

数组类型`A`的零值可以表示为`A{}`，比如数组类型`[100]int`的零值可以表示为`[100]int{}`。在运行时刻，即使一个数组变量在声明的时候未指定初始值，它的元素所占的内存空间已经被开辟出来。

```go
var _ [5]int = [5]int{}
```



##### 简化内嵌组合字面量

```go
type language struct {
	name string
	year int
}

var _ = [...]language{language{"C", 1972}, language{"Python", 1991}, language{"Go", 2009}}

// 可以被简化为
var _ = [...]language{{"C", 1972}, {"Python", 1991}, {"Go", 2009}}
```



#### 数组赋值

可以通过数组赋值的方式创建新的数组，数组被赋值给另一个数组时，所有的元素都将被从源数组复制到目标数组。赋值完成之后，这两个数组不共享任何元素。

```go
a0 := [...]int{7, 8, 9}
a1 := a0
a1[0] = 2
fmt.Println(a0, a1) // [7 8 9] [2 8 9]
```



#### `new`函数创建数组

内置`new`函数可以用来为一个任何类型的值开辟内存并返回一个存储有此值的地址的指针，用`new`函数开辟出来的值均为零值。

```go
a := *new([5]bool)          // <=> var a [5]bool
fmt.Println(a == [5]bool{}) // true
```



### 数组操作

#### 数组值的比较

大多数数组类型都是可比较类型，除了元素类型为不可比较类型的数组类型。两个数组值对应元素将逐一被比较（可以认为按照下标顺序比较），只有在对应元素都相等的情况下才相等；当一对元素不相等或在比较中产生恐慌时，对数组的比较将提前结束。

```go
var a [16]byte
fmt.Println(a == a)   // true
```



#### 数组的长度和容量

数组的长度表示数组中含有多少个元素，数组值的容量总是和长度相等，且长度和容量永不改变。调用内置函数`len`来获取一个数组值的长度，或者调用内置函数`cap`来获取一个数组值的容量，这两个函数都返回一个`int`类型确定结果值或者一个默认类型为`int`的类型不确定结果，具体取决于传递给它们的实参是否为常量表达式。 

```go
var a [5]int
fmt.Println(len(a), cap(a)) // 5 5
```



#### 读取和修改数组元素

假设`v`是一个数组，通过元素索引表达式`v[k]`来读取和修改数组的元素，`k`必须是一个可以表示为int值的非负常量并且小于`len(v)`，否则，在运行时刻将产生一个恐慌。

```go
a := [3]int{-1, 0, 1}
fmt.Println (a[2]) // 读取
a[2] = 999 // 修改
fmt.Println (a[2]) // 读取

_ = a[3]  // 下标越界，编译不通过
n := 3
_ = a[n]  // panic: 下标越界
```



#### 添加和删除数组元素

数组中的元素个数总是恒定的，无法向其中添加元素，也无法从其中删除元素，但是可寻址的数组值中的元素是可以被修改的。



#### 重置数组元素

Go 1.21引入了一个`clear`内置函数，此函数可以用来重置数组元素。

```go
func main() {
	a := [4]int{5, 6, 7, 8}
	clear(a[1:3])
	fmt.Println(a) // [5 0 0 8]
}
```



### 多维数组

Go 语言支持多维数组，以下为常用的多维数组声明方式：

```
var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type
```



以下实例声明了三维的整型数组：

```go
var threedim [5][10][4]int
```



#### 初始化二维数组

二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：

```
var arrayName [ x ][ y ] variable_type
```



多维数组可通过大括号来初始值。以下实例为一个 3 行 4 列的二维数组：

```go
a := [3][4]int{  
 {0, 1, 2, 3} ,   /*  第一行索引为 0 */
 {4, 5, 6, 7} ,   /*  第二行索引为 1 */
 {8, 9, 10, 11},   /* 第三行索引为 2 */
}
```



以上代码中倒数第二行的 **}** 必须要有逗号，因为最后一行的 **}** 不能单独一行，也可以写成这样：

```go
a := [3][4]int{  
 {0, 1, 2, 3} ,   /*  第一行索引为 0 */
 {4, 5, 6, 7} ,   /*  第二行索引为 1 */
 {8, 9, 10, 11}}   /* 第三行索引为 2 */
```



#### 访问二维数组

二维数组通过指定坐标来访问。如数组中的行索引与列索引。

```go
package main

import "fmt"

func main() {
   /* 数组 - 5 行 2 列*/
   var a = [5][2]int{ {0,0}, {1,2}, {2,4}, {3,6},{4,8}}
   var i, j int

   /* 输出数组元素 */
   for  i = 0; i < 5; i++ {
      for j = 0; j < 2; j++ {
         fmt.Printf("a[%d][%d] = %d\n", i,j, a[i][j] )
      }
   }
}
```



- 创建各个维度元素数量不一致的多维数组：

```go
package main

import "fmt"

func main() {
    // 创建空的二维数组
    animals := [][]string{}

    // 创建三一维数组，各数组长度不同
    row1 := []string{"fish", "shark", "eel"}
    row2 := []string{"bird"}
    row3 := []string{"lizard", "salamander"}

    // 使用 append() 函数将一维数组添加到二维数组中
    animals = append(animals, row1)
    animals = append(animals, row2)
    animals = append(animals, row3)

    // 循环输出
    for i := range animals {
        fmt.Printf("Row: %v\n", i)
        fmt.Println(animals[i])
    }
}
```

```
Row: 0
[fish shark eel]
Row: 1
[bird]
Row: 2
[lizard salamander]
```



## 切片 slice

Go 语言切片是对数组的抽象。Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片（动态数组），与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。切片不需要说明长度。



### 切片声明和创建

#### 无名切片类型的字面表示形式

无名切片类型的字面表示形式如下：`[]T，T`可为任意类型，它表示一个容器类型的元素类型，某个特定容器类型的值中只能存储此容器类型的元素类型的值。

所有切片类型的尺寸都是一致的。



```go
[]bool
[]int64
[]map[int]bool // 元素类型为一个映射类型：map[int]bool
[]*int         // 元素类型为一个指针类型：*int
```



#### 切片字面量的表示形式

切片容器值的文字表示也可以用组合字面量形式来表示。

```go
[]string{"break", "continue", "fallthrough"} // 一个含有三个字符串值的切片值。

// 下面这些切片字面量都是等价的。
[]string{"break", "continue", "fallthrough"}
[]string{0: "break", 1: "continue", 2: "fallthrough"}
[]string{2: "fallthrough", 1: "continue", 0: "break"}
[]string{2: "fallthrough", 0: "break", "continue"}

var a uint = 1
var _ = []int{a: 100}          // error: 切片下标必须为常量
```



从上面的例子中可以看出切片组合字面量中的索引下标（即切片的键值）是可选的，在一个切片组合字面量中：

- 如果索引下标出现，类型不必是切片类型的键值类型`int`，但必须是可以表示为int值的非负常量；如果是一个类型确定值，则类型必须为一个内置整数类型；
- 在切片组合字面量中，如果索引下标缺失，则编译器认为索引下标为出现在它之前的元素的索引下标加一；
- 如果出现的第一个元素的索引下标缺失，则它的索引下标被认为是0；



##### 切片类型零值的字面量表示形式

切片类型的零值用预声明的标识符nil来表示，它的元素所占的内存空间未被开辟出来。`[]T{}`表示类型`[]T`的一个空切片值，它和`[]T(nil)`是不等价的。

```go
var a []int // 默认值是nil
b := []int(nil) // 创建一个 nil 切片
c := []int{} // 创建一个空切片

fmt.Println(a == nil) // true
fmt.Println(b == nil) // true
fmt.Println(c == nil) // false
```



##### 简化内嵌组合字面量

```go
var heads = []*[4]byte{&[4]byte{'P', 'N', 'G', ' '}, &[4]byte{'G', 'I', 'F', ' '}, &[4]byte{'J', 'P', 'E', 'G'}}

// 可以被简化为
var heads = []*[4]byte{{'P', 'N', 'G', ' '}, {'G', 'I', 'F', ' '}, {'J', 'P', 'E', 'G'}}
```



#### 切片赋值

可以通过切片赋值的方式创建新的切片，切片赋值给另一个切片后，它们将共享底层的元素，长度和容量也相等。但是和映射不同，如果以后其中一个切片改变了长度或者容量，此变化不会体现到另一个切片中。

```go
s0 := []int{7, 8, 9}
s1 := s0
s1[0] = 2
fmt.Println(s0, s1) // [2 8 9] [2 8 9]
```



#### `make`函数创建切片

假设`S`是一个切片类型，`length`和`capacity`是两个非负整数，并且`length`小于等于`capacity`，可以用下面的两种函数调用来各自生成一个类型为`S`的切片值。`length`和`capacity`的类型必须均为整数类型（两者可以不一致）。

- `make(S, length, capacity)`：创建长度为`length`并且容量为`capacity`的切片；
- `make(S, length)`：创建了一个长度为`length`并且容量也为`length`的切片，等价于`make(S, length, length)`；



使用`make`函数创建的切片中的所有元素值均被初始化为结果切片的元素类型的零值。

```go
s := make([]int, 3, 5)
fmt.Println(s, len(s), cap(s)) // [0 0 0] 3 5
s = make([]int, 2)
fmt.Println(s, len(s), cap(s)) // [0 0] 2 2
```



#### `new`函数创建切片

因为用`new`函数开辟出来的值均为零值，所以`new`函数对于创建切片值来说没有任何价值。

```go
s := *new([]int)            // <=> var s []int
fmt.Println(s == nil)       // true
```



### 切片操作

#### 切片值的比较

切片类型属于不可比较类型，任意两个切片值是不能相互比较的，但是切片值可以和预声明的`nil`标识符进行比较以检查此切片值是否为一个零值。

```go
var s []int
fmt.Println(s == nil) // true
fmt.Println(nil == []int{}) // false
```



#### 切片的长度和容量

切片的长度表示切片中含有多少个元素，切片值的容量总是不小于此切片值的长度，在编程中，只有切片值的容量有实际意义。切片值的长度和容量可在运行时刻改变，一般只能通过被赋值的途径来修改，两者一般不可单独被修改，因此切片可以被认为是动态数组。调用内置函数`len`来获取一个切片值的长度，或者调用内置函数`cap`来获取一个切片值的容量，这两个函数都返回一个`int`类型确定结果值或者一个默认类型为`int`的类型不确定结果，具体取决于传递给它们的实参是否为常量表达式。

```go
var s []int
fmt.Println(len(s), cap(s)) // 0 0
s, s2 := []int{2, 3, 5}, []bool{}
fmt.Println(len(s), cap(s), len(s2), cap(s2)) // 3 3 0 0
```



一般来说，切片的长度和容量不能被单独修改，只有通过赋值的方式被整体修改。但是可以通过反射的途径来单独修改一个切片的长度或者容量。

```go
func main() {
	s := make([]int, 2, 6)
	fmt.Println(len(s), cap(s)) // 2 6

	reflect.ValueOf(&s).Elem().SetLen(3)
	fmt.Println(len(s), cap(s)) // 3 6

	reflect.ValueOf(&s).Elem().SetCap(5)
	fmt.Println(len(s), cap(s)) // 3 5
}
```

传递给函数`reflect.SetLen`调用的第二个实参值必须不大于第一个实参切片值的容量，传递给函数`reflect.SetCap`调用的第二个实参值必须不小于第一个实参切片值的长度并且须不大于第一个实参切片值的容量，否则，在运行时刻将产生一个恐慌。此反射方法的效率很低，远低于一个切片的赋值。



#### 读取和修改切片元素

假设`v`是一个切片，通过元素索引表达式`v[k]`来读取和修改切片的元素。如果`v`是一个零值切片，或`k`不是一个可以表示为int值的非负常量，或`k`大于等于`len(v)`，则在运行时刻将产生一个恐慌。

```go
s := []bool{true, false}
fmt.Println (s[1]) // 读取
s[1] = true // 修改
fmt.Println (s[1]) // 读取

_ = s[-1]  // 下标越界，编译不通过
n := 2
_ = s[n]  // panic: 下标越界
```



#### 添加和删除切片元素

调用内置`append`函数，以一个切片为基础，来添加不定数量的元素并返回一个新的切片，新的结果切片包含着基础切片中所有的元素和所有被添加的元素。基础切片并未被此`append`函数调用所修改。截至Go 1.23，`append`函数调用的第一个实参不能为类型不确定的`nil`。Go中并未提供一个内置方式来从一个切片中删除一个元素，必须使用`append`函数和子切片语法实现元素删除操作。下面是一个如何使用`append`内置函数的例子。

```go
s0 := []int{2, 3, 5}
fmt.Println(s0, cap(s0)) // [2 3 5] 3
s1 := append(s0, 7)      // 添加一个元素，等价于：s1 := append(s0, []int{7}...)。
fmt.Println(s1, cap(s1)) // [2 3 5 7] 6
s2 := append(s1, 11, 13) // 添加两个元素，等价于：s2 := append(s1, []int{11, 13}...)。
fmt.Println(s2, cap(s2)) // [2 3 5 7 11 13] 6
s3 := append(s0)         // <=> s3 := s0
fmt.Println(s3, cap(s3)) // [2 3 5] 3
s4 := append(s0, s0...)  // 以s0为基础添加s0中所有的元素，等价于：s4 := append(s0, s0[0], s0[1], s0[2])。
fmt.Println(s4, cap(s4)) // [2 3 5 2 3 5] 6

s0[0], s1[0] = 99, 789
fmt.Println(s2[0], s3[0], s4[0]) // 789 99 2
```



内置`append`函数是一个变长参数函数，它有两个参数，其中第二形参为一个变长参数。变长参数函数调用中的实参有两种传递方式：

- 第一种方式中，零个或多个实参元素值可以传递给`append`函数的第二个形参；
- 第二种方式中，一个和第一个实参同元素类型的实参切片传递给了第二个形参，此切片实参必须跟随三个点`...`，对于这种方式，`append`函数并不要求第二个实参的类型和第一个实参一致，但是它们的元素类型必须一致，即它们的底层类型必须一致；



在上面的程序中:

- `s1 := append(s0, 7)`的`append`函数调用将为结果切片`s1`开辟一段新的内存，因为切片`s0`中没有足够的冗余元素槽位来容纳新添加的元素；
- `s4 := append(s0, s0...)`的`append`函数调用也是同样的情况，为结果切片`s4`开辟一段新的内存，因为切片`s0`中没有足够的冗余元素槽位来容纳新添加的元素；
- `s2 := append(s1, 11, 13)`的`append`函数调用不会为结果切片`s2`开辟新的内存片段。 原因是切片`s1`中的冗余元素槽位足够容纳新添加的元素；



所以上述切片`s1`和`s2`共享一些元素，切片`s0`和`s3`共享所有的元素。下图描绘了各个切片的状态。

![各个切片状态](https://oss.xubighead.top/oss/image/202501/1877594292264914945.png)



当一个`append`函数调用需要为结果切片开辟内存时，结果切片的容量取决于具体编译器实现。对于官方标准编译器，如果基础切片的容量较小，则结果切片的容量至少为基础切片的两倍，目的是使结果切片有足够多的冗余元素槽位，以防止此结果切片被用做后续其它`append`函数调用的基础切片时再次开辟内存。在实际编程中常常将`append`函数调用的结果赋值给基础切片。



#### 取子切片

从基础切片或可寻址的基础数组派生出另一个切片，此派生操作常称为**取子切片**。派生出来的切片的元素和基础切片或数组的元素位于同一个内存片段上，或者说派生出来的切片和基础切片或数组将共享一些元素。Go中有两种取子切片的语法形式：

> 从nil数组指针派生切片将导致恐慌

```go
baseContainer[low : high]       				// 双下标形式，实践中，双下标形式使用得相对更为广泛
baseContainer[low : high : cap(baseContainer)] 	// 上面所示的双下标形式等价于下面的三下标形式
baseContainer[low : high : max] 				// 三下标形式，从Go 1.2开始支持的
```



取子切片表达式的语法形式中的下标必须满足下列关系，否则代码要么编译不通过，要么在运行时刻将造成恐慌。

```go
// 双下标形式
0 <= low <= high <= cap(baseContainer)

// 三下标形式
0 <= low <= high <= max <= cap(baseContainer)
```



注意：

- 子切片元素包含基础切片下标从`low`开始，到下标为`high - 1`的元素；
- 下标`low`和`high`都可以大于`len(baseContainer)`，但是不能大于`cap(baseContainer)`；
- 子切片表达式的结果切片的长度为`high - low`、容量为`max - low`，结果切片的长度可能大于基础切片的长度，但结果切片的容量绝不可能大于基础切片的容量；



在实践中常常在子切片表达式中省略若干下标，以使代码看上去更加简洁。省略规则如下：

- 如果下标`low`为零，则它可被省略，此条规则同时适用于双下标形式和三下标形式；
- 如果下标`high`等于`len(baseContainer)`，则它可被省略，此条规则同时只适用于双下标形式；
- 三下标形式中的下标`max`在任何情况下都不可被省略；



比如，下面的子切片表达式都是相互等价的：

```go
baseContainer[0 : len(baseContainer)]
baseContainer[: len(baseContainer)]
baseContainer[0 :]
baseContainer[:]
baseContainer[0 : len(baseContainer) : cap(baseContainer)]
baseContainer[: len(baseContainer) : cap(baseContainer)]
```



一个使用了子切片语法的例子：

```go
package main

import "fmt"

func main() {
	a := [...]int{0, 1, 2, 3, 4, 5, 6}
	s0 := a[:]     // <=> s0 := a[0:7:7]
	s1 := s0[:]    // <=> s1 := s0
	s2 := s1[1:3]  // <=> s2 := a[1:3]
	s3 := s1[3:]   // <=> s3 := s1[3:7]
	s4 := s0[3:5]  // <=> s4 := s0[3:5:7]
	s5 := s4[:2:2] // <=> s5 := s0[3:5:5]
	s6 := append(s4, 77)
	s7 := append(s5, 88)
	s8 := append(s7, 66)
	s3[1] = 99
	fmt.Println(len(s2), cap(s2), s2) // 2 6 [1 2]
	fmt.Println(len(s3), cap(s3), s3) // 4 4 [3 99 77 6]
	fmt.Println(len(s4), cap(s4), s4) // 2 4 [3 99]
	fmt.Println(len(s5), cap(s5), s5) // 2 2 [3 99]
	fmt.Println(len(s6), cap(s6), s6) // 3 4 [3 99 77]
	fmt.Println(len(s7), cap(s7), s7) // 3 4 [3 4 88]
	fmt.Println(len(s8), cap(s8), s8) // 4 4 [3 4 88 66]
}
```



下面这张图描绘了上面的程序在退出之前各个数组和切片的状态，切片`s7`和`s8`共享存储它们的元素的底层内存片段，其它切片和数组`a`共享同一个存储元素的内存片段。

![数字和切片状态](https://oss.xubighead.top/oss/image/202501/1878620810973827075.png)



注意取子切片操作有可能会造成暂时性的内存泄露，下面在这个函数中开辟的内存块中的前50个元素槽位在它的调用返回之后将不再可见，这50个元素槽位所占内存浪费了，这属于暂时性的内存泄露。当这个函数中开辟的内存块今后不再被任何切片所引用，此内存块将被回收，这时内存才不再继续泄漏。

```go
func f() []int {
	s := make([]int, 10, 100)
	return s[50:60] // 子切片表达式中的起始下标50比s的长度10要大，这是允许的
}
```



如果`baseContainer`是零值nil切片，只要子切片表达式中下标的值均为`0`，则子切片表达式不会造成恐慌，结果切片也是一个nil切片。

```go
func TestDeriveFromNilSlice(t *testing.T) {
	var x []int // nil
	a := x[:]
	b := x[0:0]
	c := x[:0:0]
	// 下一行将打印出三个true。
	fmt.Println(a == nil, b == nil, c == nil)
}
```



##### 三下标子切片形式应用

假设一个包提供了一个`func NewX(...Option) *X`函数，并且这个函数的实现将输入选项与一些内部默认选项合并，那么下面的实现是不推荐的。

```go
func NewX(opts ...Option) *X {
	options := append(opts, defaultOpts...)
	// 使用合并后选项来创建一个X值并返回其指针。
	// ...
}
```



上述实现不被推荐的原因是`append`函数调用可能会修改输入实参`opts`的底层潜在`Option`元素序列。对大多数场景，这可能是没问题的。但是对某些特殊场景，这有可能会导致后续代码执行产生不期望的结果。为了避免输入实参的底层`Option`元素序列被修改，应该使用下面的实现方法：

```go
func NewX(opts ...Option) *X {
	// 改用三下标子切片格式。
	opts = append(opts[:len(opts):len(opts)], defaultOpts...)
	// 使用合并后选项来创建一个X值并返回其指针。
	// ...
}
```



另一方面，对于`NewX`函数的调用者来说，不应该依赖于此函数的具体实现，所以最好使用三下标子切片形式`options[:len(options):cap(options)]`来传递实参。



#### 切片转换为数组指针和数组

从Go 1.17开始，切片可以被转化为相同元素类型的数组的指针类型，如果数组的长度大于被转化切片的长度，则将导致恐慌产生。转换结果和被转化切片将共享底层元素：

```go
package main

type S []int
type A [2]int
type P *A

func main() {
	var x []int
	var y = make([]int, 0)
	var x0 = (*[0]int)(x) // okay, x0 == nil
	var y0 = (*[0]int)(y) // okay, y0 != nil
	_, _ = x0, y0

	var z = make([]int, 3, 5)
	var _ = (*[3]int)(z) // okay
	var _ = (*[2]int)(z) // okay
	var _ = (*A)(z)      // okay
	var _ = P(z)         // okay

	var w = S(z)
	var _ = (*[3]int)(w) // okay
	var _ = (*[2]int)(w) // okay
	var _ = (*A)(w)      // okay
	var _ = P(w)         // okay

	var _ = (*[4]int)(z) // 会产生恐慌
}
```



从Go 1.20开始，切片可以被转化为相同元素类型的数组，但是如果数组的长度大于被转化切片的长度，则将导致恐慌产生。转换过程中将复制所需的元素，因此结果数组和被转化切片不共享底层元素：

```go
package main

import "fmt"

func main() {
	var s = []int{0, 1, 2, 3}
	var a = [3]int(s[1:])
	s[2] = 9
	fmt.Println(s) // [0 1 9 3]
	fmt.Println(a) // [1 2 3]
	
	_ = [3]int(s[:2]) // panic
}
```



#### 拷贝切片

内置`copy`函数将切片中的元素复制到另一个切片，这两个切片的类型可以不同，但是它们的元素类型必须相同，即这两个切片的类型的底层类型必须相同。`copy`函数的第一个参数为目标切片，第二个参数为源切片，传递给`copy`函数调用的两个实参可以共享一些底层元素。`copy`函数返回复制了多少个元素，此`int`类型值为这两个切片的长度的较小值。使用`copy`函数可以在两个数组之间或者一个数组与一个切片之间复制元素。截至目前Go 1.23，`copy`函数调用的两个实参均不能为类型不确定的`nil`。例子如下：

> 做为一个特例，`copy`函数可以用来将一个字符串中的字节复制到一个字节切片。

```go
type Ta []int
type Tb []int
dest := Ta{1, 2, 3}
src := Tb{5, 6, 7, 8, 9}
n := copy(dest, src)
fmt.Println(n, dest) // 3 [5 6 7]
n = copy(dest[1:], dest)
fmt.Println(n, dest) // 2 [5 5 6]

a := [4]int{} // 一个数组
n = copy(a[:], src)
fmt.Println(n, a) // 4 [5 6 7 8]
n = copy(a[:], a[2:])
fmt.Println(n, a) // 2 [7 8 7 8]
```



`copy()`函数的操作使用`append()`函数也能实现，但是`append()`函数每次复制数据都需要创建临时切片，性能上`copy()`函数更胜一筹。拷贝可分为深拷贝与浅拷贝，一般默认值类型的数据是深拷贝，引用类型的数据是浅拷贝。



#### 重置切片元素

Go 1.21引入了一个`clear`内置函数，此函数可以用来重置切片元素。

```go
func main() {
	s := []int{1, 2, 3}
	clear(s)
	fmt.Println(s) // [0 0 0]
	
	a := [4]int{5, 6, 7, 8}
	clear(a[1:3])
	fmt.Println(a) // [5 0 0 8]
}
```



### 切片内部结构

官方标准编译器对切片类型的内部定义大致如下：

```go
type _slice struct {
	elements unsafe.Pointer // 通过指针引用着底层存储在间接部分上的元素
	len      int            // 长度
	cap      int            // 容量
}
```



上面展示的切片的内部定义为切片的直接部分的定义，`elements`表示的是元素的指针，`len`表示当前存储了多少个元素，`cap`表示容量，所以`unsafe.Sizeof(切片)`永远都是 24。一般不能单独修改一个切片值的某个内部字段，除非使用反射或者非类型安全指针，即一般只能通过将其它切片赋值给一个切片来同时修改这个切片的三个字段。下图描绘了切片值的内存布局：

![切片值内存布局](https://oss.xubighead.top/oss/image/202501/1877285404894318593.png)



切片值的底层元素部分可能位于一个比较大的内存片段上，但是切片值只能感知到此内存片段上的一个子片段。比如，上图中的切片值只能感知到灰色的子片段。

在上图中，从下标`len`（包含）到下标`cap`（不包含）对应的元素并不属于图中所示的切片值，它们只是此切片之中的一些冗余元素槽位，但是它们可能是其它切片（或者数组）值中的有效元素。

通过调用内置`append`函数来向一个基础切片添加元素而得到一个新的切片，这个新的结果切片可能和这个基础切片共享起始元素，也可能不共享，具体取决于基础切片的容量（以及长度）和添加的元素数量。当一个切片被用做一个`append`函数调用中的基础切片：

- 添加的元素数量大于基础切片的冗余元素槽位的数量，则一个新的底层内存片段将被开辟出来并用来存放结果切片的元素，这时基础切片和结果切片不共享任何底层元素；
- 否则，不会有底层内存片段被开辟出来，这时基础切片中的所有元素也同时属于结果切片，两个切片的元素都存放于同一个内存片段上；



一些其它切片操作也可能会造成两个切片共享底层内存片段的情况。



### 切片源码解析

#### cap扩容

一个数组包含类型与长度两部分，切片的底层是一个数组，切片容量等于数组长度，在这个前提下，我们创建切片并修改它的长度时，如果长度小于容量（数组长度），那么函数将直接在原底层数组上增加新的元素，如果切片长度超出容量（数组长度），`append()` 函数就会创建一个新的底层数组，再将源数组的值复制过来。

```go
newcap := old.cap
doublecap := newcap + newcap
if cap > doublecap {
    newcap = cap
} else {
    if old.len < 1024 {
        newcap = doublecap
    } else {
        // Check 0 < newcap to detect overflow
        // and prevent an infinite loop.
        for 0 < newcap && newcap < cap {
            newcap += newcap / 4
        }
        // Set newcap to the requested cap when
        // the newcap calculation overflowed.
        if newcap <= 0 {
            newcap = cap
        }
    }
}
```

从上面的代码可以看出以下内容：

- 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。
- 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），
- 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap >= cap）
- 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。

需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如`int`和`string`类型的处理方式就不一样。



在 append 发生扩容时，申请容量是 原切片容量 + 追加的长度，如果是单数则 +1，再将这个容量传入扩容的方法进行判断，以讨论的 cap 变为6的代码为例：

原切片为 []int{1, 2} ，长度为2（记为 len1 = 2），容量为2（记为 cap1 =2）。

追加的长度为 {3, 4, 5}，长度为3（记为 len2= 3），此时进行扩容，申请容量为6（记为 cap2 = cap1+len2，cap2 为单数，则+1，cap2 = 6），将 cap2 带入楼上的扩容判断逻辑。

申请容量 cap2 大于2倍的旧容量（cap1 = 2），则newcap = cap2 = 6



## 映射 map

### 映射声明和创建

#### 无名映射类型的字面表示形式

无名映射类型的字面表示形式如下：`map[K]T`，`K`必须为一个可比较类型，它指定了一个映射类型的键值类型。`T`可为任意类型，它表示一个容器类型的元素类型，某个特定容器类型的值中只能存储此容器类型的元素类型的值。所有映射类型的尺寸也都是一致的。

```go
map[string]int
map[int]bool
map[int16][6]string     // 元素类型为一个数组类型：[6]string
map[bool][]string       // 元素类型为一个切片类型：[]string
map[struct{x int}]*int8 // 元素类型为一个指针类型：*int8，键值类型为一个结构体类型。
```



#### 映射字面量的表示形式

映射容器值的文字表示也可以用组合字面量形式来表示，映射组合字面量中大括号中的每一项称为一个键值元素对（key-value pair），或者称为一个条目（entry），映射的键值不能重复。

```go
map[string]int{"C": 1972, "Python": 1991, "Go": 2009} // 一个映射值。

var a uint = 1
var _ = map[uint]int {a : 123} // 映射组合字面量中元素对应的键值不可缺失，并且可以为非常量

var b map[string]int = nil // 映射类型的零值用预声明的标识符nil来表示，它的元素所占的内存空间未被开辟出来
```



##### 映射类型零值的字面量表示形式

映射类型的零值用预声明的标识符nil来表示，它的元素所占的内存空间未被开辟出来。`map[K]T{}`表示创建一个空映射，和`map[K]T(nil)`是不等价的。

```go
var a map[string]int // 默认值是nil
b := map[string]int(nil) // 创建一个 nil 映射
c := map[string]int{} // 创建一个空映射

fmt.Println(a == nil) // true
fmt.Println(b == nil) // true
fmt.Println(c == nil) // false
```



##### 简化内嵌组合字面量

```go
type LangCategory struct {
	dynamic bool
	strong  bool
}

// 此映射值的类型的键值类型为一个结构体类型，
// 元素类型为另一个映射类型：map[string]int。
var _ = map[LangCategory]map[string]int{
	LangCategory{true, true}: map[string]int{"Python": 1991, "Erlang": 1986},
	LangCategory{true, false}: map[string]int{"JavaScript": 1995},
	LangCategory{false, true}: map[string]int{"Go": 2009, "Rust": 2010},
	LangCategory{false, false}: map[string]int{"C": 1972},
}

// 可以被简化为
var _ = map[LangCategory]map[string]int{
    {true, true}: {"Python": 1991, "Erlang": 1986},
	{true, false}: {"JavaScript": 1995},
	{false, true}: {"Go": 2009, "Rust": 2010},
	{false, false}: {"C": 1972},
}
```



#### 映射赋值

可以通过映射赋值的方式创建新的映射，映射赋值语句执行完毕之后，目标映射值和源映射值将共享底层的元素，向其中一个映射中添加或删除元素将体现在另一个映射中。

```go
m0 := map[int]int{0:7, 1:8, 2:9}
m1 := m0
m1[0] = 2
fmt.Println(m0, m1) // map[0:2 1:8 2:9] map[0:2 1:8 2:9]
```



#### `make`函数创建映射

假设`M`是一个映射类型并且`n`是一个整数，可以用下面的两种函数调用来各自生成一个类型为`M`的映射值。

- `make(M, n)`：创建了一个可以容纳至少`n`个条目而无需再次开辟内存的空映射值，参数`n`可以为负或零，这时对应的调用将被视为`make(M)`调用；
- `make(M)`：创建了一个可以容纳一个小数目的条目而无需再次开辟内存的空映射值，此小数目的值取决于具体编译器实现。



```go
fmt.Println(make(map[string]int)) // map[]
m := make(map[string]int, 3)
fmt.Println(m, len(m)) // map[] 0
m["C"] = 1972
m["Go"] = 2009
fmt.Println(m, len(m)) // map[C:1972 Go:2009] 2
```



#### `new`函数创建映射

因为用`new`函数开辟出来的值均为零值，所以`new`函数对于创建映射值来说没有任何价值。

```go
m := *new(map[string]int)   // <=> var m map[string]int
fmt.Println(m == nil)       // true
```



### 映射操作

#### 映射值的比较

映射类型属于不可比较类型，任意两个映射值是不能相互比较的，但是映射值可以和预声明的`nil`标识符进行比较以检查此映射值是否为一个零值。

```go
var m map[string]int
fmt.Println(m == nil) // true
fmt.Println(nil == map[string]int{}) // false
```



#### 映射的长度和容量

映射的长度表示映射中含有多少个元素，一个非零映射值的容量可以被认为是无限大的。调用内置函数`len`来获取一个映射值的长度，返回一个`int`类型确定结果值，因为非零映射值的容量是无限大，所以内置函数`cap`并不适用于映射值来获取容量。

```go
var m map[int]bool
fmt.Println(len(m)) // 0
m, m2 := map[int]bool{1: true, 0: false}, map[int]int{}
fmt.Println(len(m), len(m2)) // 2 0
```



#### 读取和修改映射的元素

假设`v`是一个映射值，在`v[k]`中，

- 如果`k`是一个动态类型为不可比较类型的接口值，则`v[k]`在运行时刻将造成一个恐慌；
- 如果`v[k]`被用做一个赋值语句中的目标值并且`v`是一个零值nil映射，则`v[k]`在运行时刻将造成一个恐慌；
- 如果`v[k]`用来表示读取映射值`v`中键值`k`对应的元素，则它无论如何都不会产生一个恐慌，即使`v`是一个零值nil映射（假设`k`的值没有造成恐慌）；
- 如果`v[k]`用来表示读取映射值`v`中键值`k`对应的元素，并且映射值`v`中并不含有对应着键值`k`的条目，则`v[k]`返回一个此映射值的类型的元素类型的零值；
- 一般情况下，`v[k]`被认为是单值表达式，但`v[k]`被用为唯一源值的赋值语句中，`v[k]`可以返回可选的第二个返回值，此第二个返回值是一个类型不确定布尔值，用来表示是否有对应着键值`k`的条目存储在映射值`v`中。



```go
m := map[string]int{"abc": 123, "xyz": 789}
fmt.Println (m["abc"])    // 读取
m["abc"] = 999, true, 567 // 修改
fmt.Println (m["abc"])    // 读取

n, present := m["hello"]
fmt.Println(n, present, m["hello"]) // 0 false 0
n, present = m["abc"]
fmt.Println(n, present, m["abc"]) // 567 true 567

m = nil
fmt.Println(m["abc"]) // 0
m["hello"] = 555 // panic: m为一个零值映射
```



从nil映射中读取元素不会导致崩溃，读取结果是一个零元素值。函数`Foo1`和`Foo2`是等价的，但是函数`Foo2`比函数`Foo1`简洁得多。

```go
func Foo1(m map[string]int) int {
	if m != nil {
		return m["foo"]
	}
	return 0
}

func Foo2(m map[string]int) int {
	return m["foo"]
}
```



#### 添加和删除映射元素

映射添加元素的语法和修改映射元素的语法是一样的，对于一个非零映射值`m`，如果当前`m`中`k`键值不存在时，添加`（k，value）`键值对到映射`m`中；反之修改k键值对应的`value`。

```go
m[k] = value 
```



内置函数`delete`用来从一个映射中删除一个条目，`delete`调用将把键值`k`对应的条目从映射`m`中删除。如果映射`m`中未存储键值为`k`的条目，则此调用为一个空操作，它不会产生一个恐慌，即使`m`是一个nil零值映射。

```go
var m map[string]int // nil
delete(m, k)
```



下面的例子展示了如何向一个映射添加和从一个映射删除条目。

```go
m := map[string]int{"Go": 2007}
m["C"] = 1972     // 添加
m["Java"] = 1995  // 添加
fmt.Println(m)    // map[C:1972 Go:2007 Java:1995]
m["Go"] = 2009    // 修改
delete(m, "Java") // 删除
fmt.Println(m)    // map[C:1972 Go:2009]
```



#### 清空映射条目

Go 1.21引入了一个`clear`内置函数，此函数可以用来清空包含键值为NaN在内的映射条目。

```go
func main() {
	m := map[float64]float64{}
	x := 0.0
	m[x] = x
	x /= x // x变成了NaN
	m[x] = x
	fmt.Println(len(m)) // 2
	for k := range m {
		delete(m, k)
	}
	fmt.Println(len(m)) // 1
	clear(m)
	fmt.Println(len(m)) // 0
}
```



### 用映射模拟集合set

Go不支持内置集合（**set**）类型，但是可以用轻松使用映射类型来模拟。在实践中常常使用映射类型`map[K]struct{}`来模拟一个元素类型为`K`的集合类型，类型`struct{}`的尺寸为零，所以此映射类型的值中的元素不消耗内存。



## 参考资料

- [数组、切片和映射](https://gfw.go101.org/article/container.html)