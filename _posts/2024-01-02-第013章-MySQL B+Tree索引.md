---
layout: post
title: MySQL B+Tree索引.md
categories: [MySQL]
description: 
keywords: MySQL B+Tree索引.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# MySQL B+Tree 索引

## 概述

B+Tree索引是一个有序的树形结构，因此每次增删改涉及到索引的数据时，都会对索引的数据页和索引页进行重新排列（回收和分裂）。



删除操作并不会立即进行数据页内记录的重排列，而是会给被删除的记录打上一个删除的标识，等到合适的时候，再把记录从链表中移除，但是总归需要涉及到排序的维护，势必要消耗性能。

B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。最常见的索引类型，大部分索引都支持 B 树索引。



MySQL 中以 B+Tree 的有序的数据结构存储索引数据。本身是一种平衡的二叉树，每一个叶子节点到根的距离都是相同的，并且记录的所有节点是按键值的大小、顺序放在同一层的叶子节点上的，并且每一个叶子节点是通过指针来连接的。

是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。

B+Tree的每个非叶子节点存储了多个索引数据，每个非叶子节点大小为4kb。

MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个**指向相邻叶子节点的链表指针(整体类似一个双向链表的结构)**，就形成了带有顺序指针的B+Tree，提高区间访问的性能。



MyISAM的B+Tree索引的叶子节点上面存储的是主键id的内存地址。MyISAM的B+Tree索引如果是主键，则叶子节点上面存储的是该主键对应的所有列；如果不是主键，则叶子节点上面存储的是主键数据。

自适应 HASH 索引：自动维护。



### 优点

- Btree 索引适用于全值匹配的查询。
- Btree 索引适合处理范围查找。
- Btee 索引从索引的最左侧列开始匹配查找列
- 对于多个列组合成的索引，只能从左开始查找



### 缺陷

- 只能从最左侧开始按索引键的顺序使用索引，不能跳过索引键，如一个 a_b_c 的联合索引，在过滤的时候使用 a 和 c 列，那么就只能用到 a 列的索引；
- NOT IN 和 `<>`（不等于） 操作无法使用索引
- 索引列上不能使用表达式或是函数



### 和B-Tree对比

- B+Tree的磁盘读写代价更低：B+Tree非叶子结点存储索引数据，仅仅包含索引列和地址指针，同一个结点（磁盘页）中，B+Tree包含的索引数量比B-Tree更多，同样的数据量下，B+Tree会比B-Tree更加“矮胖”，查询时需要的**IO次数更少**。
- B+树的查询效率更加稳定：B+Tree所有索引或行数据都在叶子结点，而叶子结点都属于同一层级，所有查询都是从根结点遍历到叶子结点，时间复杂度相比B-Tree查询**更加稳定**。
- B+树更有利对数据的扫描：B+树可以避免B树的回溯扫描，B-Tree如果需要查询一串相邻的数值，可能需要来回扫描或是从根结点多次中序遍历。而B+Tree的所有元素都存储叶子结点，每个叶子结点都有指向下一个结点的指针，直接线性遍历即可。B+Tree更加利于做范围查询。



### 对比其他数据结构

- HASH：虽然可以快速定位，但是没有顺序，不适合范围查询，IO复杂度高；
- 有序数组：虽然范围查询效率较高，但是在中间位置插入记录时需要移动后面所有元素的位置，代价较高；
- 二叉树：树的高度不可控，不能自平衡，查找效率跟树的高度有关，并且IO代价高。在极端情况下等同于链表，此时查询相当于全表扫描；
- 红黑树：树的高度不可控，随着数据量增加而增加，IO代价高。



## 构建原理

- 内部节点并不存储真正的信息，而是保存其叶子节点的最小值作为索引。
- 每次插入删除都进行更新(此时用到parent指针)，保持最新状态。
- B+ 树非叶子节点上是不存储数据的，仅存储键值
- B+ 树只在叶子节点上以页（Page）的形式储存“数据”，每一页会存多行，上层就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。
- B+ 树的阶数是等于键值的数量的，如果 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。
- 一般根节点是常驻内存的，所以一般查找 10 亿数据，只需要 2 次磁盘 IO。
- 因为 B+ 树索引的所有“数据”均存储在叶子节点，而且数据是按照顺序排列的。
- 那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单
- B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。
- 其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。



## 查询流程

通过索引定位到页之后，在页内部存在有序数组，使用二分法查找行数据。



## 索引维护

### 页分裂

b+树插入数据可能导致分裂，因为一个节点只能存储m个元素，超过m个就会分裂。innoDB对于新插入操作，做了特殊处理，如果判断需要发生分裂时，先判断左(右)兄弟节点是否还有空位，如果有就把最左(右)边的数据迁移到左(右)节点，然后更新维护索引页，最后当前节点插入，从而阻止了分裂发生，如果左右都满了，还是会发生分裂。



可以通过有序递增的数值作为主键来避免页分裂。



### 页合并

可以通过逻辑删除的方式来避免页合并。



## 总结

### 使用自增主键

结合B+Tree的特点，自增主键是连续递增的，在插入过程中能减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。

主键类型建议设置为bigint unsigned。



### B+Tree索引页存储数据量计算

```sql
# 获取页大小
mysql> show global status like 'innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| Innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.01 sec)
```



一个索引页是 16384 也就是`16384/1024 = 16kb`，整数（`bigint`）字段的长度为8B，另外还跟着6B的指向其子树的指针，这意味着一个索引页可以存储接近1200条数据(16kb/14B ≈ 1170)。

- 树的根节点存储1200条索引目录，占用16kb内存。
- 树的第二层总共是1200个索引页，每个索引页存放1200条索引目录，就有144w条索引目录，占用1200 \* 16KB = 20M内存。
- 树的第三层1200 \* 1200 = 144w页，144w \* 16kB = 23G，此时不适合存放到内存中。



**可以通过调整页的大小来控制B+Tree索引每个节点上的索引数量。**