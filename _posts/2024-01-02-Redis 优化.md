# Optimization

影响Redis性能的内部及外部因素主要有：

1. Redis 内部的阻塞式操作
2. CPU 核和 NUMA 架构的影响
3. Redis 关键系统配置
4. Redis 内存碎片
5. Redis 缓冲区



## Redis 阻塞

### 阻塞点

Redis 实例的阻塞点：

- 客户端：网络 IO，键值对的增删改查操作，数据库操作；
- 磁盘：记录 AOF 日志；
- 主从节点：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；
- 切片集群实例：向其他实例传输哈希槽信息，数据迁移。



#### 客户端阻塞

键值对的增删改查是主线程的主要工作，复杂度高的操作当然会阻塞Redis了。判断复杂度高不高的标准就是看操作的复杂度是否为O(N)，也就是否要全表扫描。比如hgetall， smembers等操作就属于复杂度高的了。

数据的删除。删除本质上来说就是对键值对的内存空间进行释放。在释放内存时，操作系统需要将释放掉的内存块插入一个空闲内存块的链表，以便后续管理和再分配。这个过程会阻塞当前释放内存的应用程序。

如果这个键值对数据很大，比如一个 zset 包含大量元素，就会释放大量的内存。有测试过删除 100 万个元素的集合时，删除时间会达到 2s，要知道 Redis 的响应是毫秒级别的。所以这种 bigkey 的删除也会成为 Redis 的阻塞点。

清空数据库（flushdb、flushall）也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。



#### 磁盘阻塞

Redis直接记录AOF日志，若有大量的写操作，并且配置的是同步写回的话，就会阻塞主线程了。



#### 主从节点阻塞

从库在接收了 RDB 文件后，需要使用 FLUSHDB 命令清空当前数据库，这是一个阻塞点。而且，在从库清空数据库后，需要将 RDB 文件加载到内存，快慢和 rdb 文件大小相关。加载 RDB 文件是一个阻塞点。



#### 总结

总结一下，Redis 就有 5 个阻塞点：

- 集合全量查询和聚合操作；
- bigkey 删除；
- 清空数据库；
- AOF 日志同步写；
- 从库加载 RDB 文件。



### 非阻塞点

#### 网络IO

因 Redis 使用了 IO 多路复用机制，能避免主线程一直处于等待状态，网络 IO 不是导致 Redis 阻塞的因素。



#### AOF重写

AOF重写用了子进程的方式操作，所以不会阻塞主线程。



#### RDB快照

RDB快照用了子进程的方式操作，所以不会阻塞主线程。



#### 切片集群

切片集群的实例在负载均衡或者实例增加删除时，数据迁移是渐进式操作的，所以不会阻塞主线程。



#### 主从节点

在主从集群中，主库生成 RDB 文件，并传输给从库。主从复制过程的创建和传输 RDB 都是子进程处理的，不会阻塞主线程。



### 异步解决方案

通过异步的方式，去解决可能阻塞的场景。但也不是每个操作都能用异步的方式去解决。如果一个操作能够异步执行，说明客户端不需要马上得到具体值，在Redis中描述为**「若一个操作能异步执行，就意味着它不是主线程的关键路径的操作。」**

- 因为读操作需要等待数据的返回，所以不能异步执行。
- bigkey删除和清空数据库，因为删除不需要返回具体的结果，因此都可以用子线程去异步执行。
- AOF日志同步写可启动子线程操作，不用让主线程等待AOF日志的写完成。
-  从库加载 RDB 文件”，从库要想对客户端提供数据存取服务，就必须把RDB文件加载完成，不能启用子进程。



Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。
