---
layout: post
title: 2024-01-02-第031章-MySQL 表级锁.md
categories: [MySQL]
description: 
keywords: MySQL 表级锁.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# 表级锁

Mysql中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

锁作用于整个表，所有对表的操作都会收到锁限制。

MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

- 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。

**虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的**：

- 事务更新大表中的大部分数据直接使用表级锁效率更高；
- 事务比较复杂，使用行级索很可能引起死锁导致回滚。

## 表锁

表锁可以分为**表读锁**和**表写锁**。

需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。

也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。

在表读锁和表写锁的环境下：**读读不阻塞，读写阻塞，写写阻塞**！

- 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
- 读写阻塞：当前用户在读数据，其他的用户**不能修改当前用户读的数据**，会加锁！
- 写写阻塞：当前用户在修改数据，其他的用户**不能修改当前用户正在修改的数据**，会加锁！

**读锁和写锁是互斥的，读写操作是串行**。

- 如果某个进程想要获取读锁，**同时**另外一个进程想要获取写锁。在mysql里边，**写锁是优先于读锁的**！
- 写锁和读锁优先级的问题是可以通过参数调节的：`max_write_lock_count`和`low-priority-updates`

尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能。

### 语法

```sql
# 表级别的共享锁，也就是读锁；
lock tables student read;

# 表级别的独占锁，也就是写锁；
lock tables stuent write;

# 释放当前会话的所有表锁，另外，当会话退出后，也会释放所有表锁。
unlock tables;
```

表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。

Innodb 存储引擎提供表级锁，在执行 DDL 语句时会添加表级锁，此时会阻断所有的增删改操作；执行增删改操作会阻塞 DDL 执行。

- 表级独占锁：LOCK TABLES {table_name} WRITE
- 表级共享锁：LOCK TABLES {table_name} READ
- 意向独占锁：执行增删改时，会自动在表上添加。
- 意向共享锁：执行查询操作时，会自动在表上添加。

所有的意向锁之间都是兼容的，就是说所有的事务都可以在同一时间对表内的数据进行增删改查操作。

1. 意向独占锁和表级独占锁是互斥的，所以在执行 DDL 语句修改表时，会阻塞所有的增删改操作；反之，执行增删改操作会阻塞 DDL 执行。
2. 意向共享锁和表级独占锁是互斥的，所以在事务执行查询操作时，会阻塞 DDL 执行；反之，在执行 DDL 语句时，会阻塞所有的查询操作。
3. 表级共享锁和表级独占锁、意向独占锁是互斥的，加上这个锁就不允许对这个表的数据进行增删改操作，只能读数据。
4. 表级独占锁与其它锁都是互斥的，加上这个锁就不允许对表进行任何读写操作。

事务之间的增删改查不会被意向锁相互影响，但是增删改查的意向锁和表级独占锁是互斥的，意思就是执行增删改查时，不允许修改表；反之，修改表时，不允许增删改查。

## 元数据锁MDL

MDL主要作用是防止DDL和DML并发的冲突，是在Server层面实现的。

### 创建元数据锁

当我们对数据库表进行操作时，会自动给这个表加上**元数据锁**MDL：

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

- 当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。
- 反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。

加读锁则所有线程可正常读元数据，不影响增删改查操作，只是不能修改表结构；加写锁则只有拥有锁的线程可以读写元数据，也就是修改表结构，其它线程不能执行任何操作，包括修改表结构与增删改查。

### 释放元数据锁

MDL 是在事务提交后才会释放，这意味着**事务执行期间，MDL 是一直持有的**。

### Online DDL

> @since MySQL 5.6

MySQL在5.6之后开始支持Online DDL，可以保证在执行DDL语句时不会阻塞DML了。Online DDL的过程是这样的，1、2、4、5如果没有锁冲突，执行时间非常短：

1. 拿MDL写锁
2. 降级成MDL读锁
3. 真正做DDL
4. 升级成MDL写锁
5. 释放MDL锁

### 示例场景

#### 读写竞争

> MySQL 5.6

如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：


| SessionA                                        | SessionB                                        | SessionC                                                | SessionD                                              |
| ----------------------------------------------- | ----------------------------------------------- | ------------------------------------------------------- | ----------------------------------------------------- |
| begin                                           |                                                 |                                                         |                                                       |
| select * from student limit 1;<br />(加MDL读锁) |                                                 |                                                         |                                                       |
|                                                 | select * from student limit 1;<br />(加MDL读锁) |                                                         |                                                       |
|                                                 |                                                 | alter table student add age int;<br />(加MDL写锁，阻塞) |                                                       |
|                                                 |                                                 |                                                         | select * from student limit 1;<br />(加MDL读锁，阻塞) |

1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
2. 然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，

那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞。这是因为申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。

#### 小表加字段

有未提交的事务时因为MDL锁无法修改表字段，而且在存在长事务时执行修改表字段命令是一个危险的操作，可能阻塞其它增删改查请求，或导致线程爆满。

- 解决长事务，事务不提交，就会一直占着 MDL 锁。要考虑先暂停 DDL，或者 kill 掉这个长事务。这种方式对于热点表可能不适用，因为新的事务请求很快就会触发。
- 比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。

```sql
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```

## 意向锁

> 如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。

当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。

而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。

如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。**意向共享锁和意向排它锁可以同时并存多个。**

**为了允许行锁和表锁共存，实现多粒度锁机制**，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**。

`意向锁是有数据引擎自己维护的，用户无法手动操作意向锁`，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。

### 意向锁原理

因为共享锁与排他锁`互斥`，所以事务 B 在对 `users`表加共享锁的时候，必须保证：

- 当前没有其他事务持有 users 表的表排他锁。
- 当前没有其他事务持有 users 表中任意一行的排他锁  。

为了检测是否满足第二个条件，事务 B 必须在确保 `users`表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了**意向锁**之后，情况就不一样了：

**意向锁之间是互相兼容的**，它会与普通的**表级排他 / 共享锁**互斥。

`事务 A` 先获取了某一行的**排他锁**，并未提交：

```sql
SELECT * FROM users WHERE id = 6 FOR UPDATE;
```

1. `事务 A` 获取了 `users` 表上的**意向排他锁**。
2. `事务 A` 获取了 id 为 6 的数据行上的**排他锁**。

之后`事务 B` 想要获取 `users` 表的**共享锁**：

```sql
LOCK TABLES users READ;
```

1. `事务 B` 检测到`事务 A` 持有 `users` 表的**意向排他锁**。
2. `事务 B` 对 `users` 表的加锁请求被阻塞（排斥）。

最后`事务 C` 也想获取 `users` 表中某一行的**排他锁**：

```sql
SELECT * FROM users WHERE id = 5 FOR UPDATE;
```

1. `事务 C` 申请 `users` 表的**意向排他锁**。
2. `事务 C` 检测到`事务 A` 持有 `users` 表的**意向排他锁**。
3. 因为意向锁之间并不互斥，所以`事务 C` 获取到了 `users` 表的**意向排他锁**。
4. 因为id 为 5 的数据行上不存在任何**排他锁**，最终`事务 C` 成功获取到了该数据行上的**排他锁**。

### 意向共享锁

意向共享锁（IS）指事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

### 意向排它锁

意向排他锁（IX）指事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

### 总结

也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（\*lock tables ... read\*）和独占表锁（\*lock tables ... write\*）发生冲突。**

表锁和行锁是满足读读共享、读写互斥、写写互斥的。

如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。

那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。

所以，**意向锁的目的是为了快速判断表里是否有记录被加锁**。


|                | 意向共享锁 | 意向排他锁 | 表共享锁 | 表排他锁 | 行共享锁 | 行排他锁 |
| -------------- | ---------- | ---------- | -------- | -------- | -------- | -------- |
| **意向共享锁** | 兼容       | 兼容       | 兼容     | 互斥     | 兼容     | 兼容     |
| **意向排他锁** | 兼容       | 兼容       | 互斥     | 互斥     | 兼容     | 兼容     |

1. **这里的意向锁是表级锁，表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是InnoDB自动加的，不需要用户干预。**
2. **IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。**
3. InnoDB 支持`多粒度锁`，特定场景下，行级锁可以与表级锁共存。
4. 意向锁之间互不排斥，但除了 IS 与 S 兼容外，`意向锁会与 共享锁 / 排他锁 互斥`。
5. IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。
6. 意向锁在保证并发性的前提下，实现了`行锁和表锁共存`且`满足事务隔离性`的要求。

## AUTO-INC锁

在为某个字段声明 `AUTO_INCREMENT` 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。AUTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放**。

**在插入数据时，会加一个表级别的 AUTO-INC 锁**，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的。但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增。一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，**然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。

InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。

### 相关参数

#### innodb_autoinc_lock_mode

```sql
mysql> show variables like 'innodb_autoinc_lock_mode';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_autoinc_lock_mode | 2     |
+--------------------------+-------+
1 row in set (0.01 sec)
```

- 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁；
- 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁；
- 当 innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。

不过，当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，**这在有主从复制的场景中是不安全的**。