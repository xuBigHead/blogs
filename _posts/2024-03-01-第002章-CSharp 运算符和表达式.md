---
layout: post
title: 2024-03-01-第002章-CSharp 运算符和表达式.md
categories: [C#]
description: 
keywords: CSharp 运算符和表达式.md
mermaid: false
sequence: false
flow: false
mathjax: false
mindmap: false
mindmap2: false
---
# C# 运算符和表达式

## 概述

C# 提供了许多运算符。 其中许多都受到[内置类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/built-in-types)的支持，可用于对这些类型的值执行基本操作。 这些运算符包括以下组：

- [算术运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators)，将对数值操作数执行算术运算
- [比较运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators)，将比较数值操作数
- [布尔逻辑运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators)，将对 [`bool`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool) 操作数执行逻辑运算
- [位运算符和移位运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators)，将对整数类型的操作数执行位运算或移位运算
- [相等运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators)，将检查其操作数是否相等

通常可以[重载](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/operator-overloading)这些运算符，也就是说，可以为用户定义类型的操作数指定运算符行为。

最简单的 C# 表达式是文本（例如[整数](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types#integer-literals)和[实数](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types#real-literals)）和变量名称。 可以使用运算符将它们组合成复杂的表达式。 运算符[优先级](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/#operator-precedence)和[结合性](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/#operator-associativity)决定了表达式中操作的执行顺序。 可以使用括号更改由运算符优先级和结合性决定的计算顺序。



### 运算符优先级

在包含多个运算符的表达式中，先按优先级较高的运算符计算，再按优先级较低的运算符计算。下表按最高优先级到最低优先级的顺序列出 C# 运算符。 每行中运算符的优先级相同。

| 运算符                                                       | 类别或名称                                                   |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [x.y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#member-access-expression-)、[f(x)](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#invocation-expression-)、[a[i\]](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#indexer-operator-)、[`x?.y`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-)、[`x?[y\]`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-)、[x++](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#increment-operator-)、[x--](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#decrement-operator---)、[x!](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-forgiving)、[new](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/new-operator)、[typeof](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#typeof-operator)、[checked](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/checked)、[unchecked](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/unchecked)、[default](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/default)、[nameof](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/nameof)、[delegate](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/delegate-operator)、[sizeof](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/sizeof)、[stackalloc](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/stackalloc)、[x->y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/pointer-related-operators#pointer-member-access-operator--) | 主要                                                         |
| [+x](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#unary-plus-and-minus-operators)、[-x](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#unary-plus-and-minus-operators)、x[、](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#bitwise-complement-operator-)~x[、](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#increment-operator-)++x[、](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#decrement-operator---)--x[、](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#index-from-end-operator-)^x[、](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression)(T)x[、](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/await)await[、&&x](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/pointer-related-operators#address-of-operator-)、[*x](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/pointer-related-operators#pointer-indirection-operator-)、[true 和 false](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/true-false-operators) | 一元                                                         |
| [x..y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#range-operator-) | 范围                                                         |
| [switch](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/switch-expression)、[with](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/with-expression) | `switch` 和 `with` 表达式                                    |
| [x * y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#multiplication-operator-)、[x / y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#division-operator-)、[x % y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#remainder-operator-) | 乘法                                                         |
| [x + y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#addition-operator-)、[x – y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#subtraction-operator--) | 加法                                                         |
| [x << y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-)、[x >> y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#right-shift-operator-) | Shift                                                        |
| [x < y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators#less-than-operator-)、[x > y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators#greater-than-operator-)、[x <= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators#less-than-or-equal-operator-)、[x >= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/comparison-operators#greater-than-or-equal-operator-)、[is](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#is-operator)、[as](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator) | 关系和类型测试                                               |
| [x == y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators#equality-operator-)、[x != y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators#inequality-operator-) | 相等                                                         |
| `x & y`                                                      | [布尔逻辑 AND](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-and-operator-) 或[按位逻辑 AND](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#logical-and-operator-) |
| `x ^ y`                                                      | [布尔逻辑 XOR](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-exclusive-or-operator-) 或[按位逻辑 XOR](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#logical-exclusive-or-operator-) |
| `x | y`                                                      | [布尔逻辑 OR](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-or-operator-) 或[按位逻辑 OR](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#logical-or-operator-) |
| [x && y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-and-operator-) | 条件“与”                                                     |
| [x \|\| y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-or-operator-) | 条件“或”                                                     |
| [x ?? y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-coalescing-operator) | Null 合并运算符                                              |
| [c ? t : f](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/conditional-operator) | 条件运算符                                                   |
| [x = y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/assignment-operator)、[x += y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#compound-assignment)、[x -= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#compound-assignment)、[x *= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#compound-assignment)、[x /= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#compound-assignment)、[x %= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#compound-assignment)、[x &= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#compound-assignment)、[x \|= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#compound-assignment)、[x ^= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#compound-assignment)、[x <<= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#compound-assignment)、[x >>= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#compound-assignment)、[x ??= y](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-coalescing-operator)、[=>](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-operator) | 赋值和 lambda 声明                                           |



使用括号更改运算符优先级所施加的计算顺序：

```c#
var a = (2 + 2) * 2;
Console.WriteLine(a); //  output: 8
```



### 运算符结合性

当运算符的优先级相同，运算符的结合性决定了运算的执行顺序：

- 左结合运算符按从左到右的顺序计算。 除[赋值运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/assignment-operator)和 [null 合并运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-coalescing-operator)外，所有二元运算符都是左结合运算符。 例如，`a + b - c` 将计算为 `(a + b) - c`。
- 右结合运算符按从右到左的顺序计算。 赋值运算符、null 合并运算符、lambda 和[条件运算符`?:`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/conditional-operator)是右结合运算符。 例如，`x = y = z` 将计算为 `x = (y = z)`。



使用括号更改运算符结合性所施加的计算顺序：

```c#
int a = 13 / 5 / 2;
int b = 13 / (5 / 2);
Console.WriteLine($"a = {a}, b = {b}");  // output: a = 1, b = 6
```



### 操作数计算

与运算符的优先级和结合性无关，从左到右计算表达式中的操作数。 以下示例展示了运算符和操作数的计算顺序：

| 表达式            | 计算顺序            |
| :---------------- | :------------------ |
| `a + b`           | a, b, +             |
| `a + b * c`       | a, b, c, *, +       |
| `a / b + c * d`   | a, b, /, c, d, *, + |
| `a / (b + c) * d` | a, b, c, +, /, d, * |



通常，会计算所有运算符操作数。 但是，某些运算符有条件地计算操作数。 也就是说，此类运算符的最左侧操作数的值定义了是否应计算其他操作数，或计算其他哪些操作数。 这些运算符有条件逻辑 [AND (`&&`)](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-and-operator-) 和 [OR (`||`)](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-or-operator-) 运算符、[null 合并运算符 `??` 和 `??=`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-coalescing-operator)、[null 条件运算符 `?.` 和 `?[]`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-) 以及[条件运算符`?:`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/conditional-operator)。



## 算数运算符

以下运算符对数值类型的操作数执行算术运算：

- 一元 [`++`（增量）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#increment-operator-)、[`--`（减量）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#decrement-operator---)、[`+`（加）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#unary-plus-and-minus-operators)和 [`-`（减）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#unary-plus-and-minus-operators)运算符
- 二元 [`*`（乘法）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#multiplication-operator-)、[`/`（除法）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#division-operator-)、[`%`（余数）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#remainder-operator-)、[`+`（加法）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#addition-operator-)和 [`-`（减法）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/arithmetic-operators#subtraction-operator--)运算符

所有[整型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)和[浮点](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)数值类型都支持这些运算符。

对于整型类型，这些运算符（除 `++` 和 `--` 运算符以外）是为 `int`、`uint`、`long` 和 `ulong` 类型定义的。 如果操作数都是其他整型类型（`sbyte`、`byte`、`short`、`ushort` 或 `char`），它们的值将转换为 `int` 类型，这也是一个运算的结果类型。 如果操作数是不同的整型类型或浮点类型，它们的值将转换为最接近的包含类型（如果存在该类型）。 



### 增量运算符 ++

一元增量运算符 `++` 按 1 递增其操作数。 操作数必须是变量、[属性](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/properties)访问或[索引器](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/indexers/)访问。

增量运算符以两种形式进行支持：后缀增量运算符 `x++` 和前缀增量运算符 `++x`。`x++` 的结果是此操作前的 `x`的值，`++x` 的结果是此操作后的 `x`的值。

```c#
int i = 3;
Console.WriteLine(i);   // output: 3
Console.WriteLine(i++); // output: 3
Console.WriteLine(++i); // output: 5
```



### 减量运算符 --

一元减量运算符 `--` 按 1 递减其操作数。 操作数必须是变量、[属性](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/properties)访问或[索引器](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/indexers/)访问。

减量运算符以两种形式进行支持：后缀减量运算符`x--` 和前缀减量运算符 `--x`。`x--` 的结果是此操作前的 `x`的值，`--x` 的结果是此操作后的 `x`的值。

```c#
int i = 3;
Console.WriteLine(i);   // output: 3
Console.WriteLine(i--); // output: 3
Console.WriteLine(--i); // output: 1
```



### 一元加和减运算符

一元 `+` 运算符返回其操作数的值。 一元 `-` 运算符对其操作数的数值取负。[ulong](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types) 类型不支持一元 `-` 运算符。

```c#
Console.WriteLine(+4);     // output: 4

Console.WriteLine(-4);     // output: -4
Console.WriteLine(-(-4));  // output: 4

uint a = 5;
var b = -a;
Console.WriteLine(b);            // output: -5
Console.WriteLine(b.GetType());  // output: System.Int64

Console.WriteLine(-double.NaN);  // output: NaN
```



### 加减乘除及余数运算符

| 运算符 | 描述                             | 实例             |
| :----- | :------------------------------- | :--------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30  |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
| *      | 把两个操作数相乘                 | A * B 将得到 200 |
| /      | 分子除以分母                     | B / A 将得到 2   |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0   |



### 复合赋值

对于二元运算符 `op` 复合赋值表达式：`x op= y` 等价于 `x = x op y` 。

```c#
int a = 5;
a += 9;
Console.WriteLine(a);  // output: 14

a -= 4;
Console.WriteLine(a);  // output: 10

a *= 2;
Console.WriteLine(a);  // output: 20

a /= 4;
Console.WriteLine(a);  // output: 5

a %= 3;
Console.WriteLine(a);  // output: 2
```



由于[数值提升](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/expressions#1247-numeric-promotions)，`op` 运算的结果可能不会隐式转换为 `x` 的 `T` 类型。 在这种情况下，如果 `op` 是预定义的运算符并且运算的结果可以显式转换为 `x` 的类型 `T`，则形式为 `x op= y` 的复合赋值表达式等效于 `x = (T)(x op y)`，但 `x` 仅计算一次。 以下示例演示了该行为：

```c#
byte a = 200;
byte b = 100;

var c = a + b;
Console.WriteLine(c.GetType());  // output: System.Int32
Console.WriteLine(c);  // output: 300

a += b;
Console.WriteLine(a);  // output: 44
```



### 运算符优先级和关联性

以下列表对优先级由高到低的顺序对算术运算符进行排序：

- 后缀增量 `x++` 和减量 `x--` 运算符
- 前缀增量 `++x` 和减量 `--x` 以及一元 `+` 和 `-` 运算符
- 乘法 `*`、`/` 和 `%` 运算符
- 加法 `+` 和 `-` 运算符



二元算数运算符是左结合运算符。 也就是说，具有相同优先级的运算符按从左至右的顺序计算。使用括号 `()` 更改由运算符优先级和关联性决定的计算顺序。



### 算术溢出和被零除

当算术运算的结果超出所涉及数值类型的可能有限值范围时，算术运算符的行为取决于其操作数的类型。



#### 整数算术溢出

整数被零除总是引发 [DivideByZeroException](https://learn.microsoft.com/zh-cn/dotnet/api/system.dividebyzeroexception)。如果发生整数算术溢出，溢出检查上下文（可能[已检查或未检查](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked)）将控制引发的行为：

- 在已检查的上下文中，如果在常数表达式中发生溢出，则会发生编译时错误。 否则，当在运行时执行此运算时，则引发 [OverflowException](https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception)。
- 在未检查的上下文中，会通过丢弃任何不适应目标类型的高序位来将结果截断。

在使用 [checked 和 unchecked](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked) 语句时，可以使用 `checked` 和 `unchecked` 运算符来控制溢出检查上下文，在该上下文中将计算一个表达式：

```csharp
int a = int.MaxValue;
int b = 3;

Console.WriteLine(unchecked(a + b));  // output: -2147483646
try
{
    int d = checked(a + b);
}
catch(OverflowException)
{
    Console.WriteLine($"Overflow occurred when adding {a} to {b}.");
}
```



默认情况下，算术运算发生在 *unchecked* 上下文中。



#### 浮点运算溢出

使用 `float` 和 `double` 类型的算术运算永远不会引发异常。 使用这些类型的算术运算的结果可能是表示无穷大和非数字的特殊值之一：

```c#
double a = 1.0 / 0.0;
Console.WriteLine(a);                    // output: Infinity
Console.WriteLine(double.IsInfinity(a)); // output: True

Console.WriteLine(double.MaxValue + double.MaxValue); // output: Infinity

double b = 0.0 / 0.0;
Console.WriteLine(b);                // output: NaN
Console.WriteLine(double.IsNaN(b));  // output: True
```



对于 `decimal` 类型的操作数，算术溢出始终会引发 OverflowException。 被零除总是引发 DivideByZeroException。



#### 舍入误差

由于实数和浮点运算的浮点表达形式的常规限制，在使用浮点类型的计算中可能会发生舍入误差。 也就是说，表达式得出的结果可能与预期的数学运算结果不同。 以下示例演示了几种此类情况：

```c#
Console.WriteLine(.41f % .2f); // output: 0.00999999

double a = 0.1;
double b = 3 * a;
Console.WriteLine(b == 0.3);   // output: False
Console.WriteLine(b - 0.3);    // output: 5.55111512312578E-17

decimal c = 1 / 3.0m;
decimal d = 3 * c;
Console.WriteLine(d == 1.0m);  // output: False
Console.WriteLine(d);          // output: 0.9999999999999999999999999999
```



#### 运算符可重载性

用户定义类型可以[重载](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/operator-overloading)一元（`++`、`--`、`+` 和 `-`）和二元（`*`、`/`、`%`、`+` 和 `-`）算术运算符。 重载二元运算符时，对应的复合赋值运算符也会隐式重载。 用户定义类型不能显式重载复合赋值运算符。



##### 已检查的用户定义的运算符

从 C# 11 开始，重载算术运算符时，可以使用 `checked` 关键字定义该运算符的已检查版本。 下面的示例演示如何执行此操作：

```csharp
public record struct Point(int X, int Y)
{
    public static Point operator checked +(Point left, Point right)
    {
        checked
        {
            return new Point(left.X + right.X, left.Y + right.Y);
        }
    }
    
    public static Point operator +(Point left, Point right)
    {
        return new Point(left.X + right.X, left.Y + right.Y);
    }
}
```



定义已检查的运算符时，还必须定义不带 `checked` 修饰符的相应运算符。 checked 运算符在[已检查的上下文](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked)中调用；不带 `checked` 修饰符的运算符在[未检查的上下文](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked)中调用。 如果你只提供了不带 `checked` 修饰符的运算符，则会在 `checked` 和 `unchecked` 上下文中调用该运算符。

定义这两个版本的运算符时，预期其行为仅在操作结果过大而无法在结果类型中表示时有所不同，如下所示：

- 已检查的运算符引发 [OverflowException](https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception)。
- 不带 `checked` 修饰符的运算符返回表示截断结果的实例。



仅当重载以下任意运算符时，才能使用 `checked` 修饰符：

- 一元 `++`、`--` 和 `-` 运算符
- 二元 `*`、`/`、`+` 和 `-` 运算符
- [显式转换运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/user-defined-conversion-operators)



## Boolean 逻辑运算符

逻辑布尔运算符使用 [bool](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool) 操作数执行逻辑运算。 运算符包括一元逻辑非 (`!`)、二元逻辑 AND (`&`)、OR (`|`) 以及异或 (`^`)，二元条件逻辑 AND (`&&`) 和 OR (`||`)。

- 一元 [`!`（逻辑非）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-negation-operator-)运算符。
- 二元 [`&`（逻辑与）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-and-operator-)、[`|`（逻辑或）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-or-operator-)和 [`^`（逻辑异或）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-exclusive-or-operator-)运算符。 这些运算符始终计算两个操作数。
- 二元 [`&&`（条件逻辑与）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-and-operator-)和 [`||`（条件逻辑或）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-or-operator-)运算符。 这些运算符仅在必要时才计算右侧操作数。



### 逻辑非运算符 !

一元前缀 `!` 运算符计算操作数的逻辑非。 也就是说，如果操作数的计算结果为 `false`，它生成 `true`；如果操作数的计算结果为 `true`，它生成 `false`：

```c#
bool passed = false;
Console.WriteLine(!passed);  // output: True
Console.WriteLine(!true);    // output: False
```



### 逻辑“与”运算符 &

`&` 运算符计算操作数的逻辑与。 如果 `x` 和 `y` 的计算结果都为 `true`，则 `x & y` 的结果为 `true`。 否则，结果为 `false`。

`&` 运算符总是计算两个操作数。 当左侧操作数的计算结果为 `false` 时，运算结果为 `false`，而与右侧操作数的值无关。 但是，即使在这种情况下，也会计算右侧操作数。

在下面的示例中，`&` 运算符的右侧操作数是方法调用，无论左侧操作数的值如何，都会执行方法调用：

```c#
bool SecondOperand()
{
    Console.WriteLine("Second operand is evaluated.");
    return true;
}

bool a = false & SecondOperand();
Console.WriteLine(a);
// Output:
// Second operand is evaluated.
// False

bool b = true & SecondOperand();
Console.WriteLine(b);
// Output:
// Second operand is evaluated.
// True
```



### 逻辑异或运算符 ^

`^` 运算符计算操作数的逻辑异或（亦称为“逻辑 XOR”）。 如果 `x` 计算结果为 `true` 且 `y` 计算结果为 `false`，或者 `x` 计算结果为 `false` 且 `y` 计算结果为 `true`，那么 `x ^ y` 的结果为 `true`。 否则，结果为 `false`。 也就是说，对于 `bool` 操作数，`^` 运算符的计算结果与[不等运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/equality-operators#inequality-operator-)`!=` 相同。

```c#
Console.WriteLine(true ^ true);    // output: False
Console.WriteLine(true ^ false);   // output: True
Console.WriteLine(false ^ true);   // output: True
Console.WriteLine(false ^ false);  // output: False
```



### 逻辑或运算符 |

`|` 运算符计算操作数的逻辑或。 如果 `x` 或 `y` 的计算结果为 `true`，则 `x | y` 的结果为 `true`。 否则，结果为 `false`。

`|` 运算符总是计算两个操作数。 当左侧操作数的计算结果为 `true` 时，运算结果为 `true`，而与右侧操作数的值无关。 但是，即使在这种情况下，也会计算右侧操作数。

在下面的示例中，`|` 运算符的右侧操作数是方法调用，无论左侧操作数的值如何，都会执行方法调用：

```c#
bool SecondOperand()
{
    Console.WriteLine("Second operand is evaluated.");
    return true;
}

bool a = true | SecondOperand();
Console.WriteLine(a);
// Output:
// Second operand is evaluated.
// True

bool b = false | SecondOperand();
Console.WriteLine(b);
// Output:
// Second operand is evaluated.
// True
```



### 条件逻辑“与”运算符 &&

条件逻辑与运算符 `&&`（亦称为“短路”逻辑与运算符）计算操作数的逻辑与。 如果 `x` 和 `y` 的计算结果都为 `true`，则 `x && y` 的结果为 `true`。 否则，结果为 `false`。 如果 `x` 的计算结果为 `false`，则不计算 `y`。

在下面的示例中，`&&` 运算符的右侧操作数是方法调用，如果左侧操作数的计算结果为 `false`，就不执行方法调用：

```c#
bool SecondOperand()
{
    Console.WriteLine("Second operand is evaluated.");
    return true;
}

bool a = false && SecondOperand();
Console.WriteLine(a);
// Output:
// False

bool b = true && SecondOperand();
Console.WriteLine(b);
// Output:
// Second operand is evaluated.
// True
```



### 条件逻辑或运算符 ||

条件逻辑或运算符 `||`（亦称为“短路”逻辑或运算符）计算操作数的逻辑或。 如果 `x` 或 `y` 的计算结果为 `true`，则 `x || y` 的结果为 `true`。 否则，结果为 `false`。 如果 `x` 的计算结果为 `true`，则不计算 `y`。

在下面的示例中，`||` 运算符的右侧操作数是方法调用，如果左侧操作数的计算结果为 `true`，就不执行方法调用：

```c#
bool SecondOperand()
{
    Console.WriteLine("Second operand is evaluated.");
    return true;
}

bool a = true || SecondOperand();
Console.WriteLine(a);
// Output:
// True

bool b = false || SecondOperand();
Console.WriteLine(b);
// Output:
// Second operand is evaluated.
// True
```



### 可以为 null 的布尔逻辑运算符

对于 `bool?` 操作数，[`&`（逻辑与）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-and-operator-)和 [`|`（逻辑或）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-or-operator-)运算符支持三值逻辑，如下所示：

- 仅当其两个操作数的计算结果都为 `true` 时，`&` 运算符才生成 `true`。 如果 `x` 或 `y` 的计算结果为 `false`，则 `x & y` 将生成 `false`（即使另一个操作数的计算结果为 `null`）。 否则，`x & y` 的结果为 `null`。
- 仅当其两个操作数的计算结果都为 `false` 时，`|` 运算符才生成 `false`。 如果 `x` 或 `y` 的计算结果为 `true`，则 `x | y` 将生成 `true`（即使另一个操作数的计算结果为 `null`）。 否则，`x | y` 的结果为 `null`。

下表显示了该语义：

| x     | y     | x 和 y | x\|y  |
| :---- | :---- | :----- | :---- |
| true  | true  | true   | true  |
| true  | false | false  | true  |
| true  | null  | null   | true  |
| false | true  | false  | true  |
| false | false | false  | false |
| false | null  | false  | null  |
| null  | true  | null   | true  |
| null  | false | false  | null  |
| Null  | Null  | Null   | null  |



这些运算符的行为不同于值类型可以为 null 的典型运算符行为。 通常情况下，为值类型的操作数定义的运算符也能与值类型可以为 null 的相应操作数一起使用。 如果其任一操作数的计算结果为 `null`，此类运算符都会生成 `null`。 不过，即使操作数之一的计算结果为 `null`，`&` 和 `|` 运算符也可以生成非 null。 有关值类型可为空的运算符行为的详细信息，请参阅[可为空的值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types)一文的[提升的运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types#lifted-operators)部分。



此外，还可以将 `!` 和 `^` 运算符与 `bool?` 操作数结合使用，如下例所示：

```csharp
bool? test = null;
Display(!test);         // output: null
Display(test ^ false);  // output: null
Display(test ^ null);   // output: null
Display(true ^ null);   // output: null

void Display(bool? b) => Console.WriteLine(b is null ? "null" : b.Value.ToString());
```



条件逻辑运算符 `&&` 和 `||` 不支持 `bool?` 操作数。



### 复合赋值

对于二元运算符 `op` 复合赋值表达式：`x op= y` 等价于 `x = x op y` 。**条件逻辑运算符 `&&` 和 `||` 不支持复合赋值。**

```c#
bool test = true;
test &= false;
Console.WriteLine(test);  // output: False

test |= true;
Console.WriteLine(test);  // output: True

test ^= false;
Console.WriteLine(test);  // output: True
```



### 运算符优先级

以下列表按优先级从高到低的顺序对逻辑运算符进行排序：

- 逻辑非运算符 `!`
- 逻辑与运算符 `&`
- 逻辑异或运算符 `^`
- 逻辑或运算符 `|`
- 条件逻辑与运算符 `&&`
- 条件逻辑或运算符 `||`

使用括号 `()` 可以更改运算符优先级决定的计算顺序：



```c#
Console.WriteLine(true | true & false);   // output: True
Console.WriteLine((true | true) & false); // output: False

bool Operand(string name, bool value)
{
    Console.WriteLine($"Operand {name} is evaluated.");
    return value;
}

var byDefaultPrecedence = Operand("A", true) || Operand("B", true) && Operand("C", false);
Console.WriteLine(byDefaultPrecedence);
// Output:
// Operand A is evaluated.
// True

var changedOrder = (Operand("A", true) || Operand("B", true)) && Operand("C", false);
Console.WriteLine(changedOrder);
// Output:
// Operand A is evaluated.
// Operand C is evaluated.
// False
```



### 运算符可重载性

用户定义类型可以[重载](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/operator-overloading)`!`、`&`、`|` 和 `^` 运算符。 重载二元运算符时，对应的复合赋值运算符也会隐式重载。 用户定义类型不能显式重载复合赋值运算符。

用户定义类型无法重载条件逻辑运算符 `&&` 和 `||`。 不过，如果用户定义类型以某种方式重载 [true 和 false 运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/true-false-operators)以及 `&` 或 `|` 运算符，可以对相应类型的操作数执行 `&&` 或 `||` 运算。 



## 位运算符和移位运算符

位运算符和移位运算符包括一元位补、二进制左移和右移、无符号右移、二进制逻辑 AND、OR 和异或运算符。 这些操作数采用[整型数值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)或[字符型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/char)操作数。

- 一元 [`~`（按位求补）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#bitwise-complement-operator-)运算符
- 二进制 [`<<`（左移）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-)、[`>>`（右移）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#right-shift-operator-)和 [`>>>`（无符号右移）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#unsigned-right-shift-operator-)运算符
- 二进制 [`&`（逻辑 AND）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#logical-and-operator-)、[`|`（逻辑 OR）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#logical-or-operator-)和 [`^`（逻辑异或）](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#logical-exclusive-or-operator-)运算符

这些运算符是针对 `int`、`uint`、`long` 和 `ulong` 类型定义的。 如果两个操作数都是其他整数类型（`sbyte`、`byte`、`short`、`ushort` 或 `char`），它们的值将转换为 `int` 类型，这也是一个运算的结果类型。 如果操作数是不同的整数类型，它们的值将转换为最接近的包含整数类型。 复合运算符（如 `>>=`）不会将其参数转换为 `int`，也不会具有结果类型 `int`。`&`、`|` 和 `^` 运算符也是为 `bool` 类型的操作数定义的。 

位运算和移位运算永远不会导致溢出，并且不会在[已检查和未检查的](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked)上下文中产生相同的结果。



### 按位求补运算符 ~

`~` 运算符通过反转每个位产生其操作数的按位求补：

```c#
uint a = 0b_0000_1111_0000_1111_0000_1111_0000_1100;
uint b = ~a;
Console.WriteLine(Convert.ToString(b, toBase: 2));
// Output:
// 11110000111100001111000011110011
```



### 左移位运算符 <<

`<<` 运算符将其左侧操作数向左移动右侧操作数定义的位数。 左移运算会放弃超出结果类型范围的高阶位，并将低阶空位位置设置为零，如以下示例所示：

```c#
uint x = 0b_1100_1001_0000_0000_0000_0000_0001_0001;
Console.WriteLine($"Before: {Convert.ToString(x, toBase: 2)}");

uint y = x << 4;
Console.WriteLine($"After:  {Convert.ToString(y, toBase: 2)}");
// Output:
// Before: 11001001000000000000000000010001
// After:  10010000000000000000000100010000
```



由于移位运算符仅针对 `int`、`uint`、`long` 和 `ulong` 类型定义，因此运算的结果始终包含至少 32 位。 如果左侧操作数是其他整数类型（`sbyte`、`byte`、`short`、`ushort` 或 `char`），则其值将转换为 `int` 类型，如以下示例所示：

```c#
byte a = 0b_1111_0001;

var b = a << 8;
Console.WriteLine(b.GetType());
Console.WriteLine($"Shifted byte: {Convert.ToString(b, toBase: 2)}");
// Output:
// System.Int32
// Shifted byte: 1111000100000000
```



### 右移位运算符 >>

`>>` 运算符将其左侧操作数向右移动右侧操作数定义的位数。 右移位运算会放弃低阶位，如以下示例所示：

```c#
uint x = 0b_1001;
Console.WriteLine($"Before: {Convert.ToString(x, toBase: 2), 4}");

uint y = x >> 2;
Console.WriteLine($"After:  {Convert.ToString(y, toBase: 2).PadLeft(4, '0'), 4}");
// Output:
// Before: 1001
// After:  0010
```



高顺序空位位置是根据左侧操作数类型设置的，如下所示：

- 如果左侧操作数的类型是 `int` 或 `long`，则右移运算符将执行 算术移位：左侧操作数的最高有效位（符号位）的值将传播到高顺序空位位置。 也就是说，如果左侧操作数为非负，高顺序空位位置设置为零，如果为负，则将该位置设置为 1。

  ```csharp
  int a = int.MinValue;
  Console.WriteLine($"Before: {Convert.ToString(a, toBase: 2)}");
  
  int b = a >> 3;
  Console.WriteLine($"After:  {Convert.ToString(b, toBase: 2)}");
  // Output:
  // Before: 10000000000000000000000000000000
  // After:  11110000000000000000000000000000
  ```

  

- 如果左侧操作数的类型是 `uint` 或 `ulong`，则右移运算符执行逻辑移位：高顺序空位位置始终设置为零。

  ```csharp
  uint c = 0b_1000_0000_0000_0000_0000_0000_0000_0000;
  Console.WriteLine($"Before: {Convert.ToString(c, toBase: 2), 32}");
  
  uint d = c >> 3;
  Console.WriteLine($"After:  {Convert.ToString(d, toBase: 2).PadLeft(32, '0'), 32}");
  // Output:
  // Before: 10000000000000000000000000000000
  // After:  00010000000000000000000000000000
  ```



> 使用[无符号右移运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#unsigned-right-shift-operator-)可以对带符号整数类型的操作数执行逻辑移位。 这优于将左侧操作数强制转换为无符号类型，然后将移位操作的结果强制转换回带符号类型。



### 无符号右移运算符 >>>

在 C# 11 及更高版本中可用，`>>>` 运算符将其左侧操作数向右移动其右侧操作数定义的位数。

`>>>` 运算符始终执行逻辑移位。 也就是说，无论左侧操作数的类型如何，高顺序空位位置始终设置为零。 如果左侧操作数是带符号类型，[`>>` 运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#right-shift-operator-)将执行算术移位（即，最高有效位的值传播到高顺序空位位置）。 以下示例演示了对于负左操作数，`>>` 和 `>>>` 运算符之间的差别：

```c#
int x = -8;
Console.WriteLine($"Before:    {x,11}, hex: {x,8:x}, binary: {Convert.ToString(x, toBase: 2), 32}");

int y = x >> 2;
Console.WriteLine($"After  >>: {y,11}, hex: {y,8:x}, binary: {Convert.ToString(y, toBase: 2), 32}");

int z = x >>> 2;
Console.WriteLine($"After >>>: {z,11}, hex: {z,8:x}, binary: {Convert.ToString(z, toBase: 2).PadLeft(32, '0'), 32}");
// Output:
// Before:             -8, hex: fffffff8, binary: 11111111111111111111111111111000
// After  >>:          -2, hex: fffffffe, binary: 11111111111111111111111111111110
// After >>>:  1073741822, hex: 3ffffffe, binary: 00111111111111111111111111111110
```



### 与、异或、或运算符

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |



```c#
uint a = 0b_1111_1000;
uint b = 0b_0001_1100;
uint c = a ^ b;
Console.WriteLine(Convert.ToString(c, toBase: 2));
// Output:
// 11100100
```



### 复合赋值

对于二元运算符 `op` 复合赋值表达式：`x op= y` 等价于 `x = x op y` 。

```c#
uint INITIAL_VALUE = 0b_1111_1000;

uint a = INITIAL_VALUE;
a &= 0b_1001_1101; 
Display(a);  // output: 10011000

a = INITIAL_VALUE;
a |= 0b_0011_0001; 
Display(a);  // output: 11111001

a = INITIAL_VALUE;
a ^= 0b_1000_0000;
Display(a);  // output: 01111000

a = INITIAL_VALUE;
a <<= 2;
Display(a);  // output: 1111100000

a = INITIAL_VALUE;
a >>= 4;
Display(a);  // output: 00001111

a = INITIAL_VALUE;
a >>>= 4;
Display(a);  // output: 00001111

void Display(uint x) => Console.WriteLine($"{Convert.ToString(x, toBase: 2).PadLeft(8, '0'), 8}");
```



由于[数值提升](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/expressions#1247-numeric-promotions)，`op` 运算的结果可能不会隐式转换为 `x` 的 `T` 类型。 在这种情况下，如果 `op` 是预定义的运算符并且运算的结果可以显式转换为 `x` 的类型 `T`，则形式为 `x op= y` 的复合赋值表达式等效于 `x = (T)(x op y)`，但 `x` 仅计算一次。

```c#
byte x = 0b_1111_0001;

int b = x << 8;
Console.WriteLine($"{Convert.ToString(b, toBase: 2)}");  // output: 1111000100000000

x <<= 8;
Console.WriteLine(x);  // output: 0
```



### 运算符优先级

以下列表按位运算符和移位运算符从最高优先级到最低优先级排序：

- 按位求补运算符 `~`
- 移位运算符 `<<`、`>>` 和 `>>>`
- 逻辑与运算符 `&`
- 逻辑异或运算符 `^`
- 逻辑或运算符 `|`

使用括号 `()` 可以更改运算符优先级决定的计算顺序：

```c#
uint a = 0b_1101;
uint b = 0b_1001;
uint c = 0b_1010;

uint d1 = a | b & c;
Display(d1);  // output: 1101

uint d2 = (a | b) & c;
Display(d2);  // output: 1000

void Display(uint x) => Console.WriteLine($"{Convert.ToString(x, toBase: 2), 4}");
```



### 移位运算符的移位计数

对于内置移位运算符 `<<`、`>>` 和 `>>>`，右侧操作数的类型必须为 `int`，或具有[预定义隐式数值转换](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/numeric-conversions#implicit-numeric-conversions)为 `int` 的类型。

对于 `x << count`、`x >> count` 和 `x >>> count` 表达式，实际移位计数取决于 `x` 的类型，如下所示：

- 如果 `x` 的类型为 `int` 或 `uint`，则移位计数由右侧操作数的低阶五位定义。 也就是说，移位计数通过 `count & 0x1F`（或 `count & 0b_1_1111`）计算得出。
- 如果 `x` 的类型为 `long` 或 `ulong`，则移位计数由右侧操作数的低阶六位定义。 也就是说，移位计数通过 `count & 0x3F`（或 `count & 0b_11_1111`）计算得出。



以下示例演示了该行为：

```csharp
int count1 = 0b_0000_0001;
int count2 = 0b_1110_0001;

int a = 0b_0001;
Console.WriteLine($"{a} << {count1} is {a << count1}; {a} << {count2} is {a << count2}");
// Output:
// 1 << 1 is 2; 1 << 225 is 2

int b = 0b_0100;
Console.WriteLine($"{b} >> {count1} is {b >> count1}; {b} >> {count2} is {b >> count2}");
// Output:
// 4 >> 1 is 2; 4 >> 225 is 2

int count = -31;
int c = 0b_0001;
Console.WriteLine($"{c} << {count} is {c << count}");
// Output:
// 1 << -31 is 2
```

 

如前例所示，即使右侧操作符的值大于左侧操作符中的位数，移位运算的结果也不可为零。



### 枚举逻辑运算符

所有[枚举](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum)类型还支持 `~`、`&`、`|` 和 `^` 运算符。 对于相同枚举类型的操作数，对底层整数类型的相应值执行逻辑运算。 例如，对于具有底层类型 `U` 的枚举类型 `T` 的任何 `x` 和 `y`，`x & y` 表达式生成与 `(T)((U)x & (U)y)` 表达式相同的结果。

通常使用具有枚举类型的位逻辑运算符，该枚举类型使用 [Flags](https://learn.microsoft.com/zh-cn/dotnet/api/system.flagsattribute) 特性定义。 



### 运算符可重载性

用户定义的类型可以[重载](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/operator-overloading)`~`、`<<`、`>>`、`>>>`、`&`、`|` 和 `^` 运算符。 重载二元运算符时，对应的复合赋值运算符也会隐式重载。 用户定义类型不能显式重载复合赋值运算符。

如果用户定义类型 `T` 重载了 `<<`、`>>` 或 `>>>` 运算符，则左侧操作数的类型必须为 `T`。 在 C# 10 及更早版本中，右侧操作数的类型必须为 `int`；从 C# 11 开始，重载移位运算符的右侧操作数的类型可以是任意类型。



## 集合表达式

> Since C# 12

可以使用*集合表达式*来创建常见的集合值。 *集合表达式*是一种简洁的语法，在计算时，可以分配给许多不同的集合类型。 集合表达式在 `[` 和 `]` 括号之间包含元素的序列。 以下示例声明 `string` 元素的 [System.Span](https://learn.microsoft.com/zh-cn/dotnet/api/system.span-1)，并将其初始化为星期几：

```c#
Span<string> weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
foreach (var day in weekDays)
{
    Console.WriteLine(day);
}
```



*集合表达式*可以转换为许多不同的集合类型。 第一个示例演示了如何使用集合表达式初始化变量。 以下代码显示了可以使用集合表达式的其他许多位置：

```c#
// Initialize private field:
private static readonly ImmutableArray<string> _months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

// property with expression body:
public IEnumerable<int> MaxDays =>
    [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

public int Sum(IEnumerable<int> values) =>
    values.Sum();

public void Example()
{
    // As a parameter:
    int sum = Sum([1, 2, 3, 4, 5]);
}
```



不能使用需要编译时常量（例如初始化常量）或方法参数的默认值的集合表达式。上述两个示例都使用常量作为集合表达式的元素。 还可以对元素使用变量，如以下示例所示：

```c#
string hydrogen = "H";
string helium = "He";
string lithium = "Li";
string beryllium = "Be";
string boron = "B";
string carbon = "C";
string nitrogen = "N";
string oxygen = "O";
string fluorine = "F";
string neon = "Ne";
string[] elements = [hydrogen, helium, lithium, beryllium, boron, carbon, nitrogen, oxygen, fluorine, neon];
foreach (var element in elements)
{
    Console.WriteLine(element);
}
```



### 分布元素

使用*分布元素*`..`在集合表达式中使用内联集合值。 以下示例通过将元音集合、同音集合和字母“y”组合在一起，为完整字母创建一个集合，该集合可以是以下任一类型：

```csharp
string[] vowels = ["a", "e", "i", "o", "u"];
string[] consonants = ["b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
                       "n", "p", "q", "r", "s", "t", "v", "w", "x", "z"];
string[] alphabet = [.. vowels, .. consonants, "y"];
```



求值时，分布元素 `..vowels` 产生五个元素：`"a"`、`"e"`、`"i"`、`"o"` 和 `"u"`。 分布元素 `..consonants` 产生 20 个元素，即 `consonants` 数组中的数字。 分布元素中的变量必须使用 [`foreach`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement) 语句进行枚举。 如前面的示例所示，可以将分布元素与集合表达式中的单个元素组合在一起。



### 转换

*集合表达式*可以转换为不同的集合类型，包括：

- [System.Span](https://learn.microsoft.com/zh-cn/dotnet/api/system.span-1) 和 [System.ReadOnlySpan](https://learn.microsoft.com/zh-cn/dotnet/api/system.readonlyspan-1)
- [数组](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/arrays)
- 具有*创建*方法的任何类型，其参数类型为 `ReadOnlySpan<T>`，其中存在从集合表达式类型到 `T` 的隐式转换。
- 支持[集合初始值设定项](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#collection-initializers)的任何类型，例如 [System.Collections.Generic.List](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1)。 通常，此要求意味着类型支持 [System.Collections.Generic.IEnumerable](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.ienumerable-1)，并且有一个可访问的 `Add` 方法将项添加到集合中。 必须有从集合表达式元素类型到集合元素类型的隐式转换。 对于分布元素，必须有从分布元素类型到集合元素类型的隐式转换。

编译器使用静态分析来确定使用集合表达式声明的集合的最高性能方法。 例如，如果初始化后不会修改目标，则可以将空集合表达式 `[]` 实现为 [Array.Empty()](https://learn.microsoft.com/zh-cn/dotnet/api/system.array.empty#system-array-empty-1)。 当目标为 [System.Span](https://learn.microsoft.com/zh-cn/dotnet/api/system.span-1) 或 [System.ReadOnlySpan](https://learn.microsoft.com/zh-cn/dotnet/api/system.readonlyspan-1) 时，可以分配存储。 [集合表达式功能规范](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-12.0/collection-expressions)指定编译器必须遵循的规则。

许多 API 使用多个集合类型作为参数进行重载。 由于集合表达式可以转换为许多不同的表达式类型，因此这些 API 可能需要对集合表达式进行强制转换以指定正确的转换。 以下转换规则解决了一些歧义：

- 转换为 [Span](https://learn.microsoft.com/zh-cn/dotnet/api/system.span-1)、[ReadOnlySpan](https://learn.microsoft.com/zh-cn/dotnet/api/system.readonlyspan-1) 或其他 [`ref struct`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/ref-struct) 类型比转换为非 ref 结构类型更好。
- 转换为非接口类型比转换为接口类型更好。

当集合表达式转换为 `Span` 或 `ReadOnlySpan` 时，范围对象的*安全上下文* 取自范围中包含的所有元素*安全上下文*。



### 集合生成器

类型通过编写 `Create()` 方法和对集合类型应用 [System.Runtime.CompilerServices.CollectionBuilderAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.collectionbuilderattribute) 来指示生成器方法来选择加入集合表达式支持。 例如，请考虑使用固定长度缓冲区 80 个字符的应用程序。 该类可能类似于以下代码：

```csharp
public class LineBuffer : IEnumerable<char>
{
    private readonly char[] _buffer = new char[80];

    public LineBuffer(ReadOnlySpan<char> buffer)
    {
        int number = (_buffer.Length < buffer.Length) ? _buffer.Length : buffer.Length;
        for (int i = 0; i < number; i++)
        {
            _buffer[i] = buffer[i];
        }
    }

    public IEnumerator<char> GetEnumerator() => _buffer.AsEnumerable<char>().GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => _buffer.GetEnumerator();

    // etc
}
```



想要将其与集合表达式一起使用，如以下示例所示：

```csharp
LineBuffer line = ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'];
```

`

`LineBuffer` 类型实现 `IEnumerable<char>`，因此编译器将其识别为 `char` 项的集合。 实现的 [System.Collections.Generic.IEnumerable](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.ienumerable-1) 接口的类型参数指示元素类型。 需要向应用程序添加两个内容才能将集合表达式分配给 `LineBuffer` 对象。 首先，需要创建一个包含 `Create` 方法的类：

```csharp
internal static class LineBufferBuilder
{
    internal static LineBuffer Create(ReadOnlySpan<char> values) => new LineBuffer(values);
}
```



`Create` 方法必须返回 `LineBuffer` 对象，并且必须采用 `ReadOnlySpan<char>` 类型的单个参数。 `ReadOnlySpan` 的类型参数必须与集合的元素类型匹配。 返回泛型集合的生成器方法将泛型 `ReadOnlySpan<T>` 作为其参数。 该方法必须可访问且为 `static`。

最后，必须将 [CollectionBuilderAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.collectionbuilderattribute) 添加到 `LineBuffer` 类声明：

```csharp
[CollectionBuilder(typeof(LineBufferBuilder), "Create")]
```



第一个参数提供*生成器*类的名称。 第二个特性提供生成器方法的名称。



## 相等运算符
